(() => {
  // node_modules/@noble/hashes/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n, title = "") {
    if (!Number.isSafeInteger(n) || n < 0) {
      const prefix = title && `"${title}" `;
      throw new Error(`${prefix}expected integer >= 0, got ${n}`);
    }
  }
  function abytes(value, length, title = "") {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash must wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out, void 0, "digestInto() output");
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error('"digestInto() output" expected to be of length >=' + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i2 = 0; i2 < arrays.length; i2++) {
      arrays[i2].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  function byteSwap32(arr) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      arr[i2] = byteSwap(arr[i2]);
    }
    return arr;
  }
  var swap32IfBE = isLE ? (u) => u : byteSwap32;
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i2 = 0; i2 < bytes.length; i2++) {
      hex += hexes[bytes[i2]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function kdfInputToBytes(data, errorTitle = "") {
    if (typeof data === "string")
      return utf8ToBytes(data);
    return abytes(data, void 0, errorTitle);
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i2 = 0; i2 < arrays.length; i2++) {
      const a = arrays[i2];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i2 = 0, pad3 = 0; i2 < arrays.length; i2++) {
      const a = arrays[i2];
      res.set(a, pad3);
      pad3 += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
      throw new Error("options must be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function createHasher(hashCons, info = {}) {
    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
    const tmp = hashCons(void 0);
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    Object.assign(hashC, info);
    return Object.freeze(hashC);
  }
  function randomBytes(bytesLength = 32) {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    if (typeof cr?.getRandomValues !== "function")
      throw new Error("crypto.getRandomValues must be defined");
    return cr.getRandomValues(new Uint8Array(bytesLength));
  }
  var oidNist = (suffix) => ({
    oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
  });

  // node_modules/@noble/hashes/_md.js
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class {
    blockLen;
    outputLen;
    padOffset;
    isLE;
    // For partial updates less than block size
    buffer;
    view;
    finished = false;
    length = 0;
    pos = 0;
    destroyed = false;
    constructor(blockLen, outputLen, padOffset, isLE3) {
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer[i2] = 0;
      view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen must be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state[i2], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to ||= new this.constructor();
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);

  // node_modules/@noble/hashes/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA2_32B = class extends HashMD {
    constructor(outputLen) {
      super(64, outputLen, 8, false);
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W[i2 - 15];
        const W2 = SHA256_W[i2 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var _SHA256 = class extends SHA2_32B {
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    A = SHA256_IV[0] | 0;
    B = SHA256_IV[1] | 0;
    C = SHA256_IV[2] | 0;
    D = SHA256_IV[3] | 0;
    E = SHA256_IV[4] | 0;
    F = SHA256_IV[5] | 0;
    G = SHA256_IV[6] | 0;
    H = SHA256_IV[7] | 0;
    constructor() {
      super(32);
    }
  };
  var sha256 = /* @__PURE__ */ createHasher(
    () => new _SHA256(),
    /* @__PURE__ */ oidNist(1)
  );

  // node_modules/@noble/curves/utils.js
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  function abool(value, title = "") {
    if (typeof value !== "boolean") {
      const prefix = title && `"${title}" `;
      throw new Error(prefix + "expected boolean, got type=" + typeof value);
    }
    return value;
  }
  function abignumber(n) {
    if (typeof n === "bigint") {
      if (!isPosBig(n))
        throw new Error("positive bigint expected, got " + n);
    } else
      anumber(n);
    return n;
  }
  function numberToHexUnpadded(num2) {
    const hex = abignumber(num2).toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }
  function bytesToNumberLE(bytes) {
    return hexToNumber(bytesToHex(copyBytes(abytes(bytes)).reverse()));
  }
  function numberToBytesBE(n, len) {
    anumber(len);
    n = abignumber(n);
    const res = hexToBytes(n.toString(16).padStart(len * 2, "0"));
    if (res.length !== len)
      throw new Error("number too large");
    return res;
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }
  function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i2) => {
      const charCode = c.charCodeAt(0);
      if (c.length !== 1 || charCode > 127) {
        throw new Error(`string contains non-ASCII character "${ascii[i2]}" with code ${charCode} at position ${i2}`);
      }
      return charCode;
    });
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n) => (_1n << BigInt(n)) - _1n;
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    anumber(hashLen, "hashLen");
    anumber(qByteLen, "qByteLen");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const NULL = Uint8Array.of();
    const byte0 = Uint8Array.of(0);
    const byte1 = Uint8Array.of(1);
    const _maxDrbgIters = 1e3;
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i2 = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i2 = 0;
    };
    const h = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
    const reseed = (seed = NULL) => {
      k = h(byte0, seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(byte1, seed);
      v = h();
    };
    const gen = () => {
      if (i2++ >= _maxDrbgIters)
        throw new Error("drbg: tried max amount of iterations");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function validateObject(object, fields = {}, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));
    iter(fields, false);
    iter(optFields, true);
  }
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }

  // node_modules/@noble/curves/abstract/modular.js
  var _0n2 = /* @__PURE__ */ BigInt(0);
  var _1n2 = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _8n = /* @__PURE__ */ BigInt(8);
  var _9n = /* @__PURE__ */ BigInt(9);
  var _16n = /* @__PURE__ */ BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd2 = b;
    if (gcd2 !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n2) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
  }
  function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i2 = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
  }
  function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n) / _16n;
    return (Fp, n) => {
      let tv1 = Fp.pow(n, c4);
      let tv2 = Fp.mul(tv1, c1);
      const tv3 = Fp.mul(tv1, c2);
      const tv4 = Fp.mul(tv1, c3);
      const e1 = Fp.eql(Fp.sqr(tv2), n);
      const e2 = Fp.eql(Fp.sqr(tv3), n);
      tv1 = Fp.cmov(tv1, tv2, e1);
      tv2 = Fp.cmov(tv4, tv3, e2);
      const e3 = Fp.eql(Fp.sqr(tv2), n);
      const root = Fp.cmov(tv1, tv2, e3);
      assertIsSquare(Fp, root, n);
      return root;
    };
  }
  function tonelliShanks(P) {
    if (P < _3n)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp, n) {
      if (Fp.is0(n))
        return n;
      if (FpLegendre(Fp, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp.mul(Fp.ONE, cc);
      let t = Fp.pow(n, Q);
      let R = Fp.pow(n, Q1div2);
      while (!Fp.eql(t, Fp.ONE)) {
        if (Fp.is0(t))
          return Fp.ZERO;
        let i2 = 1;
        let t_tmp = Fp.sqr(t);
        while (!Fp.eql(t_tmp, Fp.ONE)) {
          i2++;
          t_tmp = Fp.sqr(t_tmp);
          if (i2 === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n2 << BigInt(M - i2 - 1);
        const b = Fp.pow(c, exponent);
        M = i2;
        c = Fp.sqr(b);
        t = Fp.mul(t, c);
        R = Fp.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n)
      return sqrt3mod4;
    if (P % _8n === _5n)
      return sqrt5mod8;
    if (P % _16n === _9n)
      return sqrt9mod16(P);
    return tonelliShanks(P);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    validateObject(field, opts);
    return field;
  }
  function FpPow(Fp, num2, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp.ONE;
    if (power === _1n2)
      return num2;
    let p = Fp.ONE;
    let d = num2;
    while (power > _0n2) {
      if (power & _1n2)
        p = Fp.mul(p, d);
      d = Fp.sqr(d);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num2, i2) => {
      if (Fp.is0(num2))
        return acc;
      inverted[i2] = acc;
      return Fp.mul(acc, num2);
    }, Fp.ONE);
    const invertedAcc = Fp.inv(multipliedAcc);
    nums.reduceRight((acc, num2, i2) => {
      if (Fp.is0(num2))
        return acc;
      inverted[i2] = Fp.mul(acc, inverted[i2]);
      return Fp.mul(acc, num2);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp, n) {
    const p1mod2 = (Fp.ORDER - _1n2) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  var _Field = class {
    ORDER;
    BITS;
    BYTES;
    isLE;
    ZERO = _0n2;
    ONE = _1n2;
    _lengths;
    _sqrt;
    // cached sqrt
    _mod;
    constructor(ORDER, opts = {}) {
      if (ORDER <= _0n2)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      this.isLE = false;
      if (opts != null && typeof opts === "object") {
        if (typeof opts.BITS === "number")
          _nbitLength = opts.BITS;
        if (typeof opts.sqrt === "function")
          this.sqrt = opts.sqrt;
        if (typeof opts.isLE === "boolean")
          this.isLE = opts.isLE;
        if (opts.allowedLengths)
          this._lengths = opts.allowedLengths?.slice();
        if (typeof opts.modFromBytes === "boolean")
          this._mod = opts.modFromBytes;
      }
      const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
      if (nByteLength > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      this.ORDER = ORDER;
      this.BITS = nBitLength;
      this.BYTES = nByteLength;
      this._sqrt = void 0;
      Object.preventExtensions(this);
    }
    create(num2) {
      return mod(num2, this.ORDER);
    }
    isValid(num2) {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < this.ORDER;
    }
    is0(num2) {
      return num2 === _0n2;
    }
    // is valid and invertible
    isValidNot0(num2) {
      return !this.is0(num2) && this.isValid(num2);
    }
    isOdd(num2) {
      return (num2 & _1n2) === _1n2;
    }
    neg(num2) {
      return mod(-num2, this.ORDER);
    }
    eql(lhs, rhs) {
      return lhs === rhs;
    }
    sqr(num2) {
      return mod(num2 * num2, this.ORDER);
    }
    add(lhs, rhs) {
      return mod(lhs + rhs, this.ORDER);
    }
    sub(lhs, rhs) {
      return mod(lhs - rhs, this.ORDER);
    }
    mul(lhs, rhs) {
      return mod(lhs * rhs, this.ORDER);
    }
    pow(num2, power) {
      return FpPow(this, num2, power);
    }
    div(lhs, rhs) {
      return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
    }
    // Same as above, but doesn't normalize
    sqrN(num2) {
      return num2 * num2;
    }
    addN(lhs, rhs) {
      return lhs + rhs;
    }
    subN(lhs, rhs) {
      return lhs - rhs;
    }
    mulN(lhs, rhs) {
      return lhs * rhs;
    }
    inv(num2) {
      return invert(num2, this.ORDER);
    }
    sqrt(num2) {
      if (!this._sqrt)
        this._sqrt = FpSqrt(this.ORDER);
      return this._sqrt(this, num2);
    }
    toBytes(num2) {
      return this.isLE ? numberToBytesLE(num2, this.BYTES) : numberToBytesBE(num2, this.BYTES);
    }
    fromBytes(bytes, skipValidation = false) {
      abytes(bytes);
      const { _lengths: allowedLengths, BYTES, isLE: isLE3, ORDER, _mod: modFromBytes } = this;
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE3 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE3 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!this.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    }
    // TODO: we don't need it here, move out to separate fn
    invertBatch(lst) {
      return FpInvertBatch(this, lst);
    }
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov(a, b, condition) {
      return condition ? b : a;
    }
  };
  function Field(ORDER, opts = {}) {
    return new _Field(ORDER, opts);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE3 = false) {
    abytes(key);
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
    return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // node_modules/@noble/curves/abstract/curve.js
  var _0n3 = /* @__PURE__ */ BigInt(0);
  var _1n3 = /* @__PURE__ */ BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, points) {
    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
    return points.map((p, i2) => c.fromAffine(p.toAffine(invertedZs[i2])));
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n3)
      throw new Error("invalid wNAF");
  }
  var wNAF = class {
    BASE;
    ZERO;
    Fn;
    bits;
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
      this.BASE = Point.BASE;
      this.ZERO = Point.ZERO;
      this.Fn = Point.Fn;
      this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
     * - ùëä is the window size
     * - ùëõ is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts(W, this.bits);
      const points = [];
      let p = point;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      if (!this.Fn.isValid(n))
        throw new Error("invalid scalar");
      let p = this.ZERO;
      let f = this.BASE;
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n);
      return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW(W, this.bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
    hasCache(elm) {
      return getW(elm) !== 1;
    }
  };
  function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n3 || k2 > _0n3) {
      if (k1 & _1n3)
        p1 = p1.add(acc);
      if (k2 & _1n3)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n3;
      k2 >>= _1n3;
    }
    return { p1, p2 };
  }
  function createField(order, field, isLE3) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField(field);
      return field;
    } else {
      return Field(order, { isLE: isLE3 });
    }
  }
  function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type === "edwards";
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n3))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
  }
  function createKeygen(randomSecretKey, getPublicKey2) {
    return function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey2(secretKey) };
    };
  }

  // node_modules/@noble/hashes/hmac.js
  var _HMAC = class {
    oHash;
    iHash;
    blockLen;
    outputLen;
    finished = false;
    destroyed = false;
    constructor(hash, key) {
      ahash(hash);
      abytes(key, void 0, "key");
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad3 = new Uint8Array(blockLen);
      pad3.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i2 = 0; i2 < pad3.length; i2++)
        pad3[i2] ^= 54;
      this.iHash.update(pad3);
      this.oHash = hash.create();
      for (let i2 = 0; i2 < pad3.length; i2++)
        pad3[i2] ^= 54 ^ 92;
      this.oHash.update(pad3);
      clean(pad3);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen, "output");
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to ||= Object.create(Object.getPrototypeOf(this), {});
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
  hmac.create = (hash, key) => new _HMAC(hash, key);

  // node_modules/@noble/curves/abstract/weierstrass.js
  var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
  function _splitEndoScalar(k, basis, n) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n4;
    const k2neg = k2 < _0n4;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n4;
    if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat(format) {
    if (!["compact", "recovered", "der"].includes(format))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
  }
  function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    abool(optsn.lowS, "lowS");
    abool(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat(optsn.format);
    return optsn;
  }
  var DERErr = class extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  var DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num2) {
        const { Err: E } = DER;
        if (num2 < _0n4)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num2);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(bytes) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = abytes(bytes, void 0, "signature");
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n2 = BigInt(2);
  var _3n2 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrass(params, extraOpts = {}) {
    const validated = createCurveFields("weierstrass", params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    validateObject(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object"
    });
    const { endo } = extraOpts;
    if (endo) {
      if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
      if (!Fp.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes2(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp.toBytes(x);
      abool(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp.isOdd(y);
        return concatBytes(pprefix(hasEvenY), bx);
      } else {
        return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
      }
    }
    function pointFromBytes(bytes) {
      abytes(bytes, void 0, "Point");
      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
      const length = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (length === comp && (head === 2 || head === 3)) {
        const x = Fp.fromBytes(tail);
        if (!Fp.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const evenY = Fp.isOdd(y);
        const evenH = (head & 1) === 1;
        if (evenH !== evenY)
          y = Fp.neg(y);
        return { x, y };
      } else if (length === uncomp && head === 4) {
        const L = Fp.BYTES;
        const x = Fp.fromBytes(tail.subarray(0, L));
        const y = Fp.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes2;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp.sqr(x);
      const x3 = Fp.mul(x2, x);
      return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
    }
    function isValidXY(x, y) {
      const left = Fp.sqr(y);
      const right = weierstrassEquation(x);
      return Fp.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp.isValid(n) || banZero && Fp.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point))
        throw new Error("Weierstrass Point expected");
    }
    function splitEndoScalarN(k) {
      if (!endo || !endo.basises)
        throw new Error("no endo");
      return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      if (Fp.eql(Z, Fp.ONE))
        return { x: X, y: Y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(Z);
      const x = Fp.mul(X, iz);
      const y = Fp.mul(Y, iz);
      const zz = Fp.mul(Z, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point {
      // base / generator point
      static BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      // zero / infinity / identity point
      static ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      // 0, 1, 0
      // math field
      static Fp = Fp;
      // scalar field
      static Fn = Fn;
      X;
      Y;
      Z;
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point)
          throw new Error("projective point not allowed");
        if (Fp.is0(x) && Fp.is0(y))
          return Point.ZERO;
        return new Point(x, y, Fp.ONE);
      }
      static fromBytes(bytes) {
        const P = Point.fromAffine(decodePoint(abytes(bytes, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point.fromBytes(hexToBytes(hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n2);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point(this.X, Fp.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp.mul(b, _3n2);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        let t0 = Fp.mul(X1, X1);
        let t1 = Fp.mul(Y1, Y1);
        let t2 = Fp.mul(Z1, Z1);
        let t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3);
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3);
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3);
        t2 = Fp.mul(a, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0);
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1);
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3);
        Z3 = Fp.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        const a = CURVE.a;
        const b3 = Fp.mul(CURVE.b, _3n2);
        let t0 = Fp.mul(X1, X2);
        let t1 = Fp.mul(Y1, Y2);
        let t2 = Fp.mul(Z1, Z2);
        let t3 = Fp.add(X1, Y1);
        let t4 = Fp.add(X2, Y2);
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        let t5 = Fp.add(X2, Z2);
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2);
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a, t4);
        X3 = Fp.mul(b3, t2);
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0);
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2);
        t2 = Fp.mul(a, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4);
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = extraOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul3 = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul3(k1);
          const { p: k2p, f: k2f } = mul3(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul3(scalar);
          point = p;
          fake = f;
        }
        return normalizeZ(Point, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = extraOpts;
        const p = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n4 || p.is0())
          return Point.ZERO;
        if (sc === _1n4)
          return p;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p, sc);
        }
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n4)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n4)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        abool(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    const bits = Fn.BITS;
    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8);
    return Point;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths(Fp, Fn) {
    return {
      secretKey: Fn.BYTES,
      publicKey: 1 + Fp.BYTES,
      publicKeyUncompressed: 1 + 2 * Fp.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn.BYTES
    };
  }
  function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        const num2 = Fn.fromBytes(secretKey);
        return Fn.isValidNot0(num2);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey, isCompressed) {
      const { publicKey: comp, publicKeyUncompressed } = lengths;
      try {
        const l = publicKey.length;
        if (isCompressed === true && l !== comp)
          return false;
        if (isCompressed === false && l !== publicKeyUncompressed)
          return false;
        return !!Point.fromBytes(publicKey);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField(abytes(seed, lengths.seed, "seed"), Fn.ORDER);
    }
    function getPublicKey2(secretKey, isCompressed = true) {
      return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);
    }
    function isProbPub(item) {
      const { secretKey, publicKey, publicKeyUncompressed } = lengths;
      if (!isBytes(item))
        return void 0;
      if ("_lengths" in Fn && Fn._lengths || secretKey === publicKey)
        return void 0;
      const l = abytes(item, void 0, "key").length;
      return l === publicKey || l === publicKeyUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s = Fn.fromBytes(secretKeyA);
      const b = Point.fromBytes(publicKeyB);
      return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey
    };
    const keygen = createKeygen(randomSecretKey, getPublicKey2);
    return Object.freeze({ getPublicKey: getPublicKey2, getSharedSecret, keygen, Point, utils, lengths });
  }
  function ecdsa(Point, hash, ecdsaOpts = {}) {
    ahash(hash);
    validateObject(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    ecdsaOpts = Object.assign({}, ecdsaOpts);
    const randomBytes3 = ecdsaOpts.randomBytes || randomBytes;
    const hmac2 = ecdsaOpts.hmac || ((key, msg) => hmac(hash, key, msg));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey: getPublicKey2, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
      prehash: true,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
      format: "compact",
      extraEntropy: false
    };
    const hasLargeCofactor = CURVE_ORDER * _2n2 < Fp.ORDER;
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n4;
      return number > HALF;
    }
    function validateRS(title, num2) {
      if (!Fn.isValidNot0(num2))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num2;
    }
    function assertSmallCofactor() {
      if (hasLargeCofactor)
        throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
    }
    function validateSigLength(bytes, format) {
      validateSigFormat(format);
      const size = lengths.signature;
      const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
      return abytes(bytes, sizer);
    }
    class Signature {
      r;
      s;
      recovery;
      constructor(r, s, recovery) {
        this.r = validateRS("r", r);
        this.s = validateRS("s", s);
        if (recovery != null) {
          assertSmallCofactor();
          if (![0, 1, 2, 3].includes(recovery))
            throw new Error("invalid recovery id");
          this.recovery = recovery;
        }
        Object.freeze(this);
      }
      static fromBytes(bytes, format = defaultSigOpts.format) {
        validateSigLength(bytes, format);
        let recid;
        if (format === "der") {
          const { r: r2, s: s2 } = DER.toSig(abytes(bytes));
          return new Signature(r2, s2);
        }
        if (format === "recovered") {
          recid = bytes[0];
          format = "compact";
          bytes = bytes.subarray(1);
        }
        const L = lengths.signature / 2;
        const r = bytes.subarray(0, L);
        const s = bytes.subarray(L, L * 2);
        return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
      }
      static fromHex(hex, format) {
        return this.fromBytes(hexToBytes(hex), format);
      }
      assertRecovery() {
        const { recovery } = this;
        if (recovery == null)
          throw new Error("invalid recovery id: must be present");
        return recovery;
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(messageHash) {
        const { r, s } = this;
        const recovery = this.assertRecovery();
        const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;
        if (!Fp.isValid(radj))
          throw new Error("invalid recovery id: sig.r+curve.n != R.x");
        const x = Fp.toBytes(radj);
        const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN(abytes(messageHash, void 0, "msgHash"));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("invalid recovery: point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format = defaultSigOpts.format) {
        validateSigFormat(format);
        if (format === "der")
          return hexToBytes(DER.hexFromSig(this));
        const { r, s } = this;
        const rb = Fn.toBytes(r);
        const sb = Fn.toBytes(s);
        if (format === "recovered") {
          assertSmallCofactor();
          return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
        }
        return concatBytes(rb, sb);
      }
      toHex(format) {
        return bytesToHex(this.toBytes(format));
      }
    }
    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num2 = bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - fnBits;
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
      return Fn.create(bits2int(bytes));
    };
    const ORDER_MASK = bitMask(fnBits);
    function int2octets(num2) {
      aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
      return Fn.toBytes(num2);
    }
    function validateMsgAndHash(message, prehash) {
      abytes(message, void 0, "message");
      return prehash ? abytes(hash(message), void 0, "prehashed message") : message;
    }
    function prepSig(message, secretKey, opts) {
      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      const h1int = bits2int_modN(message);
      const d = Fn.fromBytes(secretKey);
      if (!Fn.isValidNot0(d))
        throw new Error("invalid private key");
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e = extraEntropy === true ? randomBytes3(lengths.secretKey) : extraEntropy;
        seedArgs.push(abytes(e, void 0, "extraEntropy"));
      }
      const seed = concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n4)
          return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n4)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = Fn.neg(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, hasLargeCofactor ? void 0 : recovery);
      }
      return { seed, k2sig };
    }
    function sign(message, secretKey, opts = {}) {
      const { seed, k2sig } = prepSig(message, secretKey, opts);
      const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac2);
      const sig = drbg(seed, k2sig);
      return sig.toBytes(opts.format);
    }
    function verify(signature, message, publicKey, opts = {}) {
      const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
      publicKey = abytes(publicKey, void 0, "publicKey");
      message = validateMsgAndHash(message, prehash);
      if (!isBytes(signature)) {
        const end = signature instanceof Signature ? ", use sig.toBytes()" : "";
        throw new Error("verify expects Uint8Array signature" + end);
      }
      validateSigLength(signature, format);
      try {
        const sig = Signature.fromBytes(signature, format);
        const P = Point.fromBytes(publicKey);
        if (lowS && sig.hasHighS())
          return false;
        const { r, s } = sig;
        const h = bits2int_modN(message);
        const is = Fn.inv(s);
        const u1 = Fn.create(h * is);
        const u2 = Fn.create(r * is);
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn.create(R.x);
        return v === r;
      } catch (e) {
        return false;
      }
    }
    function recoverPublicKey(signature, message, opts = {}) {
      const { prehash } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      utils,
      lengths,
      Point,
      sign,
      verify,
      recoverPublicKey,
      Signature,
      hash
    });
  }

  // node_modules/@noble/curves/secp256k1.js
  var secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _0n5 = /* @__PURE__ */ BigInt(0);
  var _2n3 = /* @__PURE__ */ BigInt(2);
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n3, P) * b3 % P;
    const b9 = pow2(b6, _3n3, P) * b3 % P;
    const b11 = pow2(b9, _2n3, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n3, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n3, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
  var Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {
    Fp: Fpk1,
    endo: secp256k1_ENDO
  });
  var secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha256);
  var TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = sha256(asciiToBytes(tag));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return sha256(concatBytes(tagP, ...messages));
  }
  var pointToBytes = (point) => point.toBytes(true).slice(1);
  var hasEven = (y) => y % _2n3 === _0n5;
  function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = Fn.fromBytes(priv);
    const p = BASE.multiply(d_);
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return { scalar, bytes: pointToBytes(p) };
  }
  function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x))
      throw new Error("invalid x: Fail if x \u2265 p");
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7));
    let y = Fp.sqrt(c);
    if (!hasEven(y))
      y = Fp.neg(y);
    const p = Pointk1.fromAffine({ x, y });
    p.assertValidity();
    return p;
  }
  var num = bytesToNumberBE;
  function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes;
  }
  function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
    const { Fn } = Pointk1;
    const m = abytes(message, void 0, "message");
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
    const a = abytes(auxRand, 32, "auxRand");
    const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const { Fp, Fn, BASE } = Pointk1;
    const sig = abytes(signature, 64, "signature");
    const m = abytes(message, void 0, "message");
    const pub = abytes(publicKey, 32, "publicKey");
    try {
      const P = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!Fp.isValidNot0(r))
        return false;
      const s = num(sig.subarray(32, 64));
      if (!Fn.isValidNot0(s))
        return false;
      const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
      const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
      const { x, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  var schnorr = /* @__PURE__ */ (() => {
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = randomBytes(seedLength)) => {
      return mapHashToField(seed, secp256k1_CURVE.n);
    };
    return {
      keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      Point: Pointk1,
      utils: {
        randomSecretKey,
        taggedHash,
        lift_x,
        pointToBytes
      },
      lengths: {
        secretKey: size,
        publicKey: size,
        publicKeyHasPrefix: false,
        signature: size * 2,
        seed: seedLength
      }
    };
  })();

  // node_modules/@scure/base/index.js
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes2(b) {
    if (!isBytes2(b))
      throw new Error("Uint8Array expected");
  }
  function isArrayOf(isString, arr) {
    if (!Array.isArray(arr))
      return false;
    if (arr.length === 0)
      return true;
    if (isString) {
      return arr.every((item) => typeof item === "string");
    } else {
      return arr.every((item) => Number.isSafeInteger(item));
    }
  }
  function afn(input) {
    if (typeof input !== "function")
      throw new Error("function expected");
    return true;
  }
  function astr(label, input) {
    if (typeof input !== "string")
      throw new Error(`${label}: string expected`);
    return true;
  }
  function anumber2(n) {
    if (!Number.isSafeInteger(n))
      throw new Error(`invalid integer: ${n}`);
  }
  function aArr(input) {
    if (!Array.isArray(input))
      throw new Error("array expected");
  }
  function astrArr(label, input) {
    if (!isArrayOf(true, input))
      throw new Error(`${label}: array of strings expected`);
  }
  function anumArr(label, input) {
    if (!isArrayOf(false, input))
      throw new Error(`${label}: array of numbers expected`);
  }
  // @__NO_SIDE_EFFECTS__
  function chain(...args) {
    const id = (a) => a;
    const wrap2 = (a, b) => (c) => a(b(c));
    const encode = args.map((x) => x.encode).reduceRight(wrap2, id);
    const decode2 = args.map((x) => x.decode).reduce(wrap2, id);
    return { encode, decode: decode2 };
  }
  // @__NO_SIDE_EFFECTS__
  function alphabet(letters) {
    const lettersA = typeof letters === "string" ? letters.split("") : letters;
    const len = lettersA.length;
    astrArr("alphabet", lettersA);
    const indexes = new Map(lettersA.map((l, i2) => [l, i2]));
    return {
      encode: (digits) => {
        aArr(digits);
        return digits.map((i2) => {
          if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
            throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
          return lettersA[i2];
        });
      },
      decode: (input) => {
        aArr(input);
        return input.map((letter) => {
          astr("alphabet.decode", letter);
          const i2 = indexes.get(letter);
          if (i2 === void 0)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
          return i2;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function join(separator = "") {
    astr("join", separator);
    return {
      encode: (from) => {
        astrArr("join.decode", from);
        return from.join(separator);
      },
      decode: (to) => {
        astr("join.decode", to);
        return to.split(separator);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function padding(bits, chr = "=") {
    anumber2(bits);
    astr("padding", chr);
    return {
      encode(data) {
        astrArr("padding.encode", data);
        while (data.length * bits % 8)
          data.push(chr);
        return data;
      },
      decode(input) {
        astrArr("padding.decode", input);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("padding: invalid, string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          const last = end - 1;
          const byte = last * bits;
          if (byte % 8 === 0)
            throw new Error("padding: invalid, string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
  var powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i2 = 0; i2 < 40; i2++)
      res.push(2 ** i2);
    return res;
  })();
  function convertRadix2(data, from, to, padding2) {
    aArr(data);
    if (from <= 0 || from > 32)
      throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
      throw new Error(`convertRadix2: wrong to=${to}`);
    if (/* @__PURE__ */ radix2carry(from, to) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data) {
      anumber2(n);
      if (n >= max)
        throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
      carry = carry << from | n;
      if (pos + from > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to)
        res.push((carry >> pos - to & mask) >>> 0);
      const pow = powers[pos];
      if (pow === void 0)
        throw new Error("invalid carry");
      carry &= pow - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding2 && pos >= from)
      throw new Error("Excess padding");
    if (!padding2 && carry > 0)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  // @__NO_SIDE_EFFECTS__
  function radix2(bits, revPadding = false) {
    anumber2(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes) => {
        if (!isBytes2(bytes))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
      },
      decode: (digits) => {
        anumArr("radix2.decode", digits);
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e) {
      }
    };
  }
  var hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
  var decodeBase64Builtin = (s, isUrl) => {
    astr("base64", s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet2 = isUrl ? "base64url" : "base64";
    if (s.length > 0 && !re.test(s))
      throw new Error("invalid base64");
    return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
  };
  var base64 = hasBase64Builtin ? {
    encode(b) {
      abytes2(b);
      return b.toBase64();
    },
    decode(s) {
      return decodeBase64Builtin(s, false);
    }
  } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
  var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
      if ((b >> i2 & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i2];
    }
    return chk;
  }
  function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i2 = 0; i2 < len; i2++) {
      const c = prefix.charCodeAt(i2);
      if (c < 33 || c > 126)
        throw new Error(`Invalid prefix (${prefix})`);
      chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i2 = 0; i2 < len; i2++)
      chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
    for (let v of words)
      chk = bech32Polymod(chk) ^ v;
    for (let i2 = 0; i2 < 6; i2++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
  }
  // @__NO_SIDE_EFFECTS__
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = /* @__PURE__ */ radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
      astr("bech32.encode prefix", prefix);
      if (isBytes2(words))
        words = Array.from(words);
      anumArr("bech32.encode", words);
      const plen = prefix.length;
      if (plen === 0)
        throw new TypeError(`Invalid prefix length ${plen}`);
      const actualLength = plen + 7 + words.length;
      if (limit !== false && actualLength > limit)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      const lowered = prefix.toLowerCase();
      const sum = bechChecksum(lowered, words, ENCODING_CONST);
      return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode2(str, limit = 90) {
      astr("bech32.decode input", str);
      const slen = str.length;
      if (slen < 8 || limit !== false && slen > limit)
        throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      const sepIndex = lowered.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix = lowered.slice(0, sepIndex);
      const data = lowered.slice(sepIndex + 1);
      if (data.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(data).slice(0, -6);
      const sum = bechChecksum(prefix, words, ENCODING_CONST);
      if (!data.endsWith(sum))
        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode2);
    function decodeToBytes(str) {
      const { prefix, words } = decode2(str, false);
      return { prefix, words, bytes: fromWords(words) };
    }
    function encodeFromBytes(prefix, bytes) {
      return encode(prefix, toWords(bytes));
    }
    return {
      encode,
      decode: decode2,
      encodeFromBytes,
      decodeToBytes,
      decodeUnsafe,
      fromWords,
      fromWordsUnsafe,
      toWords
    };
  }
  var bech32 = /* @__PURE__ */ genBech32("bech32");

  // node_modules/@noble/ciphers/utils.js
  function isBytes3(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool2(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber3(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes3(value, length, title = "") {
    const bytes = isBytes3(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes3(out, void 0, "output");
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u322(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i2 = 0; i2 < arrays.length; i2++) {
      arrays[i2].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function overlapBytes(a, b) {
    return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
    b.byteOffset < a.byteOffset + a.byteLength;
  }
  function complexOverlapBytes(input, output) {
    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
      throw new Error("complex overlap of input and output is not supported");
  }
  function checkOpts2(defaults, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i2 = 0; i2 < a.length; i2++)
      diff |= a[i2] ^ b[i2];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes3(key, void 0, "key");
      if (!isLE2)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        abytes3(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0)
        abytes3(args[1], void 0, "AAD");
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output) => {
        if (output !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes3(output, void 0, "output");
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes3(data);
          checkOutput(cipher.encrypt.length, output);
          return cipher.encrypt(data, output);
        },
        decrypt(data, output) {
          abytes3(data);
          if (tagl && data.length < tagl)
            throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
          checkOutput(cipher.decrypt.length, output);
          return cipher.decrypt(data, output);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function u64Lengths(dataLength, aadLength, isLE3) {
    abool2(isLE3);
    const num2 = new Uint8Array(16);
    const view = createView2(num2);
    view.setBigUint64(0, BigInt(aadLength), isLE3);
    view.setBigUint64(8, BigInt(dataLength), isLE3);
    return num2;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes2(bytes) {
    return Uint8Array.from(bytes);
  }

  // node_modules/@noble/ciphers/aes.js
  var BLOCK_SIZE = 16;
  var POLY = 283;
  function validateKeyLength(key) {
    if (![16, 24, 32].includes(key.length))
      throw new Error('"aes key" expected Uint8Array of length 16/24/32, got length=' + key.length);
  }
  function mul2(n) {
    return n << 1 ^ POLY & -(n >> 7);
  }
  function mul(a, b) {
    let res = 0;
    for (; b > 0; b >>= 1) {
      res ^= a & -(b & 1);
      a = mul2(a);
    }
    return res;
  }
  var sbox = /* @__PURE__ */ (() => {
    const t = new Uint8Array(256);
    for (let i2 = 0, x = 1; i2 < 256; i2++, x ^= mul2(x))
      t[i2] = x;
    const box = new Uint8Array(256);
    box[0] = 99;
    for (let i2 = 0; i2 < 255; i2++) {
      let x = t[255 - i2];
      x |= x << 8;
      box[t[i2]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
    }
    clean2(t);
    return box;
  })();
  var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
  var rotr32_8 = (n) => n << 24 | n >>> 8;
  var rotl32_8 = (n) => n << 8 | n >>> 24;
  function genTtable(sbox2, fn) {
    if (sbox2.length !== 256)
      throw new Error("Wrong sbox length");
    const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
    const T1 = T0.map(rotl32_8);
    const T2 = T1.map(rotl32_8);
    const T3 = T2.map(rotl32_8);
    const T01 = new Uint32Array(256 * 256);
    const T23 = new Uint32Array(256 * 256);
    const sbox22 = new Uint16Array(256 * 256);
    for (let i2 = 0; i2 < 256; i2++) {
      for (let j = 0; j < 256; j++) {
        const idx = i2 * 256 + j;
        T01[idx] = T0[i2] ^ T1[j];
        T23[idx] = T2[i2] ^ T3[j];
        sbox22[idx] = sbox2[i2] << 8 | sbox2[j];
      }
    }
    return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
  }
  var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
  var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
  var xPowers = /* @__PURE__ */ (() => {
    const p = new Uint8Array(16);
    for (let i2 = 0, x = 1; i2 < 16; i2++, x = mul2(x))
      p[i2] = x;
    return p;
  })();
  function expandKeyLE(key) {
    abytes3(key);
    const len = key.length;
    validateKeyLength(key);
    const { sbox2 } = tableEncoding;
    const toClean = [];
    if (!isAligned32(key))
      toClean.push(key = copyBytes2(key));
    const k32 = u322(key);
    const Nk = k32.length;
    const subByte = (n) => applySbox(sbox2, n, n, n, n);
    const xk = new Uint32Array(len + 28);
    xk.set(k32);
    for (let i2 = Nk; i2 < xk.length; i2++) {
      let t = xk[i2 - 1];
      if (i2 % Nk === 0)
        t = subByte(rotr32_8(t)) ^ xPowers[i2 / Nk - 1];
      else if (Nk > 6 && i2 % Nk === 4)
        t = subByte(t);
      xk[i2] = xk[i2 - Nk] ^ t;
    }
    clean2(...toClean);
    return xk;
  }
  function expandKeyDecLE(key) {
    const encKey = expandKeyLE(key);
    const xk = encKey.slice();
    const Nk = encKey.length;
    const { sbox2 } = tableEncoding;
    const { T0, T1, T2, T3 } = tableDecoding;
    for (let i2 = 0; i2 < Nk; i2 += 4) {
      for (let j = 0; j < 4; j++)
        xk[i2 + j] = encKey[Nk - i2 - 4 + j];
    }
    clean2(encKey);
    for (let i2 = 4; i2 < Nk - 4; i2++) {
      const x = xk[i2];
      const w = applySbox(sbox2, x, x, x, x);
      xk[i2] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
    }
    return xk;
  }
  function apply0123(T01, T23, s0, s1, s2, s3) {
    return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
  }
  function applySbox(sbox2, s0, s1, s2, s3) {
    return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
  }
  function encrypt(xk, s0, s1, s2, s3) {
    const { sbox2, T01, T23 } = tableEncoding;
    let k = 0;
    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
    const rounds = xk.length / 4 - 2;
    for (let i2 = 0; i2 < rounds; i2++) {
      const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
      const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
      const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
      const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
      s0 = t02, s1 = t12, s2 = t22, s3 = t32;
    }
    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
    return { s0: t0, s1: t1, s2: t2, s3: t3 };
  }
  function decrypt(xk, s0, s1, s2, s3) {
    const { sbox2, T01, T23 } = tableDecoding;
    let k = 0;
    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
    const rounds = xk.length / 4 - 2;
    for (let i2 = 0; i2 < rounds; i2++) {
      const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
      const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
      const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
      const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
      s0 = t02, s1 = t12, s2 = t22, s3 = t32;
    }
    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
    return { s0: t0, s1: t1, s2: t2, s3: t3 };
  }
  function validateBlockDecrypt(data) {
    abytes3(data);
    if (data.length % BLOCK_SIZE !== 0) {
      throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size " + BLOCK_SIZE);
    }
  }
  function validateBlockEncrypt(plaintext, pcks5, dst) {
    abytes3(plaintext);
    let outLen = plaintext.length;
    const remaining = outLen % BLOCK_SIZE;
    if (!pcks5 && remaining !== 0)
      throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
    if (!isAligned32(plaintext))
      plaintext = copyBytes2(plaintext);
    const b = u322(plaintext);
    if (pcks5) {
      let left = BLOCK_SIZE - remaining;
      if (!left)
        left = BLOCK_SIZE;
      outLen = outLen + left;
    }
    dst = getOutput(outLen, dst);
    complexOverlapBytes(plaintext, dst);
    const o = u322(dst);
    return { b, o, out: dst };
  }
  function validatePCKS(data, pcks5) {
    if (!pcks5)
      return data;
    const len = data.length;
    if (!len)
      throw new Error("aes/pcks5: empty ciphertext not allowed");
    const lastByte = data[len - 1];
    if (lastByte <= 0 || lastByte > 16)
      throw new Error("aes/pcks5: wrong padding");
    const out = data.subarray(0, -lastByte);
    for (let i2 = 0; i2 < lastByte; i2++)
      if (data[len - i2 - 1] !== lastByte)
        throw new Error("aes/pcks5: wrong padding");
    return out;
  }
  function padPCKS(left) {
    const tmp = new Uint8Array(16);
    const tmp32 = u322(tmp);
    tmp.set(left);
    const paddingByte = BLOCK_SIZE - left.length;
    for (let i2 = BLOCK_SIZE - paddingByte; i2 < BLOCK_SIZE; i2++)
      tmp[i2] = paddingByte;
    return tmp32;
  }
  var cbc = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {
    const pcks5 = !opts.disablePadding;
    return {
      encrypt(plaintext, dst) {
        const xk = expandKeyLE(key);
        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
        let _iv = iv;
        const toClean = [xk];
        if (!isAligned32(_iv))
          toClean.push(_iv = copyBytes2(_iv));
        const n32 = u322(_iv);
        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
        let i2 = 0;
        for (; i2 + 4 <= b.length; ) {
          s0 ^= b[i2 + 0], s1 ^= b[i2 + 1], s2 ^= b[i2 + 2], s3 ^= b[i2 + 3];
          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
          o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
        }
        if (pcks5) {
          const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
          s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
          o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
        }
        clean2(...toClean);
        return _out;
      },
      decrypt(ciphertext, dst) {
        validateBlockDecrypt(ciphertext);
        const xk = expandKeyDecLE(key);
        let _iv = iv;
        const toClean = [xk];
        if (!isAligned32(_iv))
          toClean.push(_iv = copyBytes2(_iv));
        const n32 = u322(_iv);
        dst = getOutput(ciphertext.length, dst);
        if (!isAligned32(ciphertext))
          toClean.push(ciphertext = copyBytes2(ciphertext));
        complexOverlapBytes(ciphertext, dst);
        const b = u322(ciphertext);
        const o = u322(dst);
        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
        for (let i2 = 0; i2 + 4 <= b.length; ) {
          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
          s0 = b[i2 + 0], s1 = b[i2 + 1], s2 = b[i2 + 2], s3 = b[i2 + 3];
          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
          o[i2++] = o0 ^ ps0, o[i2++] = o1 ^ ps1, o[i2++] = o2 ^ ps2, o[i2++] = o3 ^ ps3;
        }
        clean2(...toClean);
        return validatePCKS(dst, pcks5);
      }
    };
  });
  function isBytes32(a) {
    return a instanceof Uint32Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint32Array";
  }
  function encryptBlock(xk, block) {
    abytes3(block, 16, "block");
    if (!isBytes32(xk))
      throw new Error("_encryptBlock accepts result of expandKeyLE");
    const b32 = u322(block);
    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);
    b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
    return block;
  }
  function dbl(block) {
    let carry = 0;
    for (let i2 = BLOCK_SIZE - 1; i2 >= 0; i2--) {
      const newCarry = (block[i2] & 128) >>> 7;
      block[i2] = block[i2] << 1 | carry;
      carry = newCarry;
    }
    if (carry) {
      block[BLOCK_SIZE - 1] ^= 135;
    }
    return block;
  }
  function xorBlock(a, b) {
    if (a.length !== b.length)
      throw new Error("xorBlock: blocks must have same length");
    for (let i2 = 0; i2 < a.length; i2++) {
      a[i2] = a[i2] ^ b[i2];
    }
    return a;
  }
  var _CMAC = class {
    buffer;
    destroyed;
    k1;
    k2;
    xk;
    constructor(key) {
      abytes3(key);
      validateKeyLength(key);
      this.xk = expandKeyLE(key);
      this.buffer = new Uint8Array(0);
      this.destroyed = false;
      const L = new Uint8Array(BLOCK_SIZE);
      encryptBlock(this.xk, L);
      this.k1 = dbl(L);
      this.k2 = dbl(new Uint8Array(this.k1));
    }
    update(data) {
      const { destroyed, buffer } = this;
      if (destroyed)
        throw new Error("CMAC instance was destroyed");
      abytes3(data);
      const newBuffer = new Uint8Array(buffer.length + data.length);
      newBuffer.set(buffer);
      newBuffer.set(data, buffer.length);
      this.buffer = newBuffer;
      return this;
    }
    // see https://www.rfc-editor.org/rfc/rfc4493.html#section-2.4
    digest() {
      if (this.destroyed)
        throw new Error("CMAC instance was destroyed");
      const { buffer } = this;
      const msgLen = buffer.length;
      let n = Math.ceil(msgLen / BLOCK_SIZE);
      let flag;
      if (n === 0) {
        n = 1;
        flag = false;
      } else {
        flag = msgLen % BLOCK_SIZE === 0;
      }
      const lastBlockStart = (n - 1) * BLOCK_SIZE;
      const lastBlockData = buffer.subarray(lastBlockStart);
      let m_last;
      if (flag) {
        m_last = xorBlock(new Uint8Array(lastBlockData), this.k1);
      } else {
        const padded = new Uint8Array(BLOCK_SIZE);
        padded.set(lastBlockData);
        padded[lastBlockData.length] = 128;
        m_last = xorBlock(padded, this.k2);
      }
      let x = new Uint8Array(BLOCK_SIZE);
      for (let i2 = 0; i2 < n - 1; i2++) {
        const m_i = buffer.subarray(i2 * BLOCK_SIZE, (i2 + 1) * BLOCK_SIZE);
        xorBlock(x, m_i);
        encryptBlock(this.xk, x);
      }
      xorBlock(x, m_last);
      encryptBlock(this.xk, x);
      clean2(m_last);
      return x;
    }
    destroy() {
      const { buffer, destroyed, xk, k1, k2 } = this;
      if (destroyed)
        return;
      this.destroyed = true;
      clean2(buffer, xk, k1, k2);
    }
  };
  var cmac = (key, message) => new _CMAC(key).update(message).digest();
  cmac.create = (key) => new _CMAC(key);

  // node_modules/@noble/ciphers/_arx.js
  var encodeStr = (str) => Uint8Array.from(str.split(""), (c) => c.charCodeAt(0));
  var sigma16 = encodeStr("expand 16-byte k");
  var sigma32 = encodeStr("expand 32-byte k");
  var sigma16_32 = u322(sigma16);
  var sigma32_32 = u322(sigma32);
  function rotl2(a, b) {
    return a << b | a >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = Uint32Array.of();
  function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u322(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u322(data) : U32_EMPTY;
    const o32 = isAligned ? u322(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take; j++) {
        posj = pos + j;
        output[posj] = data[posj] ^ block[j];
      }
      pos += take;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber3(counterLength);
    anumber3(rounds);
    abool2(counterRight);
    abool2(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
      abytes3(key, void 0, "key");
      abytes3(nonce, void 0, "nonce");
      abytes3(data, void 0, "data");
      const len = data.length;
      if (output === void 0)
        output = new Uint8Array(len);
      abytes3(output, void 0, "output");
      anumber3(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output.length < len)
        throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
      const toClean = [];
      let l = key.length;
      let k;
      let sigma;
      if (l === 32) {
        toClean.push(k = copyBytes2(key));
        sigma = sigma32_32;
      } else if (l === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        abytes3(key, 32, "arx key");
        throw new Error("invalid key size");
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes2(nonce));
      const k32 = u322(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u322(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u322(nonce);
      runCipher(core, sigma, k32, n32, data, output, counter, rounds);
      clean2(...toClean);
      return output;
    };
  }

  // node_modules/@noble/ciphers/_poly1305.js
  function u8to16(a, i2) {
    return a[i2++] & 255 | (a[i2++] & 255) << 8;
  }
  var Poly1305 = class {
    blockLen = 16;
    outputLen = 16;
    buffer = new Uint8Array(16);
    r = new Uint16Array(10);
    // Allocating 1 array with .subarray() here is slower than 3
    h = new Uint16Array(10);
    pad = new Uint16Array(8);
    pos = 0;
    finished = false;
    // Can be speed-up using BigUint64Array, at the cost of complexity
    constructor(key) {
      key = copyBytes2(abytes3(key, 32, "key"));
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i2 = 0; i2 < 8; i2++)
        this.pad[i2] = u8to16(key, 16 + 2 * i2);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h[0] + (t0 & 8191);
      let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h[5] + (t4 >>> 1 & 8191);
      let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h[0] = d0;
      h[1] = d1;
      h[2] = d2;
      h[3] = d3;
      h[4] = d4;
      h[5] = d5;
      h[6] = d6;
      h[7] = d7;
      h[8] = d8;
      h[9] = d9;
    }
    finalize() {
      const { h, pad: pad3 } = this;
      const g = new Uint16Array(10);
      let c = h[1] >>> 13;
      h[1] &= 8191;
      for (let i2 = 2; i2 < 10; i2++) {
        h[i2] += c;
        c = h[i2] >>> 13;
        h[i2] &= 8191;
      }
      h[0] += c * 5;
      c = h[0] >>> 13;
      h[0] &= 8191;
      h[1] += c;
      c = h[1] >>> 13;
      h[1] &= 8191;
      h[2] += c;
      g[0] = h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i2 = 1; i2 < 10; i2++) {
        g[i2] = h[i2] + c;
        c = g[i2] >>> 13;
        g[i2] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i2 = 0; i2 < 10; i2++)
        g[i2] &= mask;
      mask = ~mask;
      for (let i2 = 0; i2 < 10; i2++)
        h[i2] = h[i2] & mask | g[i2];
      h[0] = (h[0] | h[1] << 13) & 65535;
      h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
      h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
      h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
      h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
      h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
      h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
      h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
      let f = h[0] + pad3[0];
      h[0] = f & 65535;
      for (let i2 = 1; i2 < 8; i2++) {
        f = (h[i2] + pad3[i2] | 0) + (f >>> 16) | 0;
        h[i2] = f & 65535;
      }
      clean2(g);
    }
    update(data) {
      aexists2(this);
      abytes3(data);
      data = copyBytes2(data);
      const { buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean2(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer, h } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (; pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        out[opos++] = h[i2] >>> 0;
        out[opos++] = h[i2] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(msg).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();

  // node_modules/@noble/ciphers/chacha.js
  function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s, k, i2, out) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
    for (let r = 0; r < 20; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = x00;
    out[oi++] = x01;
    out[oi++] = x02;
    out[oi++] = x03;
    out[oi++] = x12;
    out[oi++] = x13;
    out[oi++] = x14;
    out[oi++] = x15;
  }
  var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
  });
  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });
  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h, msg) => {
    h.update(msg);
    const leftover = msg.length % 16;
    if (leftover)
      h.update(ZEROS16.subarray(leftover));
  };
  var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag(fn, key, nonce, ciphertext, AAD) {
    if (AAD !== void 0)
      abytes3(AAD, void 0, "AAD");
    const authKey = fn(key, nonce, ZEROS32);
    const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
    const h = poly1305.create(authKey);
    if (AAD)
      updatePadded(h, AAD);
    updatePadded(h, ciphertext);
    h.update(lengths);
    const res = h.digest();
    clean2(authKey, lengths);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output) {
        const plength = plaintext.length;
        output = getOutput(plength + tagLength, output, false);
        output.set(plaintext);
        const oPlain = output.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
        output.set(tag, plength);
        clean2(tag);
        return output;
      },
      decrypt(ciphertext, output) {
        output = getOutput(ciphertext.length - tagLength, output, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag(xorStream, key, nonce, data, AAD);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        output.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output, output, 1);
        clean2(tag);
        return output;
      }
    };
  };
  var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

  // node_modules/@noble/hashes/hkdf.js
  function extract(hash, ikm, salt) {
    ahash(hash);
    if (salt === void 0)
      salt = new Uint8Array(hash.outputLen);
    return hmac(hash, salt, ikm);
  }
  var HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
  var EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
  function expand(hash, prk, info, length = 32) {
    ahash(hash);
    anumber(length, "length");
    const olen = hash.outputLen;
    if (length > 255 * olen)
      throw new Error("Length must be <= 255*HashLen");
    const blocks = Math.ceil(length / olen);
    if (info === void 0)
      info = EMPTY_BUFFER;
    else
      abytes(info, void 0, "info");
    const okm = new Uint8Array(blocks * olen);
    const HMAC = hmac.create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, olen * counter);
      HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    clean(T, HKDF_COUNTER);
    return okm.slice(0, length);
  }

  // node_modules/nostr-tools/lib/esm/index.js
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var verifiedSymbol = /* @__PURE__ */ Symbol("verified");
  var isRecord = (obj) => obj instanceof Object;
  function validateEvent(event) {
    if (!isRecord(event))
      return false;
    if (typeof event.kind !== "number")
      return false;
    if (typeof event.content !== "string")
      return false;
    if (typeof event.created_at !== "number")
      return false;
    if (typeof event.pubkey !== "string")
      return false;
    if (!event.pubkey.match(/^[a-f0-9]{64}$/))
      return false;
    if (!Array.isArray(event.tags))
      return false;
    for (let i2 = 0; i2 < event.tags.length; i2++) {
      let tag = event.tags[i2];
      if (!Array.isArray(tag))
        return false;
      for (let j = 0; j < tag.length; j++) {
        if (typeof tag[j] !== "string")
          return false;
      }
    }
    return true;
  }
  var utils_exports = {};
  __export(utils_exports, {
    binarySearch: () => binarySearch,
    bytesToHex: () => bytesToHex,
    hexToBytes: () => hexToBytes,
    insertEventIntoAscendingList: () => insertEventIntoAscendingList,
    insertEventIntoDescendingList: () => insertEventIntoDescendingList,
    mergeReverseSortedLists: () => mergeReverseSortedLists,
    normalizeURL: () => normalizeURL,
    utf8Decoder: () => utf8Decoder,
    utf8Encoder: () => utf8Encoder
  });
  var utf8Decoder = new TextDecoder("utf-8");
  var utf8Encoder = new TextEncoder();
  function normalizeURL(url) {
    try {
      if (url.indexOf("://") === -1)
        url = "wss://" + url;
      let p = new URL(url);
      if (p.protocol === "http:")
        p.protocol = "ws:";
      else if (p.protocol === "https:")
        p.protocol = "wss:";
      p.pathname = p.pathname.replace(/\/+/g, "/");
      if (p.pathname.endsWith("/"))
        p.pathname = p.pathname.slice(0, -1);
      if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
        p.port = "";
      p.searchParams.sort();
      p.hash = "";
      return p.toString();
    } catch (e) {
      throw new Error(`Invalid URL: ${url}`);
    }
  }
  function insertEventIntoDescendingList(sortedArray, event) {
    const [idx, found] = binarySearch(sortedArray, (b) => {
      if (event.id === b.id)
        return 0;
      if (event.created_at === b.created_at)
        return -1;
      return b.created_at - event.created_at;
    });
    if (!found) {
      sortedArray.splice(idx, 0, event);
    }
    return sortedArray;
  }
  function insertEventIntoAscendingList(sortedArray, event) {
    const [idx, found] = binarySearch(sortedArray, (b) => {
      if (event.id === b.id)
        return 0;
      if (event.created_at === b.created_at)
        return -1;
      return event.created_at - b.created_at;
    });
    if (!found) {
      sortedArray.splice(idx, 0, event);
    }
    return sortedArray;
  }
  function binarySearch(arr, compare) {
    let start = 0;
    let end = arr.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const cmp = compare(arr[mid]);
      if (cmp === 0) {
        return [mid, true];
      }
      if (cmp < 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return [start, false];
  }
  function mergeReverseSortedLists(list1, list2) {
    const result = new Array(list1.length + list2.length);
    result.length = 0;
    let i1 = 0;
    let i2 = 0;
    let sameTimestampIds = [];
    while (i1 < list1.length && i2 < list2.length) {
      let next;
      if (list1[i1]?.created_at > list2[i2]?.created_at) {
        next = list1[i1];
        i1++;
      } else {
        next = list2[i2];
        i2++;
      }
      if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {
        if (sameTimestampIds.includes(next.id))
          continue;
      } else {
        sameTimestampIds.length = 0;
      }
      result.push(next);
      sameTimestampIds.push(next.id);
    }
    while (i1 < list1.length) {
      const next = list1[i1];
      i1++;
      if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {
        if (sameTimestampIds.includes(next.id))
          continue;
      } else {
        sameTimestampIds.length = 0;
      }
      result.push(next);
      sameTimestampIds.push(next.id);
    }
    while (i2 < list2.length) {
      const next = list2[i2];
      i2++;
      if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {
        if (sameTimestampIds.includes(next.id))
          continue;
      } else {
        sameTimestampIds.length = 0;
      }
      result.push(next);
      sameTimestampIds.push(next.id);
    }
    return result;
  }
  var JS = class {
    generateSecretKey() {
      return schnorr.utils.randomSecretKey();
    }
    getPublicKey(secretKey) {
      return bytesToHex(schnorr.getPublicKey(secretKey));
    }
    finalizeEvent(t, secretKey) {
      const event = t;
      event.pubkey = bytesToHex(schnorr.getPublicKey(secretKey));
      event.id = getEventHash(event);
      event.sig = bytesToHex(schnorr.sign(hexToBytes(getEventHash(event)), secretKey));
      event[verifiedSymbol] = true;
      return event;
    }
    verifyEvent(event) {
      if (typeof event[verifiedSymbol] === "boolean")
        return event[verifiedSymbol];
      const hash = getEventHash(event);
      if (hash !== event.id) {
        event[verifiedSymbol] = false;
        return false;
      }
      try {
        const valid = schnorr.verify(hexToBytes(event.sig), hexToBytes(hash), hexToBytes(event.pubkey));
        event[verifiedSymbol] = valid;
        return valid;
      } catch (err) {
        event[verifiedSymbol] = false;
        return false;
      }
    }
  };
  function serializeEvent(evt) {
    if (!validateEvent(evt))
      throw new Error("can't serialize event with wrong or missing properties");
    return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
  }
  function getEventHash(event) {
    let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)));
    return bytesToHex(eventHash);
  }
  var i = new JS();
  var generateSecretKey = i.generateSecretKey;
  var getPublicKey = i.getPublicKey;
  var finalizeEvent = i.finalizeEvent;
  var verifyEvent = i.verifyEvent;
  var kinds_exports = {};
  __export(kinds_exports, {
    Application: () => Application,
    BadgeAward: () => BadgeAward,
    BadgeDefinition: () => BadgeDefinition,
    BlockedRelaysList: () => BlockedRelaysList,
    BlossomServerList: () => BlossomServerList,
    BookmarkList: () => BookmarkList,
    Bookmarksets: () => Bookmarksets,
    Calendar: () => Calendar,
    CalendarEventRSVP: () => CalendarEventRSVP,
    ChannelCreation: () => ChannelCreation,
    ChannelHideMessage: () => ChannelHideMessage,
    ChannelMessage: () => ChannelMessage,
    ChannelMetadata: () => ChannelMetadata,
    ChannelMuteUser: () => ChannelMuteUser,
    ChatMessage: () => ChatMessage,
    ClassifiedListing: () => ClassifiedListing,
    ClientAuth: () => ClientAuth,
    Comment: () => Comment,
    CommunitiesList: () => CommunitiesList,
    CommunityDefinition: () => CommunityDefinition,
    CommunityPostApproval: () => CommunityPostApproval,
    Contacts: () => Contacts,
    CreateOrUpdateProduct: () => CreateOrUpdateProduct,
    CreateOrUpdateStall: () => CreateOrUpdateStall,
    Curationsets: () => Curationsets,
    Date: () => Date2,
    DirectMessageRelaysList: () => DirectMessageRelaysList,
    DraftClassifiedListing: () => DraftClassifiedListing,
    DraftLong: () => DraftLong,
    Emojisets: () => Emojisets,
    EncryptedDirectMessage: () => EncryptedDirectMessage,
    EventDeletion: () => EventDeletion,
    FavoriteRelays: () => FavoriteRelays,
    FileMessage: () => FileMessage,
    FileMetadata: () => FileMetadata,
    FileServerPreference: () => FileServerPreference,
    Followsets: () => Followsets,
    ForumThread: () => ForumThread,
    GenericRepost: () => GenericRepost,
    Genericlists: () => Genericlists,
    GiftWrap: () => GiftWrap,
    GroupMetadata: () => GroupMetadata,
    HTTPAuth: () => HTTPAuth,
    Handlerinformation: () => Handlerinformation,
    Handlerrecommendation: () => Handlerrecommendation,
    Highlights: () => Highlights,
    InterestsList: () => InterestsList,
    Interestsets: () => Interestsets,
    JobFeedback: () => JobFeedback,
    JobRequest: () => JobRequest,
    JobResult: () => JobResult,
    Label: () => Label,
    LightningPubRPC: () => LightningPubRPC,
    LiveChatMessage: () => LiveChatMessage,
    LiveEvent: () => LiveEvent,
    LongFormArticle: () => LongFormArticle,
    Metadata: () => Metadata,
    Mutelist: () => Mutelist,
    NWCWalletInfo: () => NWCWalletInfo,
    NWCWalletRequest: () => NWCWalletRequest,
    NWCWalletResponse: () => NWCWalletResponse,
    NormalVideo: () => NormalVideo,
    NostrConnect: () => NostrConnect,
    OpenTimestamps: () => OpenTimestamps,
    Photo: () => Photo,
    Pinlist: () => Pinlist,
    Poll: () => Poll,
    PollResponse: () => PollResponse,
    PrivateDirectMessage: () => PrivateDirectMessage,
    ProblemTracker: () => ProblemTracker,
    ProfileBadges: () => ProfileBadges,
    PublicChatsList: () => PublicChatsList,
    Reaction: () => Reaction,
    RecommendRelay: () => RecommendRelay,
    RelayList: () => RelayList,
    RelayReview: () => RelayReview,
    Relaysets: () => Relaysets,
    Report: () => Report,
    Reporting: () => Reporting,
    Repost: () => Repost,
    Seal: () => Seal,
    SearchRelaysList: () => SearchRelaysList,
    ShortTextNote: () => ShortTextNote,
    ShortVideo: () => ShortVideo,
    Time: () => Time,
    UserEmojiList: () => UserEmojiList,
    UserStatuses: () => UserStatuses,
    Voice: () => Voice,
    VoiceComment: () => VoiceComment,
    Zap: () => Zap,
    ZapGoal: () => ZapGoal,
    ZapRequest: () => ZapRequest,
    classifyKind: () => classifyKind,
    isAddressableKind: () => isAddressableKind,
    isEphemeralKind: () => isEphemeralKind,
    isKind: () => isKind,
    isRegularKind: () => isRegularKind,
    isReplaceableKind: () => isReplaceableKind
  });
  function isRegularKind(kind) {
    return kind < 1e4 && kind !== 0 && kind !== 3;
  }
  function isReplaceableKind(kind) {
    return kind === 0 || kind === 3 || 1e4 <= kind && kind < 2e4;
  }
  function isEphemeralKind(kind) {
    return 2e4 <= kind && kind < 3e4;
  }
  function isAddressableKind(kind) {
    return 3e4 <= kind && kind < 4e4;
  }
  function classifyKind(kind) {
    if (isRegularKind(kind))
      return "regular";
    if (isReplaceableKind(kind))
      return "replaceable";
    if (isEphemeralKind(kind))
      return "ephemeral";
    if (isAddressableKind(kind))
      return "parameterized";
    return "unknown";
  }
  function isKind(event, kind) {
    const kindAsArray = kind instanceof Array ? kind : [kind];
    return validateEvent(event) && kindAsArray.includes(event.kind) || false;
  }
  var Metadata = 0;
  var ShortTextNote = 1;
  var RecommendRelay = 2;
  var Contacts = 3;
  var EncryptedDirectMessage = 4;
  var EventDeletion = 5;
  var Repost = 6;
  var Reaction = 7;
  var BadgeAward = 8;
  var ChatMessage = 9;
  var ForumThread = 11;
  var Seal = 13;
  var PrivateDirectMessage = 14;
  var FileMessage = 15;
  var GenericRepost = 16;
  var Photo = 20;
  var NormalVideo = 21;
  var ShortVideo = 22;
  var ChannelCreation = 40;
  var ChannelMetadata = 41;
  var ChannelMessage = 42;
  var ChannelHideMessage = 43;
  var ChannelMuteUser = 44;
  var OpenTimestamps = 1040;
  var GiftWrap = 1059;
  var Poll = 1068;
  var FileMetadata = 1063;
  var Comment = 1111;
  var LiveChatMessage = 1311;
  var Voice = 1222;
  var VoiceComment = 1244;
  var ProblemTracker = 1971;
  var Report = 1984;
  var Reporting = 1984;
  var Label = 1985;
  var CommunityPostApproval = 4550;
  var JobRequest = 5999;
  var JobResult = 6999;
  var JobFeedback = 7e3;
  var ZapGoal = 9041;
  var ZapRequest = 9734;
  var Zap = 9735;
  var Highlights = 9802;
  var PollResponse = 1018;
  var Mutelist = 1e4;
  var Pinlist = 10001;
  var RelayList = 10002;
  var BookmarkList = 10003;
  var CommunitiesList = 10004;
  var PublicChatsList = 10005;
  var BlockedRelaysList = 10006;
  var SearchRelaysList = 10007;
  var FavoriteRelays = 10012;
  var InterestsList = 10015;
  var UserEmojiList = 10030;
  var DirectMessageRelaysList = 10050;
  var FileServerPreference = 10096;
  var BlossomServerList = 10063;
  var NWCWalletInfo = 13194;
  var LightningPubRPC = 21e3;
  var ClientAuth = 22242;
  var NWCWalletRequest = 23194;
  var NWCWalletResponse = 23195;
  var NostrConnect = 24133;
  var HTTPAuth = 27235;
  var Followsets = 3e4;
  var Genericlists = 30001;
  var Relaysets = 30002;
  var Bookmarksets = 30003;
  var Curationsets = 30004;
  var ProfileBadges = 30008;
  var BadgeDefinition = 30009;
  var Interestsets = 30015;
  var CreateOrUpdateStall = 30017;
  var CreateOrUpdateProduct = 30018;
  var LongFormArticle = 30023;
  var DraftLong = 30024;
  var Emojisets = 30030;
  var Application = 30078;
  var LiveEvent = 30311;
  var UserStatuses = 30315;
  var ClassifiedListing = 30402;
  var DraftClassifiedListing = 30403;
  var Date2 = 31922;
  var Time = 31923;
  var Calendar = 31924;
  var CalendarEventRSVP = 31925;
  var RelayReview = 31987;
  var Handlerrecommendation = 31989;
  var Handlerinformation = 31990;
  var CommunityDefinition = 34550;
  var GroupMetadata = 39e3;
  var fakejson_exports = {};
  __export(fakejson_exports, {
    getHex64: () => getHex64,
    getInt: () => getInt,
    getSubscriptionId: () => getSubscriptionId,
    matchEventId: () => matchEventId,
    matchEventKind: () => matchEventKind,
    matchEventPubkey: () => matchEventPubkey
  });
  function getHex64(json, field) {
    let len = field.length + 3;
    let idx = json.indexOf(`"${field}":`) + len;
    let s = json.slice(idx).indexOf(`"`) + idx + 1;
    return json.slice(s, s + 64);
  }
  function getInt(json, field) {
    let len = field.length;
    let idx = json.indexOf(`"${field}":`) + len + 3;
    let sliced = json.slice(idx);
    let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
    return parseInt(sliced.slice(0, end), 10);
  }
  function getSubscriptionId(json) {
    let idx = json.slice(0, 22).indexOf(`"EVENT"`);
    if (idx === -1)
      return null;
    let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
    if (pstart === -1)
      return null;
    let start = idx + 7 + 1 + pstart;
    let pend = json.slice(start + 1, 80).indexOf(`"`);
    if (pend === -1)
      return null;
    let end = start + 1 + pend;
    return json.slice(start + 1, end);
  }
  function matchEventId(json, id) {
    return id === getHex64(json, "id");
  }
  function matchEventPubkey(json, pubkey) {
    return pubkey === getHex64(json, "pubkey");
  }
  function matchEventKind(json, kind) {
    return kind === getInt(json, "kind");
  }
  var nip42_exports = {};
  __export(nip42_exports, {
    makeAuthEvent: () => makeAuthEvent
  });
  function makeAuthEvent(relayURL, challenge2) {
    return {
      kind: ClientAuth,
      created_at: Math.floor(Date.now() / 1e3),
      tags: [
        ["relay", relayURL],
        ["challenge", challenge2]
      ],
      content: ""
    };
  }
  var _WebSocket;
  try {
    _WebSocket = WebSocket;
  } catch {
  }
  var _WebSocket2;
  try {
    _WebSocket2 = WebSocket;
  } catch {
  }
  var nip19_exports = {};
  __export(nip19_exports, {
    BECH32_REGEX: () => BECH32_REGEX,
    Bech32MaxSize: () => Bech32MaxSize,
    NostrTypeGuard: () => NostrTypeGuard,
    decode: () => decode,
    decodeNostrURI: () => decodeNostrURI,
    encodeBytes: () => encodeBytes,
    naddrEncode: () => naddrEncode,
    neventEncode: () => neventEncode,
    noteEncode: () => noteEncode,
    nprofileEncode: () => nprofileEncode,
    npubEncode: () => npubEncode,
    nsecEncode: () => nsecEncode
  });
  var NostrTypeGuard = {
    isNProfile: (value) => /^nprofile1[a-z\d]+$/.test(value || ""),
    isNEvent: (value) => /^nevent1[a-z\d]+$/.test(value || ""),
    isNAddr: (value) => /^naddr1[a-z\d]+$/.test(value || ""),
    isNSec: (value) => /^nsec1[a-z\d]{58}$/.test(value || ""),
    isNPub: (value) => /^npub1[a-z\d]{58}$/.test(value || ""),
    isNote: (value) => /^note1[a-z\d]+$/.test(value || ""),
    isNcryptsec: (value) => /^ncryptsec1[a-z\d]+$/.test(value || "")
  };
  var Bech32MaxSize = 5e3;
  var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
  function integerToUint8Array(number) {
    const uint8Array = new Uint8Array(4);
    uint8Array[0] = number >> 24 & 255;
    uint8Array[1] = number >> 16 & 255;
    uint8Array[2] = number >> 8 & 255;
    uint8Array[3] = number & 255;
    return uint8Array;
  }
  function decodeNostrURI(nip19code) {
    try {
      if (nip19code.startsWith("nostr:"))
        nip19code = nip19code.substring(6);
      return decode(nip19code);
    } catch (_err) {
      return { type: "invalid", data: null };
    }
  }
  function decode(code) {
    let { prefix, words } = bech32.decode(code, Bech32MaxSize);
    let data = new Uint8Array(bech32.fromWords(words));
    switch (prefix) {
      case "nprofile": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for nprofile");
        if (tlv[0][0].length !== 32)
          throw new Error("TLV 0 should be 32 bytes");
        return {
          type: "nprofile",
          data: {
            pubkey: bytesToHex(tlv[0][0]),
            relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
          }
        };
      }
      case "nevent": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for nevent");
        if (tlv[0][0].length !== 32)
          throw new Error("TLV 0 should be 32 bytes");
        if (tlv[2] && tlv[2][0].length !== 32)
          throw new Error("TLV 2 should be 32 bytes");
        if (tlv[3] && tlv[3][0].length !== 4)
          throw new Error("TLV 3 should be 4 bytes");
        return {
          type: "nevent",
          data: {
            id: bytesToHex(tlv[0][0]),
            relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
            author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : void 0,
            kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : void 0
          }
        };
      }
      case "naddr": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for naddr");
        if (!tlv[2]?.[0])
          throw new Error("missing TLV 2 for naddr");
        if (tlv[2][0].length !== 32)
          throw new Error("TLV 2 should be 32 bytes");
        if (!tlv[3]?.[0])
          throw new Error("missing TLV 3 for naddr");
        if (tlv[3][0].length !== 4)
          throw new Error("TLV 3 should be 4 bytes");
        return {
          type: "naddr",
          data: {
            identifier: utf8Decoder.decode(tlv[0][0]),
            pubkey: bytesToHex(tlv[2][0]),
            kind: parseInt(bytesToHex(tlv[3][0]), 16),
            relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
          }
        };
      }
      case "nsec":
        return { type: prefix, data };
      case "npub":
      case "note":
        return { type: prefix, data: bytesToHex(data) };
      default:
        throw new Error(`unknown prefix ${prefix}`);
    }
  }
  function parseTLV(data) {
    let result = {};
    let rest = data;
    while (rest.length > 0) {
      let t = rest[0];
      let l = rest[1];
      let v = rest.slice(2, 2 + l);
      rest = rest.slice(2 + l);
      if (v.length < l)
        throw new Error(`not enough data to read on TLV ${t}`);
      result[t] = result[t] || [];
      result[t].push(v);
    }
    return result;
  }
  function nsecEncode(key) {
    return encodeBytes("nsec", key);
  }
  function npubEncode(hex) {
    return encodeBytes("npub", hexToBytes(hex));
  }
  function noteEncode(hex) {
    return encodeBytes("note", hexToBytes(hex));
  }
  function encodeBech32(prefix, data) {
    let words = bech32.toWords(data);
    return bech32.encode(prefix, words, Bech32MaxSize);
  }
  function encodeBytes(prefix, bytes) {
    return encodeBech32(prefix, bytes);
  }
  function nprofileEncode(profile) {
    let data = encodeTLV({
      0: [hexToBytes(profile.pubkey)],
      1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
    });
    return encodeBech32("nprofile", data);
  }
  function neventEncode(event) {
    let kindArray;
    if (event.kind !== void 0) {
      kindArray = integerToUint8Array(event.kind);
    }
    let data = encodeTLV({
      0: [hexToBytes(event.id)],
      1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
      2: event.author ? [hexToBytes(event.author)] : [],
      3: kindArray ? [new Uint8Array(kindArray)] : []
    });
    return encodeBech32("nevent", data);
  }
  function naddrEncode(addr) {
    let kind = new ArrayBuffer(4);
    new DataView(kind).setUint32(0, addr.kind, false);
    let data = encodeTLV({
      0: [utf8Encoder.encode(addr.identifier)],
      1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
      2: [hexToBytes(addr.pubkey)],
      3: [new Uint8Array(kind)]
    });
    return encodeBech32("naddr", data);
  }
  function encodeTLV(tlv) {
    let entries = [];
    Object.entries(tlv).reverse().forEach(([t, vs]) => {
      vs.forEach((v) => {
        let entry = new Uint8Array(v.length + 2);
        entry.set([parseInt(t)], 0);
        entry.set([v.length], 1);
        entry.set(v, 2);
        entries.push(entry);
      });
    });
    return concatBytes(...entries);
  }
  var nip04_exports = {};
  __export(nip04_exports, {
    decrypt: () => decrypt2,
    encrypt: () => encrypt2
  });
  function encrypt2(secretKey, pubkey, text) {
    const privkey = secretKey instanceof Uint8Array ? secretKey : hexToBytes(secretKey);
    const key = secp256k1.getSharedSecret(privkey, hexToBytes("02" + pubkey));
    const normalizedKey = getNormalizedX(key);
    let iv = Uint8Array.from(randomBytes(16));
    let plaintext = utf8Encoder.encode(text);
    let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
    let ctb64 = base64.encode(new Uint8Array(ciphertext));
    let ivb64 = base64.encode(new Uint8Array(iv.buffer));
    return `${ctb64}?iv=${ivb64}`;
  }
  function decrypt2(secretKey, pubkey, data) {
    const privkey = secretKey instanceof Uint8Array ? secretKey : hexToBytes(secretKey);
    let [ctb64, ivb64] = data.split("?iv=");
    let key = secp256k1.getSharedSecret(privkey, hexToBytes("02" + pubkey));
    let normalizedKey = getNormalizedX(key);
    let iv = base64.decode(ivb64);
    let ciphertext = base64.decode(ctb64);
    let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
    return utf8Decoder.decode(plaintext);
  }
  function getNormalizedX(key) {
    return key.slice(1, 33);
  }
  var nip05_exports = {};
  __export(nip05_exports, {
    NIP05_REGEX: () => NIP05_REGEX,
    isNip05: () => isNip05,
    isValid: () => isValid,
    queryProfile: () => queryProfile,
    searchDomain: () => searchDomain,
    useFetchImplementation: () => useFetchImplementation
  });
  var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
  var isNip05 = (value) => NIP05_REGEX.test(value || "");
  var _fetch;
  try {
    _fetch = fetch;
  } catch (_) {
    null;
  }
  function useFetchImplementation(fetchImplementation) {
    _fetch = fetchImplementation;
  }
  async function searchDomain(domain, query = "") {
    try {
      const url = `https://${domain}/.well-known/nostr.json?name=${query}`;
      const res = await _fetch(url, { redirect: "manual" });
      if (res.status !== 200) {
        throw Error("Wrong response code");
      }
      const json = await res.json();
      return json.names;
    } catch (_) {
      return {};
    }
  }
  async function queryProfile(fullname) {
    const match = fullname.match(NIP05_REGEX);
    if (!match)
      return null;
    const [, name = "_", domain] = match;
    try {
      const url = `https://${domain}/.well-known/nostr.json?name=${name}`;
      const res = await _fetch(url, { redirect: "manual" });
      if (res.status !== 200) {
        throw Error("Wrong response code");
      }
      const json = await res.json();
      const pubkey = json.names[name];
      return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;
    } catch (_e) {
      return null;
    }
  }
  async function isValid(pubkey, nip05) {
    const res = await queryProfile(nip05);
    return res ? res.pubkey === pubkey : false;
  }
  var nip10_exports = {};
  __export(nip10_exports, {
    parse: () => parse
  });
  function parse(event) {
    const result = {
      reply: void 0,
      root: void 0,
      mentions: [],
      profiles: [],
      quotes: []
    };
    let maybeParent;
    let maybeRoot;
    for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {
      const tag = event.tags[i2];
      if (tag[0] === "e" && tag[1]) {
        const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;
        const eventPointer = {
          id: eTagEventId,
          relays: eTagRelayUrl ? [eTagRelayUrl] : [],
          author: eTagAuthor
        };
        if (eTagMarker === "root") {
          result.root = eventPointer;
          continue;
        }
        if (eTagMarker === "reply") {
          result.reply = eventPointer;
          continue;
        }
        if (eTagMarker === "mention") {
          result.mentions.push(eventPointer);
          continue;
        }
        if (!maybeParent) {
          maybeParent = eventPointer;
        } else {
          maybeRoot = eventPointer;
        }
        result.mentions.push(eventPointer);
        continue;
      }
      if (tag[0] === "q" && tag[1]) {
        const [_, eTagEventId, eTagRelayUrl] = tag;
        result.quotes.push({
          id: eTagEventId,
          relays: eTagRelayUrl ? [eTagRelayUrl] : []
        });
      }
      if (tag[0] === "p" && tag[1]) {
        result.profiles.push({
          pubkey: tag[1],
          relays: tag[2] ? [tag[2]] : []
        });
        continue;
      }
    }
    if (!result.root) {
      result.root = maybeRoot || maybeParent || result.reply;
    }
    if (!result.reply) {
      result.reply = maybeParent || result.root;
    }
    ;
    [result.reply, result.root].forEach((ref) => {
      if (!ref)
        return;
      let idx = result.mentions.indexOf(ref);
      if (idx !== -1) {
        result.mentions.splice(idx, 1);
      }
      if (ref.author) {
        let author = result.profiles.find((p) => p.pubkey === ref.author);
        if (author && author.relays) {
          if (!ref.relays) {
            ref.relays = [];
          }
          author.relays.forEach((url) => {
            if (ref.relays?.indexOf(url) === -1)
              ref.relays.push(url);
          });
          author.relays = ref.relays;
        }
      }
    });
    result.mentions.forEach((ref) => {
      if (ref.author) {
        let author = result.profiles.find((p) => p.pubkey === ref.author);
        if (author && author.relays) {
          if (!ref.relays) {
            ref.relays = [];
          }
          author.relays.forEach((url) => {
            if (ref.relays.indexOf(url) === -1)
              ref.relays.push(url);
          });
          author.relays = ref.relays;
        }
      }
    });
    return result;
  }
  var nip11_exports = {};
  __export(nip11_exports, {
    fetchRelayInformation: () => fetchRelayInformation,
    useFetchImplementation: () => useFetchImplementation2
  });
  var _fetch2;
  try {
    _fetch2 = fetch;
  } catch {
  }
  function useFetchImplementation2(fetchImplementation) {
    _fetch2 = fetchImplementation;
  }
  async function fetchRelayInformation(url) {
    return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
      headers: { Accept: "application/nostr+json" }
    })).json();
  }
  var nip13_exports = {};
  __export(nip13_exports, {
    getPow: () => getPow,
    minePow: () => minePow
  });
  function getPow(hex) {
    let count = 0;
    for (let i2 = 0; i2 < 64; i2 += 8) {
      const nibble = parseInt(hex.substring(i2, i2 + 8), 16);
      if (nibble === 0) {
        count += 32;
      } else {
        count += Math.clz32(nibble);
        break;
      }
    }
    return count;
  }
  function getPowFromBytes(hash) {
    let count = 0;
    for (let i2 = 0; i2 < hash.length; i2++) {
      const byte = hash[i2];
      if (byte === 0) {
        count += 8;
      } else {
        count += Math.clz32(byte) - 24;
        break;
      }
    }
    return count;
  }
  function minePow(unsigned, difficulty) {
    let count = 0;
    const event = unsigned;
    const tag = ["nonce", count.toString(), difficulty.toString()];
    event.tags.push(tag);
    while (true) {
      const now2 = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      if (now2 !== event.created_at) {
        count = 0;
        event.created_at = now2;
      }
      tag[1] = (++count).toString();
      const hash = sha256(
        utf8Encoder.encode(JSON.stringify([0, event.pubkey, event.created_at, event.kind, event.tags, event.content]))
      );
      if (getPowFromBytes(hash) >= difficulty) {
        event.id = bytesToHex(hash);
        break;
      }
    }
    return event;
  }
  var nip17_exports = {};
  __export(nip17_exports, {
    unwrapEvent: () => unwrapEvent2,
    unwrapManyEvents: () => unwrapManyEvents2,
    wrapEvent: () => wrapEvent2,
    wrapManyEvents: () => wrapManyEvents2
  });
  var nip59_exports = {};
  __export(nip59_exports, {
    createRumor: () => createRumor,
    createSeal: () => createSeal,
    createWrap: () => createWrap,
    unwrapEvent: () => unwrapEvent,
    unwrapManyEvents: () => unwrapManyEvents,
    wrapEvent: () => wrapEvent,
    wrapManyEvents: () => wrapManyEvents
  });
  var nip44_exports = {};
  __export(nip44_exports, {
    decrypt: () => decrypt22,
    encrypt: () => encrypt22,
    getConversationKey: () => getConversationKey,
    v2: () => v2
  });
  var minPlaintextSize = 1;
  var maxPlaintextSize = 65535;
  function getConversationKey(privkeyA, pubkeyB) {
    const sharedX = secp256k1.getSharedSecret(privkeyA, hexToBytes("02" + pubkeyB)).subarray(1, 33);
    return extract(sha256, sharedX, utf8Encoder.encode("nip44-v2"));
  }
  function getMessageKeys(conversationKey, nonce) {
    const keys = expand(sha256, conversationKey, nonce, 76);
    return {
      chacha_key: keys.subarray(0, 32),
      chacha_nonce: keys.subarray(32, 44),
      hmac_key: keys.subarray(44, 76)
    };
  }
  function calcPaddedLen(len) {
    if (!Number.isSafeInteger(len) || len < 1)
      throw new Error("expected positive integer");
    if (len <= 32)
      return 32;
    const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
    const chunk = nextPower <= 256 ? 32 : nextPower / 8;
    return chunk * (Math.floor((len - 1) / chunk) + 1);
  }
  function writeU16BE(num2) {
    if (!Number.isSafeInteger(num2) || num2 < minPlaintextSize || num2 > maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const arr = new Uint8Array(2);
    new DataView(arr.buffer).setUint16(0, num2, false);
    return arr;
  }
  function pad(plaintext) {
    const unpadded = utf8Encoder.encode(plaintext);
    const unpaddedLen = unpadded.length;
    const prefix = writeU16BE(unpaddedLen);
    const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
    return concatBytes(prefix, unpadded, suffix);
  }
  function unpad(padded) {
    const unpaddedLen = new DataView(padded.buffer).getUint16(0);
    const unpadded = padded.subarray(2, 2 + unpaddedLen);
    if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))
      throw new Error("invalid padding");
    return utf8Decoder.decode(unpadded);
  }
  function hmacAad(key, message, aad) {
    if (aad.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const combined = concatBytes(aad, message);
    return hmac(sha256, key, combined);
  }
  function decodePayload(payload) {
    if (typeof payload !== "string")
      throw new Error("payload must be a valid string");
    const plen = payload.length;
    if (plen < 132 || plen > 87472)
      throw new Error("invalid payload length: " + plen);
    if (payload[0] === "#")
      throw new Error("unknown encryption version");
    let data;
    try {
      data = base64.decode(payload);
    } catch (error) {
      throw new Error("invalid base64: " + error.message);
    }
    const dlen = data.length;
    if (dlen < 99 || dlen > 65603)
      throw new Error("invalid data length: " + dlen);
    const vers = data[0];
    if (vers !== 2)
      throw new Error("unknown encryption version " + vers);
    return {
      nonce: data.subarray(1, 33),
      ciphertext: data.subarray(33, -32),
      mac: data.subarray(-32)
    };
  }
  function encrypt22(plaintext, conversationKey, nonce = randomBytes(32)) {
    const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
    const padded = pad(plaintext);
    const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
    const mac = hmacAad(hmac_key, ciphertext, nonce);
    return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac));
  }
  function decrypt22(payload, conversationKey) {
    const { nonce, ciphertext, mac } = decodePayload(payload);
    const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
    const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);
    if (!equalBytes(calculatedMac, mac))
      throw new Error("invalid MAC");
    const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
    return unpad(padded);
  }
  var v2 = {
    utils: {
      getConversationKey,
      calcPaddedLen
    },
    encrypt: encrypt22,
    decrypt: decrypt22
  };
  var TWO_DAYS = 2 * 24 * 60 * 60;
  var now = () => Math.round(Date.now() / 1e3);
  var randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);
  var nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);
  var nip44Encrypt = (data, privateKey, publicKey) => encrypt22(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));
  var nip44Decrypt = (data, privateKey) => JSON.parse(decrypt22(data.content, nip44ConversationKey(privateKey, data.pubkey)));
  function createRumor(event, privateKey) {
    const rumor = {
      created_at: now(),
      content: "",
      tags: [],
      ...event,
      pubkey: getPublicKey(privateKey)
    };
    rumor.id = getEventHash(rumor);
    return rumor;
  }
  function createSeal(rumor, privateKey, recipientPublicKey) {
    return finalizeEvent(
      {
        kind: Seal,
        content: nip44Encrypt(rumor, privateKey, recipientPublicKey),
        created_at: randomNow(),
        tags: []
      },
      privateKey
    );
  }
  function createWrap(seal, recipientPublicKey) {
    const randomKey = generateSecretKey();
    return finalizeEvent(
      {
        kind: GiftWrap,
        content: nip44Encrypt(seal, randomKey, recipientPublicKey),
        created_at: randomNow(),
        tags: [["p", recipientPublicKey]]
      },
      randomKey
    );
  }
  function wrapEvent(event, senderPrivateKey, recipientPublicKey) {
    const rumor = createRumor(event, senderPrivateKey);
    const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);
    return createWrap(seal, recipientPublicKey);
  }
  function wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {
    if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {
      throw new Error("At least one recipient is required.");
    }
    const senderPublicKey = getPublicKey(senderPrivateKey);
    const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];
    recipientsPublicKeys.forEach((recipientPublicKey) => {
      wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));
    });
    return wrappeds;
  }
  function unwrapEvent(wrap2, recipientPrivateKey) {
    const unwrappedSeal = nip44Decrypt(wrap2, recipientPrivateKey);
    return nip44Decrypt(unwrappedSeal, recipientPrivateKey);
  }
  function unwrapManyEvents(wrappedEvents, recipientPrivateKey) {
    let unwrappedEvents = [];
    wrappedEvents.forEach((e) => {
      unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));
    });
    unwrappedEvents.sort((a, b) => a.created_at - b.created_at);
    return unwrappedEvents;
  }
  function createEvent(recipients, message, conversationTitle, replyTo) {
    const baseEvent = {
      created_at: Math.ceil(Date.now() / 1e3),
      kind: PrivateDirectMessage,
      tags: [],
      content: message
    };
    const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];
    recipientsArray.forEach(({ publicKey, relayUrl }) => {
      baseEvent.tags.push(relayUrl ? ["p", publicKey, relayUrl] : ["p", publicKey]);
    });
    if (replyTo) {
      baseEvent.tags.push(["e", replyTo.eventId, replyTo.relayUrl || "", "reply"]);
    }
    if (conversationTitle) {
      baseEvent.tags.push(["subject", conversationTitle]);
    }
    return baseEvent;
  }
  function wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {
    const event = createEvent(recipient, message, conversationTitle, replyTo);
    return wrapEvent(event, senderPrivateKey, recipient.publicKey);
  }
  function wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {
    if (!recipients || recipients.length === 0) {
      throw new Error("At least one recipient is required.");
    }
    const senderPublicKey = getPublicKey(senderPrivateKey);
    return [{ publicKey: senderPublicKey }, ...recipients].map(
      (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)
    );
  }
  var unwrapEvent2 = unwrapEvent;
  var unwrapManyEvents2 = unwrapManyEvents;
  var nip18_exports = {};
  __export(nip18_exports, {
    finishRepostEvent: () => finishRepostEvent,
    getRepostedEvent: () => getRepostedEvent,
    getRepostedEventPointer: () => getRepostedEventPointer
  });
  function finishRepostEvent(t, reposted, relayUrl, privateKey) {
    let kind;
    const tags = [...t.tags ?? [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]];
    if (reposted.kind === ShortTextNote) {
      kind = Repost;
    } else {
      kind = GenericRepost;
      tags.push(["k", String(reposted.kind)]);
    }
    return finalizeEvent(
      {
        kind,
        tags,
        content: t.content === "" || reposted.tags?.find((tag) => tag[0] === "-") ? "" : JSON.stringify(reposted),
        created_at: t.created_at
      },
      privateKey
    );
  }
  function getRepostedEventPointer(event) {
    if (![Repost, GenericRepost].includes(event.kind)) {
      return void 0;
    }
    let lastETag;
    let lastPTag;
    for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
      const tag = event.tags[i2];
      if (tag.length >= 2) {
        if (tag[0] === "e" && lastETag === void 0) {
          lastETag = tag;
        } else if (tag[0] === "p" && lastPTag === void 0) {
          lastPTag = tag;
        }
      }
    }
    if (lastETag === void 0) {
      return void 0;
    }
    return {
      id: lastETag[1],
      relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === "string"),
      author: lastPTag?.[1]
    };
  }
  function getRepostedEvent(event, { skipVerification } = {}) {
    const pointer = getRepostedEventPointer(event);
    if (pointer === void 0 || event.content === "") {
      return void 0;
    }
    let repostedEvent;
    try {
      repostedEvent = JSON.parse(event.content);
    } catch (error) {
      return void 0;
    }
    if (repostedEvent.id !== pointer.id) {
      return void 0;
    }
    if (!skipVerification && !verifyEvent(repostedEvent)) {
      return void 0;
    }
    return repostedEvent;
  }
  var nip21_exports = {};
  __export(nip21_exports, {
    NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
    parse: () => parse2,
    test: () => test
  });
  var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
  function test(value) {
    return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
  }
  function parse2(uri) {
    const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
    if (!match)
      throw new Error(`Invalid Nostr URI: ${uri}`);
    return {
      uri: match[0],
      value: match[1],
      decoded: decode(match[1])
    };
  }
  var nip25_exports = {};
  __export(nip25_exports, {
    finishReactionEvent: () => finishReactionEvent,
    getReactedEventPointer: () => getReactedEventPointer
  });
  function finishReactionEvent(t, reacted, privateKey) {
    const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
    return finalizeEvent(
      {
        ...t,
        kind: Reaction,
        tags: [...t.tags ?? [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
        content: t.content ?? "+"
      },
      privateKey
    );
  }
  function getReactedEventPointer(event) {
    if (event.kind !== Reaction) {
      return void 0;
    }
    let lastETag;
    let lastPTag;
    for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
      const tag = event.tags[i2];
      if (tag.length >= 2) {
        if (tag[0] === "e" && lastETag === void 0) {
          lastETag = tag;
        } else if (tag[0] === "p" && lastPTag === void 0) {
          lastPTag = tag;
        }
      }
    }
    if (lastETag === void 0 || lastPTag === void 0) {
      return void 0;
    }
    return {
      id: lastETag[1],
      relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),
      author: lastPTag[1]
    };
  }
  var nip27_exports = {};
  __export(nip27_exports, {
    parse: () => parse3
  });
  var noCharacter = /\W/m;
  var noURLCharacter = /[^\w\/] |[^\w\/]$|$|,| /m;
  var MAX_HASHTAG_LENGTH = 42;
  function* parse3(content) {
    let emojis = [];
    if (typeof content !== "string") {
      for (let i2 = 0; i2 < content.tags.length; i2++) {
        const tag = content.tags[i2];
        if (tag[0] === "emoji" && tag.length >= 3) {
          emojis.push({ type: "emoji", shortcode: tag[1], url: tag[2] });
        }
      }
      content = content.content;
    }
    const max = content.length;
    let prevIndex = 0;
    let index = 0;
    mainloop:
      while (index < max) {
        const u = content.indexOf(":", index);
        const h = content.indexOf("#", index);
        if (u === -1 && h === -1) {
          break mainloop;
        }
        if (u === -1 || h >= 0 && h < u) {
          if (h === 0 || content[h - 1].match(noCharacter)) {
            const m = content.slice(h + 1, h + MAX_HASHTAG_LENGTH).match(noCharacter);
            const end = m ? h + 1 + m.index : max;
            yield { type: "text", text: content.slice(prevIndex, h) };
            yield { type: "hashtag", value: content.slice(h + 1, end) };
            index = end;
            prevIndex = index;
            continue mainloop;
          }
          index = h + 1;
          continue mainloop;
        }
        if (content.slice(u - 5, u) === "nostr") {
          const m = content.slice(u + 60).match(noCharacter);
          const end = m ? u + 60 + m.index : max;
          try {
            let pointer;
            let { data, type } = decode(content.slice(u + 1, end));
            switch (type) {
              case "npub":
                pointer = { pubkey: data };
                break;
              case "note":
                pointer = { id: data };
                break;
              case "nsec":
                index = end + 1;
                continue;
              default:
                pointer = data;
            }
            if (prevIndex !== u - 5) {
              yield { type: "text", text: content.slice(prevIndex, u - 5) };
            }
            yield { type: "reference", pointer };
            index = end;
            prevIndex = index;
            continue mainloop;
          } catch (_err) {
            index = u + 1;
            continue mainloop;
          }
        } else if (content.slice(u - 5, u) === "https" || content.slice(u - 4, u) === "http") {
          const m = content.slice(u + 4).match(noURLCharacter);
          const end = m ? u + 4 + m.index : max;
          const prefixLen = content[u - 1] === "s" ? 5 : 4;
          try {
            let url = new URL(content.slice(u - prefixLen, end));
            if (url.hostname.indexOf(".") === -1) {
              throw new Error("invalid url");
            }
            if (prevIndex !== u - prefixLen) {
              yield { type: "text", text: content.slice(prevIndex, u - prefixLen) };
            }
            if (/\.(png|jpe?g|gif|webp|heic|svg)$/i.test(url.pathname)) {
              yield { type: "image", url: url.toString() };
              index = end;
              prevIndex = index;
              continue mainloop;
            }
            if (/\.(mp4|avi|webm|mkv|mov)$/i.test(url.pathname)) {
              yield { type: "video", url: url.toString() };
              index = end;
              prevIndex = index;
              continue mainloop;
            }
            if (/\.(mp3|aac|ogg|opus|wav|flac)$/i.test(url.pathname)) {
              yield { type: "audio", url: url.toString() };
              index = end;
              prevIndex = index;
              continue mainloop;
            }
            yield { type: "url", url: url.toString() };
            index = end;
            prevIndex = index;
            continue mainloop;
          } catch (_err) {
            index = end + 1;
            continue mainloop;
          }
        } else if (content.slice(u - 3, u) === "wss" || content.slice(u - 2, u) === "ws") {
          const m = content.slice(u + 4).match(noURLCharacter);
          const end = m ? u + 4 + m.index : max;
          const prefixLen = content[u - 1] === "s" ? 3 : 2;
          try {
            let url = new URL(content.slice(u - prefixLen, end));
            if (url.hostname.indexOf(".") === -1) {
              throw new Error("invalid ws url");
            }
            if (prevIndex !== u - prefixLen) {
              yield { type: "text", text: content.slice(prevIndex, u - prefixLen) };
            }
            yield { type: "relay", url: url.toString() };
            index = end;
            prevIndex = index;
            continue mainloop;
          } catch (_err) {
            index = end + 1;
            continue mainloop;
          }
        } else {
          for (let e = 0; e < emojis.length; e++) {
            const emoji = emojis[e];
            if (content[u + emoji.shortcode.length + 1] === ":" && content.slice(u + 1, u + emoji.shortcode.length + 1) === emoji.shortcode) {
              if (prevIndex !== u) {
                yield { type: "text", text: content.slice(prevIndex, u) };
              }
              yield emoji;
              index = u + emoji.shortcode.length + 2;
              prevIndex = index;
              continue mainloop;
            }
          }
          index = u + 1;
          continue mainloop;
        }
      }
    if (prevIndex !== max) {
      yield { type: "text", text: content.slice(prevIndex) };
    }
  }
  var nip28_exports = {};
  __export(nip28_exports, {
    channelCreateEvent: () => channelCreateEvent,
    channelHideMessageEvent: () => channelHideMessageEvent,
    channelMessageEvent: () => channelMessageEvent,
    channelMetadataEvent: () => channelMetadataEvent,
    channelMuteUserEvent: () => channelMuteUserEvent
  });
  var channelCreateEvent = (t, privateKey) => {
    let content;
    if (typeof t.content === "object") {
      content = JSON.stringify(t.content);
    } else if (typeof t.content === "string") {
      content = t.content;
    } else {
      return void 0;
    }
    return finalizeEvent(
      {
        kind: ChannelCreation,
        tags: [...t.tags ?? []],
        content,
        created_at: t.created_at
      },
      privateKey
    );
  };
  var channelMetadataEvent = (t, privateKey) => {
    let content;
    if (typeof t.content === "object") {
      content = JSON.stringify(t.content);
    } else if (typeof t.content === "string") {
      content = t.content;
    } else {
      return void 0;
    }
    return finalizeEvent(
      {
        kind: ChannelMetadata,
        tags: [["e", t.channel_create_event_id], ...t.tags ?? []],
        content,
        created_at: t.created_at
      },
      privateKey
    );
  };
  var channelMessageEvent = (t, privateKey) => {
    const tags = [["e", t.channel_create_event_id, t.relay_url, "root"]];
    if (t.reply_to_channel_message_event_id) {
      tags.push(["e", t.reply_to_channel_message_event_id, t.relay_url, "reply"]);
    }
    return finalizeEvent(
      {
        kind: ChannelMessage,
        tags: [...tags, ...t.tags ?? []],
        content: t.content,
        created_at: t.created_at
      },
      privateKey
    );
  };
  var channelHideMessageEvent = (t, privateKey) => {
    let content;
    if (typeof t.content === "object") {
      content = JSON.stringify(t.content);
    } else if (typeof t.content === "string") {
      content = t.content;
    } else {
      return void 0;
    }
    return finalizeEvent(
      {
        kind: ChannelHideMessage,
        tags: [["e", t.channel_message_event_id], ...t.tags ?? []],
        content,
        created_at: t.created_at
      },
      privateKey
    );
  };
  var channelMuteUserEvent = (t, privateKey) => {
    let content;
    if (typeof t.content === "object") {
      content = JSON.stringify(t.content);
    } else if (typeof t.content === "string") {
      content = t.content;
    } else {
      return void 0;
    }
    return finalizeEvent(
      {
        kind: ChannelMuteUser,
        tags: [["p", t.pubkey_to_mute], ...t.tags ?? []],
        content,
        created_at: t.created_at
      },
      privateKey
    );
  };
  var nip30_exports = {};
  __export(nip30_exports, {
    EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
    matchAll: () => matchAll,
    regex: () => regex,
    replaceAll: () => replaceAll
  });
  var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
  var regex = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
  function* matchAll(content) {
    const matches = content.matchAll(regex());
    for (const match of matches) {
      try {
        const [shortcode, name] = match;
        yield {
          shortcode,
          name,
          start: match.index,
          end: match.index + shortcode.length
        };
      } catch (_e) {
      }
    }
  }
  function replaceAll(content, replacer) {
    return content.replaceAll(regex(), (shortcode, name) => {
      return replacer({
        shortcode,
        name
      });
    });
  }
  var nip39_exports = {};
  __export(nip39_exports, {
    useFetchImplementation: () => useFetchImplementation3,
    validateGithub: () => validateGithub
  });
  var _fetch3;
  try {
    _fetch3 = fetch;
  } catch {
  }
  function useFetchImplementation3(fetchImplementation) {
    _fetch3 = fetchImplementation;
  }
  async function validateGithub(pubkey, username, proof) {
    try {
      let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
      return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
    } catch (_) {
      return false;
    }
  }
  var nip47_exports = {};
  __export(nip47_exports, {
    makeNwcRequestEvent: () => makeNwcRequestEvent,
    parseConnectionString: () => parseConnectionString
  });
  function parseConnectionString(connectionString) {
    const { host, pathname, searchParams } = new URL(connectionString);
    const pubkey = pathname || host;
    const relay = searchParams.get("relay");
    const secret = searchParams.get("secret");
    if (!pubkey || !relay || !secret) {
      throw new Error("invalid connection string");
    }
    return { pubkey, relay, secret };
  }
  async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
    const content = {
      method: "pay_invoice",
      params: {
        invoice
      }
    };
    const encryptedContent = encrypt2(secretKey, pubkey, JSON.stringify(content));
    const eventTemplate = {
      kind: NWCWalletRequest,
      created_at: Math.round(Date.now() / 1e3),
      content: encryptedContent,
      tags: [["p", pubkey]]
    };
    return finalizeEvent(eventTemplate, secretKey);
  }
  var nip54_exports = {};
  __export(nip54_exports, {
    normalizeIdentifier: () => normalizeIdentifier
  });
  function normalizeIdentifier(name) {
    name = name.trim().toLowerCase();
    name = name.normalize("NFKC");
    return Array.from(name).map((char) => {
      if (/\p{Letter}/u.test(char) || /\p{Number}/u.test(char)) {
        return char;
      }
      return "-";
    }).join("");
  }
  var nip57_exports = {};
  __export(nip57_exports, {
    getSatoshisAmountFromBolt11: () => getSatoshisAmountFromBolt11,
    getZapEndpoint: () => getZapEndpoint,
    makeZapReceipt: () => makeZapReceipt,
    makeZapRequest: () => makeZapRequest,
    useFetchImplementation: () => useFetchImplementation4,
    validateZapRequest: () => validateZapRequest
  });
  var _fetch4;
  try {
    _fetch4 = fetch;
  } catch {
  }
  function useFetchImplementation4(fetchImplementation) {
    _fetch4 = fetchImplementation;
  }
  async function getZapEndpoint(metadata) {
    try {
      let lnurl = "";
      let { lud06, lud16 } = JSON.parse(metadata.content);
      if (lud16) {
        let [name, domain] = lud16.split("@");
        lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();
      } else if (lud06) {
        let { words } = bech32.decode(lud06, 1e3);
        let data = bech32.fromWords(words);
        lnurl = utf8Decoder.decode(data);
      } else {
        return null;
      }
      let res = await _fetch4(lnurl);
      let body = await res.json();
      if (body.allowsNostr && body.nostrPubkey) {
        return body.callback;
      }
    } catch (err) {
    }
    return null;
  }
  function makeZapRequest(params) {
    let zr = {
      kind: 9734,
      created_at: Math.round(Date.now() / 1e3),
      content: params.comment || "",
      tags: [
        ["p", "pubkey" in params ? params.pubkey : params.event.pubkey],
        ["amount", params.amount.toString()],
        ["relays", ...params.relays]
      ]
    };
    if ("event" in params) {
      zr.tags.push(["e", params.event.id]);
      if (isReplaceableKind(params.event.kind)) {
        const a = ["a", `${params.event.kind}:${params.event.pubkey}:`];
        zr.tags.push(a);
      } else if (isAddressableKind(params.event.kind)) {
        let d = params.event.tags.find(([t, v]) => t === "d" && v);
        if (!d)
          throw new Error("d tag not found or is empty");
        const a = ["a", `${params.event.kind}:${params.event.pubkey}:${d[1]}`];
        zr.tags.push(a);
      }
      zr.tags.push(["k", params.event.kind.toString()]);
    }
    return zr;
  }
  function validateZapRequest(zapRequestString) {
    let zapRequest;
    try {
      zapRequest = JSON.parse(zapRequestString);
    } catch (err) {
      return "Invalid zap request JSON.";
    }
    if (!validateEvent(zapRequest))
      return "Zap request is not a valid Nostr event.";
    if (!verifyEvent(zapRequest))
      return "Invalid signature on zap request.";
    let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
    if (!p)
      return "Zap request doesn't have a 'p' tag.";
    if (!p[1].match(/^[a-f0-9]{64}$/))
      return "Zap request 'p' tag is not valid hex.";
    let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
    if (e && !e[1].match(/^[a-f0-9]{64}$/))
      return "Zap request 'e' tag is not valid hex.";
    let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
    if (!relays)
      return "Zap request doesn't have a 'relays' tag.";
    return null;
  }
  function makeZapReceipt({
    zapRequest,
    preimage,
    bolt11,
    paidAt
  }) {
    let zr = JSON.parse(zapRequest);
    let tagsFromZapRequest = zr.tags.filter(([t]) => t === "e" || t === "p" || t === "a");
    let zap = {
      kind: 9735,
      created_at: Math.round(paidAt.getTime() / 1e3),
      content: "",
      tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
    };
    if (preimage) {
      zap.tags.push(["preimage", preimage]);
    }
    return zap;
  }
  function getSatoshisAmountFromBolt11(bolt11) {
    if (bolt11.length < 50) {
      return 0;
    }
    bolt11 = bolt11.substring(0, 50);
    const idx = bolt11.lastIndexOf("1");
    if (idx === -1) {
      return 0;
    }
    const hrp = bolt11.substring(0, idx);
    if (!hrp.startsWith("lnbc")) {
      return 0;
    }
    const amount = hrp.substring(4);
    if (amount.length < 1) {
      return 0;
    }
    const char = amount[amount.length - 1];
    const digit = char.charCodeAt(0) - "0".charCodeAt(0);
    const isDigit = digit >= 0 && digit <= 9;
    let cutPoint = amount.length - 1;
    if (isDigit) {
      cutPoint++;
    }
    if (cutPoint < 1) {
      return 0;
    }
    const num2 = parseInt(amount.substring(0, cutPoint));
    switch (char) {
      case "m":
        return num2 * 1e5;
      case "u":
        return num2 * 100;
      case "n":
        return num2 / 10;
      case "p":
        return num2 / 1e4;
      default:
        return num2 * 1e8;
    }
  }
  var nip77_exports = {};
  __export(nip77_exports, {
    Negentropy: () => Negentropy,
    NegentropyStorageVector: () => NegentropyStorageVector,
    NegentropySync: () => NegentropySync
  });
  var PROTOCOL_VERSION = 97;
  var ID_SIZE = 32;
  var FINGERPRINT_SIZE = 16;
  var Mode = {
    Skip: 0,
    Fingerprint: 1,
    IdList: 2
  };
  var WrappedBuffer = class {
    _raw;
    length;
    constructor(buffer) {
      if (typeof buffer === "number") {
        this._raw = new Uint8Array(buffer);
        this.length = 0;
      } else if (buffer instanceof Uint8Array) {
        this._raw = new Uint8Array(buffer);
        this.length = buffer.length;
      } else {
        this._raw = new Uint8Array(512);
        this.length = 0;
      }
    }
    unwrap() {
      return this._raw.subarray(0, this.length);
    }
    get capacity() {
      return this._raw.byteLength;
    }
    extend(buf) {
      if (buf instanceof WrappedBuffer)
        buf = buf.unwrap();
      if (typeof buf.length !== "number")
        throw Error("bad length");
      const targetSize = buf.length + this.length;
      if (this.capacity < targetSize) {
        const oldRaw = this._raw;
        const newCapacity = Math.max(this.capacity * 2, targetSize);
        this._raw = new Uint8Array(newCapacity);
        this._raw.set(oldRaw);
      }
      this._raw.set(buf, this.length);
      this.length += buf.length;
    }
    shift() {
      const first = this._raw[0];
      this._raw = this._raw.subarray(1);
      this.length--;
      return first;
    }
    shiftN(n = 1) {
      const firstSubarray = this._raw.subarray(0, n);
      this._raw = this._raw.subarray(n);
      this.length -= n;
      return firstSubarray;
    }
  };
  function decodeVarInt(buf) {
    let res = 0;
    while (1) {
      if (buf.length === 0)
        throw Error("parse ends prematurely");
      let byte = buf.shift();
      res = res << 7 | byte & 127;
      if ((byte & 128) === 0)
        break;
    }
    return res;
  }
  function encodeVarInt(n) {
    if (n === 0)
      return new WrappedBuffer(new Uint8Array([0]));
    let o = [];
    while (n !== 0) {
      o.push(n & 127);
      n >>>= 7;
    }
    o.reverse();
    for (let i2 = 0; i2 < o.length - 1; i2++)
      o[i2] |= 128;
    return new WrappedBuffer(new Uint8Array(o));
  }
  function getByte(buf) {
    return getBytes(buf, 1)[0];
  }
  function getBytes(buf, n) {
    if (buf.length < n)
      throw Error("parse ends prematurely");
    return buf.shiftN(n);
  }
  var Accumulator = class {
    buf;
    constructor() {
      this.setToZero();
    }
    setToZero() {
      this.buf = new Uint8Array(ID_SIZE);
    }
    add(otherBuf) {
      let currCarry = 0, nextCarry = 0;
      let p = new DataView(this.buf.buffer);
      let po = new DataView(otherBuf.buffer);
      for (let i2 = 0; i2 < 8; i2++) {
        let offset = i2 * 4;
        let orig = p.getUint32(offset, true);
        let otherV = po.getUint32(offset, true);
        let next = orig;
        next += currCarry;
        next += otherV;
        if (next > 4294967295)
          nextCarry = 1;
        p.setUint32(offset, next & 4294967295, true);
        currCarry = nextCarry;
        nextCarry = 0;
      }
    }
    negate() {
      let p = new DataView(this.buf.buffer);
      for (let i2 = 0; i2 < 8; i2++) {
        let offset = i2 * 4;
        p.setUint32(offset, ~p.getUint32(offset, true));
      }
      let one = new Uint8Array(ID_SIZE);
      one[0] = 1;
      this.add(one);
    }
    getFingerprint(n) {
      let input = new WrappedBuffer();
      input.extend(this.buf);
      input.extend(encodeVarInt(n));
      let hash = sha256(input.unwrap());
      return hash.subarray(0, FINGERPRINT_SIZE);
    }
  };
  var NegentropyStorageVector = class {
    items;
    sealed;
    constructor() {
      this.items = [];
      this.sealed = false;
    }
    insert(timestamp, id) {
      if (this.sealed)
        throw Error("already sealed");
      const idb = hexToBytes(id);
      if (idb.byteLength !== ID_SIZE)
        throw Error("bad id size for added item");
      this.items.push({ timestamp, id: idb });
    }
    seal() {
      if (this.sealed)
        throw Error("already sealed");
      this.sealed = true;
      this.items.sort(itemCompare);
      for (let i2 = 1; i2 < this.items.length; i2++) {
        if (itemCompare(this.items[i2 - 1], this.items[i2]) === 0)
          throw Error("duplicate item inserted");
      }
    }
    unseal() {
      this.sealed = false;
    }
    size() {
      this._checkSealed();
      return this.items.length;
    }
    getItem(i2) {
      this._checkSealed();
      if (i2 >= this.items.length)
        throw Error("out of range");
      return this.items[i2];
    }
    iterate(begin, end, cb) {
      this._checkSealed();
      this._checkBounds(begin, end);
      for (let i2 = begin; i2 < end; ++i2) {
        if (!cb(this.items[i2], i2))
          break;
      }
    }
    findLowerBound(begin, end, bound) {
      this._checkSealed();
      this._checkBounds(begin, end);
      return this._binarySearch(this.items, begin, end, (a) => itemCompare(a, bound) < 0);
    }
    fingerprint(begin, end) {
      let out = new Accumulator();
      out.setToZero();
      this.iterate(begin, end, (item) => {
        out.add(item.id);
        return true;
      });
      return out.getFingerprint(end - begin);
    }
    _checkSealed() {
      if (!this.sealed)
        throw Error("not sealed");
    }
    _checkBounds(begin, end) {
      if (begin > end || end > this.items.length)
        throw Error("bad range");
    }
    _binarySearch(arr, first, last, cmp) {
      let count = last - first;
      while (count > 0) {
        let it = first;
        let step = Math.floor(count / 2);
        it += step;
        if (cmp(arr[it])) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
  };
  var Negentropy = class {
    storage;
    frameSizeLimit;
    lastTimestampIn;
    lastTimestampOut;
    constructor(storage4, frameSizeLimit = 6e4) {
      if (frameSizeLimit < 4096)
        throw Error("frameSizeLimit too small");
      this.storage = storage4;
      this.frameSizeLimit = frameSizeLimit;
      this.lastTimestampIn = 0;
      this.lastTimestampOut = 0;
    }
    _bound(timestamp, id) {
      return { timestamp, id: id || new Uint8Array(0) };
    }
    initiate() {
      let output = new WrappedBuffer();
      output.extend(new Uint8Array([PROTOCOL_VERSION]));
      this.splitRange(0, this.storage.size(), this._bound(Number.MAX_VALUE), output);
      return bytesToHex(output.unwrap());
    }
    reconcile(queryMsg, onhave, onneed) {
      const query = new WrappedBuffer(hexToBytes(queryMsg));
      this.lastTimestampIn = this.lastTimestampOut = 0;
      let fullOutput = new WrappedBuffer();
      fullOutput.extend(new Uint8Array([PROTOCOL_VERSION]));
      let protocolVersion = getByte(query);
      if (protocolVersion < 96 || protocolVersion > 111)
        throw Error("invalid negentropy protocol version byte");
      if (protocolVersion !== PROTOCOL_VERSION) {
        throw Error("unsupported negentropy protocol version requested: " + (protocolVersion - 96));
      }
      let storageSize = this.storage.size();
      let prevBound = this._bound(0);
      let prevIndex = 0;
      let skip = false;
      while (query.length !== 0) {
        let o = new WrappedBuffer();
        let doSkip = () => {
          if (skip) {
            skip = false;
            o.extend(this.encodeBound(prevBound));
            o.extend(encodeVarInt(Mode.Skip));
          }
        };
        let currBound = this.decodeBound(query);
        let mode = decodeVarInt(query);
        let lower = prevIndex;
        let upper = this.storage.findLowerBound(prevIndex, storageSize, currBound);
        if (mode === Mode.Skip) {
          skip = true;
        } else if (mode === Mode.Fingerprint) {
          let theirFingerprint = getBytes(query, FINGERPRINT_SIZE);
          let ourFingerprint = this.storage.fingerprint(lower, upper);
          if (compareUint8Array(theirFingerprint, ourFingerprint) !== 0) {
            doSkip();
            this.splitRange(lower, upper, currBound, o);
          } else {
            skip = true;
          }
        } else if (mode === Mode.IdList) {
          let numIds = decodeVarInt(query);
          let theirElems = {};
          for (let i2 = 0; i2 < numIds; i2++) {
            let e = getBytes(query, ID_SIZE);
            theirElems[bytesToHex(e)] = e;
          }
          skip = true;
          this.storage.iterate(lower, upper, (item) => {
            let k = item.id;
            const id = bytesToHex(k);
            if (!theirElems[id]) {
              onhave?.(id);
            } else {
              delete theirElems[bytesToHex(k)];
            }
            return true;
          });
          if (onneed) {
            for (let v of Object.values(theirElems)) {
              onneed(bytesToHex(v));
            }
          }
        } else {
          throw Error("unexpected mode");
        }
        if (this.exceededFrameSizeLimit(fullOutput.length + o.length)) {
          let remainingFingerprint = this.storage.fingerprint(upper, storageSize);
          fullOutput.extend(this.encodeBound(this._bound(Number.MAX_VALUE)));
          fullOutput.extend(encodeVarInt(Mode.Fingerprint));
          fullOutput.extend(remainingFingerprint);
          break;
        } else {
          fullOutput.extend(o);
        }
        prevIndex = upper;
        prevBound = currBound;
      }
      return fullOutput.length === 1 ? null : bytesToHex(fullOutput.unwrap());
    }
    splitRange(lower, upper, upperBound, o) {
      let numElems = upper - lower;
      let buckets = 16;
      if (numElems < buckets * 2) {
        o.extend(this.encodeBound(upperBound));
        o.extend(encodeVarInt(Mode.IdList));
        o.extend(encodeVarInt(numElems));
        this.storage.iterate(lower, upper, (item) => {
          o.extend(item.id);
          return true;
        });
      } else {
        let itemsPerBucket = Math.floor(numElems / buckets);
        let bucketsWithExtra = numElems % buckets;
        let curr = lower;
        for (let i2 = 0; i2 < buckets; i2++) {
          let bucketSize = itemsPerBucket + (i2 < bucketsWithExtra ? 1 : 0);
          let ourFingerprint = this.storage.fingerprint(curr, curr + bucketSize);
          curr += bucketSize;
          let nextBound;
          if (curr === upper) {
            nextBound = upperBound;
          } else {
            let prevItem;
            let currItem;
            this.storage.iterate(curr - 1, curr + 1, (item, index) => {
              if (index === curr - 1)
                prevItem = item;
              else
                currItem = item;
              return true;
            });
            nextBound = this.getMinimalBound(prevItem, currItem);
          }
          o.extend(this.encodeBound(nextBound));
          o.extend(encodeVarInt(Mode.Fingerprint));
          o.extend(ourFingerprint);
        }
      }
    }
    exceededFrameSizeLimit(n) {
      return n > this.frameSizeLimit - 200;
    }
    decodeTimestampIn(encoded) {
      let timestamp = decodeVarInt(encoded);
      timestamp = timestamp === 0 ? Number.MAX_VALUE : timestamp - 1;
      if (this.lastTimestampIn === Number.MAX_VALUE || timestamp === Number.MAX_VALUE) {
        this.lastTimestampIn = Number.MAX_VALUE;
        return Number.MAX_VALUE;
      }
      timestamp += this.lastTimestampIn;
      this.lastTimestampIn = timestamp;
      return timestamp;
    }
    decodeBound(encoded) {
      let timestamp = this.decodeTimestampIn(encoded);
      let len = decodeVarInt(encoded);
      if (len > ID_SIZE)
        throw Error("bound key too long");
      let id = getBytes(encoded, len);
      return { timestamp, id };
    }
    encodeTimestampOut(timestamp) {
      if (timestamp === Number.MAX_VALUE) {
        this.lastTimestampOut = Number.MAX_VALUE;
        return encodeVarInt(0);
      }
      let temp = timestamp;
      timestamp -= this.lastTimestampOut;
      this.lastTimestampOut = temp;
      return encodeVarInt(timestamp + 1);
    }
    encodeBound(key) {
      let output = new WrappedBuffer();
      output.extend(this.encodeTimestampOut(key.timestamp));
      output.extend(encodeVarInt(key.id.length));
      output.extend(key.id);
      return output;
    }
    getMinimalBound(prev, curr) {
      if (curr.timestamp !== prev.timestamp) {
        return this._bound(curr.timestamp);
      } else {
        let sharedPrefixBytes = 0;
        let currKey = curr.id;
        let prevKey = prev.id;
        for (let i2 = 0; i2 < ID_SIZE; i2++) {
          if (currKey[i2] !== prevKey[i2])
            break;
          sharedPrefixBytes++;
        }
        return this._bound(curr.timestamp, curr.id.subarray(0, sharedPrefixBytes + 1));
      }
    }
  };
  function compareUint8Array(a, b) {
    for (let i2 = 0; i2 < a.byteLength; i2++) {
      if (a[i2] < b[i2])
        return -1;
      if (a[i2] > b[i2])
        return 1;
    }
    if (a.byteLength > b.byteLength)
      return 1;
    if (a.byteLength < b.byteLength)
      return -1;
    return 0;
  }
  function itemCompare(a, b) {
    if (a.timestamp === b.timestamp) {
      return compareUint8Array(a.id, b.id);
    }
    return a.timestamp - b.timestamp;
  }
  var NegentropySync = class {
    relay;
    storage;
    neg;
    filter;
    subscription;
    onhave;
    onneed;
    constructor(relay, storage4, filter, params = {}) {
      this.relay = relay;
      this.storage = storage4;
      this.neg = new Negentropy(storage4);
      this.onhave = params.onhave;
      this.onneed = params.onneed;
      this.filter = filter;
      this.subscription = this.relay.prepareSubscription([{}], { label: params.label || "negentropy" });
      this.subscription.oncustom = (data) => {
        switch (data[0]) {
          case "NEG-MSG": {
            if (data.length < 3) {
              console.warn(`got invalid NEG-MSG from ${this.relay.url}: ${data}`);
            }
            try {
              const response = this.neg.reconcile(data[2], this.onhave, this.onneed);
              if (response) {
                this.relay.send(`["NEG-MSG", "${this.subscription.id}", "${response}"]`);
              } else {
                this.close();
                params.onclose?.();
              }
            } catch (error) {
              console.error("negentropy reconcile error:", error);
              params?.onclose?.(`reconcile error: ${error}`);
            }
            break;
          }
          case "NEG-CLOSE": {
            const reason = data[2];
            console.warn("negentropy error:", reason);
            params.onclose?.(reason);
            break;
          }
          case "NEG-ERR": {
            params.onclose?.();
          }
        }
      };
    }
    async start() {
      const initMsg = this.neg.initiate();
      this.relay.send(`["NEG-OPEN","${this.subscription.id}",${JSON.stringify(this.filter)},"${initMsg}"]`);
    }
    close() {
      this.relay.send(`["NEG-CLOSE","${this.subscription.id}"]`);
      this.subscription.close();
    }
  };
  var nip98_exports = {};
  __export(nip98_exports, {
    getToken: () => getToken,
    hashPayload: () => hashPayload,
    unpackEventFromToken: () => unpackEventFromToken,
    validateEvent: () => validateEvent2,
    validateEventKind: () => validateEventKind,
    validateEventMethodTag: () => validateEventMethodTag,
    validateEventPayloadTag: () => validateEventPayloadTag,
    validateEventTimestamp: () => validateEventTimestamp,
    validateEventUrlTag: () => validateEventUrlTag,
    validateToken: () => validateToken
  });
  var _authorizationScheme = "Nostr ";
  async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {
    const event = {
      kind: HTTPAuth,
      tags: [
        ["u", loginUrl],
        ["method", httpMethod]
      ],
      created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
      content: ""
    };
    if (payload) {
      event.tags.push(["payload", hashPayload(payload)]);
    }
    const signedEvent = await sign(event);
    const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
    return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
  }
  async function validateToken(token, url, method) {
    const event = await unpackEventFromToken(token).catch((error) => {
      throw error;
    });
    const valid = await validateEvent2(event, url, method).catch((error) => {
      throw error;
    });
    return valid;
  }
  async function unpackEventFromToken(token) {
    if (!token) {
      throw new Error("Missing token");
    }
    token = token.replace(_authorizationScheme, "");
    const eventB64 = utf8Decoder.decode(base64.decode(token));
    if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
      throw new Error("Invalid token");
    }
    const event = JSON.parse(eventB64);
    return event;
  }
  function validateEventTimestamp(event) {
    if (!event.created_at) {
      return false;
    }
    return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - event.created_at < 60;
  }
  function validateEventKind(event) {
    return event.kind === HTTPAuth;
  }
  function validateEventUrlTag(event, url) {
    const urlTag = event.tags.find((t) => t[0] === "u");
    if (!urlTag) {
      return false;
    }
    return urlTag.length > 0 && urlTag[1] === url;
  }
  function validateEventMethodTag(event, method) {
    const methodTag = event.tags.find((t) => t[0] === "method");
    if (!methodTag) {
      return false;
    }
    return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
  }
  function hashPayload(payload) {
    const hash = sha256(utf8Encoder.encode(JSON.stringify(payload)));
    return bytesToHex(hash);
  }
  function validateEventPayloadTag(event, payload) {
    const payloadTag = event.tags.find((t) => t[0] === "payload");
    if (!payloadTag) {
      return false;
    }
    const payloadHash = hashPayload(payload);
    return payloadTag.length > 0 && payloadTag[1] === payloadHash;
  }
  async function validateEvent2(event, url, method, body) {
    if (!verifyEvent(event)) {
      throw new Error("Invalid nostr event, signature invalid");
    }
    if (!validateEventKind(event)) {
      throw new Error("Invalid nostr event, kind invalid");
    }
    if (!validateEventTimestamp(event)) {
      throw new Error("Invalid nostr event, created_at timestamp invalid");
    }
    if (!validateEventUrlTag(event, url)) {
      throw new Error("Invalid nostr event, url tag invalid");
    }
    if (!validateEventMethodTag(event, method)) {
      throw new Error("Invalid nostr event, method tag invalid");
    }
    if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
      if (!validateEventPayloadTag(event, body)) {
        throw new Error("Invalid nostr event, payload tag does not match request body hash");
      }
    }
    return true;
  }

  // node_modules/@noble/hashes/pbkdf2.js
  function pbkdf2Init(hash, _password, _salt, _opts) {
    ahash(hash);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    anumber(c, "c");
    anumber(dkLen, "dkLen");
    anumber(asyncTick, "asyncTick");
    if (c < 1)
      throw new Error("iterations (c) must be >= 1");
    const password = kdfInputToBytes(_password, "password");
    const salt = kdfInputToBytes(_salt, "salt");
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    clean(u);
    return DK;
  }
  function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i2 = 0; i2 < Ti.length; i2++)
          Ti[i2] ^= u[i2];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // node_modules/@noble/hashes/scrypt.js
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i2 = 0; i2 < 8; i2 += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i2 = 0; i2 < 16; i2++)
      out[tail + i2] = input[ii + (2 * r - 1) * 16 + i2];
    for (let i2 = 0; i2 < r; i2++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i2 > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    anumber(N, "N");
    anumber(r, "r");
    anumber(p, "p");
    anumber(dkLen, "dkLen");
    anumber(asyncTick, "asyncTick");
    anumber(maxmem, "maxmem");
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb must be a function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    const pow32 = Math.pow(2, 32);
    if (N <= 1 || (N & N - 1) !== 0 || N > pow32)
      throw new Error('"N" expected a power of 2, and 2^1 <= N <= 2^32');
    if (p < 1 || p > (pow32 - 1) * 32 / blockSize)
      throw new Error('"p" expected integer 1..((2^32 - 1) * 32) / (128 * r)');
    if (dkLen < 1 || dkLen > (pow32 - 1) * 32)
      throw new Error('"dkLen" expected integer 1..(2^32 - 1) * 32');
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem)
      throw new Error('"maxmem" limit was hit, expected 128*r*(N+p) <= "maxmem"=' + maxmem);
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    clean(B, V, tmp);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    swap32IfBE(B32);
    for (let pi = 0; pi < p; pi++) {
      const Pi = blockSize32 * pi;
      for (let i2 = 0; i2 < blockSize32; i2++)
        V[i2] = B32[Pi + i2];
      for (let i2 = 0, pos = 0; i2 < N - 1; i2++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
      blockMixCb();
      for (let i2 = 0; i2 < N; i2++) {
        const j = (B32[Pi + blockSize32 - 16] & N - 1) >>> 0;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi, r);
        blockMixCb();
      }
    }
    swap32IfBE(B32);
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // node_modules/nostr-tools/lib/esm/nip49.js
  var Bech32MaxSize2 = 5e3;
  function encodeBech322(prefix, data) {
    let words = bech32.toWords(data);
    return bech32.encode(prefix, words, Bech32MaxSize2);
  }
  function encodeBytes2(prefix, bytes) {
    return encodeBech322(prefix, bytes);
  }
  function encrypt3(sec, password, logn = 16, ksb = 2) {
    let salt = randomBytes(16);
    let n = 2 ** logn;
    let key = scrypt(password.normalize("NFKC"), salt, { N: n, r: 8, p: 1, dkLen: 32 });
    let nonce = randomBytes(24);
    let aad = Uint8Array.from([ksb]);
    let xc2p1 = xchacha20poly1305(key, nonce, aad);
    let ciphertext = xc2p1.encrypt(sec);
    let b = concatBytes(Uint8Array.from([2]), Uint8Array.from([logn]), salt, nonce, aad, ciphertext);
    return encodeBytes2("ncryptsec", b);
  }
  function decrypt3(ncryptsec, password) {
    let { prefix, words } = bech32.decode(ncryptsec, Bech32MaxSize2);
    if (prefix !== "ncryptsec") {
      throw new Error(`invalid prefix ${prefix}, expected 'ncryptsec'`);
    }
    let b = new Uint8Array(bech32.fromWords(words));
    let version = b[0];
    if (version !== 2) {
      throw new Error(`invalid version ${version}, expected 0x02`);
    }
    let logn = b[1];
    let n = 2 ** logn;
    let salt = b.slice(2, 2 + 16);
    let nonce = b.slice(2 + 16, 2 + 16 + 24);
    let ksb = b[2 + 16 + 24];
    let aad = Uint8Array.from([ksb]);
    let ciphertext = b.slice(2 + 16 + 24 + 1);
    let key = scrypt(password.normalize("NFKC"), salt, { N: n, r: 8, p: 1, dkLen: 32 });
    let xc2p1 = xchacha20poly1305(key, nonce, aad);
    let sec = xc2p1.decrypt(ciphertext);
    return sec;
  }

  // src/utilities/keys.js
  async function generateKeyPair() {
    const privateKeyBytes = randomBytes(32);
    const publicKeyBytes = schnorr.getPublicKey(privateKeyBytes);
    return {
      privateKey: bytesToHex(privateKeyBytes),
      publicKey: bytesToHex(publicKeyBytes)
    };
  }

  // node_modules/async-mutex/index.mjs
  var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
  var E_ALREADY_LOCKED = new Error("mutex already locked");
  var E_CANCELED = new Error("request for lock canceled");
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Semaphore = class {
    constructor(_value, _cancelError = E_CANCELED) {
      this._value = _value;
      this._cancelError = _cancelError;
      this._queue = [];
      this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      return new Promise((resolve, reject) => {
        const task = { resolve, reject, weight, priority };
        const i2 = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
        if (i2 === -1 && weight <= this._value) {
          this._dispatchItem(task);
        } else {
          this._queue.splice(i2 + 1, 0, task);
        }
      });
    }
    runExclusive(callback_1) {
      return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
        const [value, release] = yield this.acquire(weight, priority);
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    waitForUnlock(weight = 1, priority = 0) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      if (this._couldLockImmediately(weight, priority)) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          if (!this._weightedWaiters[weight - 1])
            this._weightedWaiters[weight - 1] = [];
          insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
        });
      }
    }
    isLocked() {
      return this._value <= 0;
    }
    getValue() {
      return this._value;
    }
    setValue(value) {
      this._value = value;
      this._dispatchQueue();
    }
    release(weight = 1) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      this._value += weight;
      this._dispatchQueue();
    }
    cancel() {
      this._queue.forEach((entry) => entry.reject(this._cancelError));
      this._queue = [];
    }
    _dispatchQueue() {
      this._drainUnlockWaiters();
      while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
        this._dispatchItem(this._queue.shift());
        this._drainUnlockWaiters();
      }
    }
    _dispatchItem(item) {
      const previousValue = this._value;
      this._value -= item.weight;
      item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
      let called = false;
      return () => {
        if (called)
          return;
        called = true;
        this.release(weight);
      };
    }
    _drainUnlockWaiters() {
      if (this._queue.length === 0) {
        for (let weight = this._value; weight > 0; weight--) {
          const waiters = this._weightedWaiters[weight - 1];
          if (!waiters)
            continue;
          waiters.forEach((waiter) => waiter.resolve());
          this._weightedWaiters[weight - 1] = [];
        }
      } else {
        const queuedPriority = this._queue[0].priority;
        for (let weight = this._value; weight > 0; weight--) {
          const waiters = this._weightedWaiters[weight - 1];
          if (!waiters)
            continue;
          const i2 = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
          (i2 === -1 ? waiters : waiters.splice(0, i2)).forEach(((waiter) => waiter.resolve()));
        }
      }
    }
    _couldLockImmediately(weight, priority) {
      return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
    }
  };
  function insertSorted(a, v) {
    const i2 = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i2 + 1, 0, v);
  }
  function findIndexFromEnd(a, predicate) {
    for (let i2 = a.length - 1; i2 >= 0; i2--) {
      if (predicate(a[i2])) {
        return i2;
      }
    }
    return -1;
  }
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Mutex = class {
    constructor(cancelError) {
      this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
      return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
        const [, releaser] = yield this._semaphore.acquire(1, priority);
        return releaser;
      });
    }
    runExclusive(callback, priority = 0) {
      return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
      return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
      if (this._semaphore.isLocked())
        this._semaphore.release();
    }
    cancel() {
      return this._semaphore.cancel();
    }
  };

  // src/utilities/browser-polyfill.js
  var _browser = typeof browser !== "undefined" ? browser : typeof chrome !== "undefined" ? chrome : null;
  if (!_browser) {
    throw new Error("browser-polyfill: No extension API namespace found (neither browser nor chrome).");
  }
  var isChrome = typeof browser === "undefined" && typeof chrome !== "undefined";
  function promisify(context, method) {
    return (...args) => {
      try {
        const result = method.apply(context, args);
        if (result && typeof result.then === "function") {
          return result;
        }
      } catch (_) {
      }
      return new Promise((resolve, reject) => {
        method.apply(context, [
          ...args,
          (...cbArgs) => {
            if (_browser.runtime && _browser.runtime.lastError) {
              reject(new Error(_browser.runtime.lastError.message));
            } else {
              resolve(cbArgs.length <= 1 ? cbArgs[0] : cbArgs);
            }
          }
        ]);
      });
    };
  }
  var api = {};
  api.runtime = {
    /**
     * sendMessage ‚Äì always returns a Promise.
     */
    sendMessage(...args) {
      if (!isChrome) {
        return _browser.runtime.sendMessage(...args);
      }
      return promisify(_browser.runtime, _browser.runtime.sendMessage)(...args);
    },
    /**
     * onMessage ‚Äì thin wrapper so callers use a consistent reference.
     * The listener signature is (message, sender, sendResponse).
     * On Chrome the listener can return `true` to keep the channel open,
     * or return a Promise (MV3).  Safari / Firefox expect a Promise return.
     */
    onMessage: _browser.runtime.onMessage,
    /**
     * getURL ‚Äì synchronous on all browsers.
     */
    getURL(path) {
      return _browser.runtime.getURL(path);
    },
    /**
     * openOptionsPage
     */
    openOptionsPage() {
      if (!isChrome) {
        return _browser.runtime.openOptionsPage();
      }
      return promisify(_browser.runtime, _browser.runtime.openOptionsPage)();
    },
    /**
     * Expose the id for convenience.
     */
    get id() {
      return _browser.runtime.id;
    }
  };
  api.storage = {
    local: {
      get(...args) {
        if (!isChrome) {
          return _browser.storage.local.get(...args);
        }
        return promisify(_browser.storage.local, _browser.storage.local.get)(...args);
      },
      set(...args) {
        if (!isChrome) {
          return _browser.storage.local.set(...args);
        }
        return promisify(_browser.storage.local, _browser.storage.local.set)(...args);
      },
      clear(...args) {
        if (!isChrome) {
          return _browser.storage.local.clear(...args);
        }
        return promisify(_browser.storage.local, _browser.storage.local.clear)(...args);
      },
      remove(...args) {
        if (!isChrome) {
          return _browser.storage.local.remove(...args);
        }
        return promisify(_browser.storage.local, _browser.storage.local.remove)(...args);
      }
    }
  };
  api.tabs = {
    create(...args) {
      if (!isChrome) {
        return _browser.tabs.create(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.create)(...args);
    },
    query(...args) {
      if (!isChrome) {
        return _browser.tabs.query(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.query)(...args);
    },
    remove(...args) {
      if (!isChrome) {
        return _browser.tabs.remove(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.remove)(...args);
    },
    update(...args) {
      if (!isChrome) {
        return _browser.tabs.update(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.update)(...args);
    },
    get(...args) {
      if (!isChrome) {
        return _browser.tabs.get(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.get)(...args);
    },
    getCurrent(...args) {
      if (!isChrome) {
        return _browser.tabs.getCurrent(...args);
      }
      return promisify(_browser.tabs, _browser.tabs.getCurrent)(...args);
    }
  };

  // src/utilities/crypto.js
  var PBKDF2_ITERATIONS = 6e5;
  var SALT_BYTES = 16;
  var IV_BYTES = 12;
  function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i2 = 0; i2 < bytes.length; i2++) {
      binary += String.fromCharCode(bytes[i2]);
    }
    return btoa(binary);
  }
  function base64ToArrayBuffer(base642) {
    const binary = atob(base642);
    const bytes = new Uint8Array(binary.length);
    for (let i2 = 0; i2 < binary.length; i2++) {
      bytes[i2] = binary.charCodeAt(i2);
    }
    return bytes.buffer;
  }
  async function deriveKey(password, salt) {
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      enc.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt: salt instanceof Uint8Array ? salt : new Uint8Array(salt),
        iterations: PBKDF2_ITERATIONS,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }
  async function encrypt4(plaintext, password) {
    const salt = crypto.getRandomValues(new Uint8Array(SALT_BYTES));
    const iv = crypto.getRandomValues(new Uint8Array(IV_BYTES));
    const key = await deriveKey(password, salt);
    const enc = new TextEncoder();
    const ciphertext = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      enc.encode(plaintext)
    );
    return JSON.stringify({
      salt: arrayBufferToBase64(salt),
      iv: arrayBufferToBase64(iv),
      ciphertext: arrayBufferToBase64(ciphertext)
    });
  }
  async function decrypt4(encryptedData, password) {
    const { salt, iv, ciphertext } = JSON.parse(encryptedData);
    const saltBuf = new Uint8Array(base64ToArrayBuffer(salt));
    const ivBuf = new Uint8Array(base64ToArrayBuffer(iv));
    const ctBuf = base64ToArrayBuffer(ciphertext);
    const key = await deriveKey(password, saltBuf);
    const plainBuf = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: ivBuf },
      key,
      ctBuf
    );
    const dec = new TextDecoder();
    return dec.decode(plainBuf);
  }
  async function hashPassword(password, salt) {
    if (!salt) {
      salt = crypto.getRandomValues(new Uint8Array(SALT_BYTES));
    } else if (typeof salt === "string") {
      salt = new Uint8Array(base64ToArrayBuffer(salt));
    }
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      enc.encode(password),
      "PBKDF2",
      false,
      ["deriveBits"]
    );
    const hashBits = await crypto.subtle.deriveBits(
      {
        name: "PBKDF2",
        salt,
        iterations: PBKDF2_ITERATIONS,
        hash: "SHA-256"
      },
      keyMaterial,
      256
    );
    return {
      hash: arrayBufferToBase64(hashBits),
      salt: arrayBufferToBase64(salt)
    };
  }
  async function verifyPassword(password, storedHash, storedSalt) {
    const { hash } = await hashPassword(password, storedSalt);
    return hash === storedHash;
  }

  // src/utilities/utils.js
  var storage = api.storage.local;
  var RECOMMENDED_RELAYS = [
    new URL("wss://relay.damus.io"),
    new URL("wss://relay.primal.net"),
    new URL("wss://relay.snort.social"),
    new URL("wss://relay.getalby.com/v1"),
    new URL("wss://nos.lol"),
    new URL("wss://brb.io"),
    new URL("wss://nostr.orangepill.dev")
  ];
  async function getProfiles() {
    let profiles = await storage.get({ profiles: [] });
    return profiles.profiles;
  }
  async function getProfile(index) {
    let profiles = await getProfiles();
    return profiles[index];
  }
  async function getProfileIndex() {
    const index = await storage.get({ profileIndex: 0 });
    return index.profileIndex;
  }
  async function get(item) {
    return (await storage.get(item))[item];
  }
  async function getPermission(host, action) {
    let index = await getProfileIndex();
    let profile = await getProfile(index);
    return profile.hosts?.[host]?.[action] || "ask";
  }
  async function setPermission(host, action, perm, index = null) {
    let profiles = await getProfiles();
    if (!index) {
      index = await getProfileIndex();
    }
    let profile = profiles[index];
    let newPerms = profile.hosts[host] || {};
    newPerms = { ...newPerms, [action]: perm };
    profile.hosts[host] = newPerms;
    profiles[index] = profile;
    await storage.set({ profiles });
  }
  async function isEncrypted() {
    let data = await storage.get({ isEncrypted: false });
    return data.isEncrypted;
  }
  async function setPasswordHash(password) {
    const { hash, salt } = await hashPassword(password);
    await storage.set({
      passwordHash: hash,
      passwordSalt: salt,
      isEncrypted: true
    });
  }
  async function checkPassword(password) {
    const data = await storage.get({
      passwordHash: null,
      passwordSalt: null
    });
    if (!data.passwordHash || !data.passwordSalt) return false;
    return verifyPassword(password, data.passwordHash, data.passwordSalt);
  }
  async function removePasswordProtection(password) {
    const valid = await checkPassword(password);
    if (!valid) throw new Error("Invalid password");
    let profiles = await getProfiles();
    for (let i2 = 0; i2 < profiles.length; i2++) {
      if (profiles[i2].type === "bunker") continue;
      if (isEncryptedBlob(profiles[i2].privKey)) {
        profiles[i2].privKey = await decrypt4(profiles[i2].privKey, password);
      }
    }
    await storage.set({
      profiles,
      isEncrypted: false,
      passwordHash: null,
      passwordSalt: null
    });
  }
  async function encryptAllKeys(password) {
    let profiles = await getProfiles();
    for (let i2 = 0; i2 < profiles.length; i2++) {
      if (profiles[i2].type === "bunker") continue;
      if (!isEncryptedBlob(profiles[i2].privKey)) {
        profiles[i2].privKey = await encrypt4(profiles[i2].privKey, password);
      }
    }
    await setPasswordHash(password);
    await storage.set({ profiles });
  }
  async function changePasswordForKeys(oldPassword, newPassword) {
    let profiles = await getProfiles();
    for (let i2 = 0; i2 < profiles.length; i2++) {
      if (profiles[i2].type === "bunker") continue;
      let hex = profiles[i2].privKey;
      if (isEncryptedBlob(hex)) {
        hex = await decrypt4(hex, oldPassword);
      }
      profiles[i2].privKey = await encrypt4(hex, newPassword);
    }
    const { hash, salt } = await hashPassword(newPassword);
    await storage.set({
      profiles,
      passwordHash: hash,
      passwordSalt: salt,
      isEncrypted: true
    });
  }
  async function getDecryptedPrivKey(profile, password) {
    if (profile.type === "bunker") return "";
    if (isEncryptedBlob(profile.privKey)) {
      return decrypt4(profile.privKey, password);
    }
    return profile.privKey;
  }
  function isEncryptedBlob(value) {
    if (typeof value !== "string") return false;
    try {
      const parsed = JSON.parse(value);
      return !!(parsed.salt && parsed.iv && parsed.ciphertext);
    } catch {
      return false;
    }
  }

  // node_modules/idb/build/index.js
  var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
  var idbProxyableTypes;
  var cursorAdvanceMethods;
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  var transactionDoneMap = /* @__PURE__ */ new WeakMap();
  var transformCache = /* @__PURE__ */ new WeakMap();
  var reverseTransformCache = /* @__PURE__ */ new WeakMap();
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = () => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };
      const success = () => {
        resolve(wrap(request.result));
        unlisten();
      };
      const error = () => {
        reject(request.error);
        unlisten();
      };
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = () => {
        tx.removeEventListener("complete", complete2);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };
      const complete2 = () => {
        resolve();
        unlisten();
      };
      const error = () => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };
      tx.addEventListener("complete", complete2);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  var idbProxyTraps = {
    get(target, prop, receiver) {
      if (target instanceof IDBTransaction) {
        if (prop === "done")
          return transactionDoneMap.get(target);
        if (prop === "store") {
          return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
        }
      }
      return wrap(target[prop]);
    },
    set(target, prop, value) {
      target[prop] = value;
      return true;
    },
    has(target, prop) {
      if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
        return true;
      }
      return prop in target;
    }
  };
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  var unwrap = (value) => reverseTransformCache.get(value);
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
  var writeMethods = ["put", "add", "delete", "clear"];
  var cachedMethods = /* @__PURE__ */ new Map();
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
  }
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
  }));
  var advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
  var methodMap = {};
  var advanceResults = /* @__PURE__ */ new WeakMap();
  var ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
  var cursorIteratorTraps = {
    get(target, prop) {
      if (!advanceMethodProps.includes(prop))
        return target[prop];
      let cachedFunc = methodMap[prop];
      if (!cachedFunc) {
        cachedFunc = methodMap[prop] = function(...args) {
          advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
        };
      }
      return cachedFunc;
    }
  };
  async function* iterate(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get(target, prop, receiver) {
      if (isIteratorProp(target, prop))
        return iterate;
      return oldTraps.get(target, prop, receiver);
    },
    has(target, prop) {
      return isIteratorProp(target, prop) || oldTraps.has(target, prop);
    }
  }));

  // src/utilities/db.js
  async function openEventsDb() {
    return await openDB("events", 1, {
      upgrade(db) {
        const events = db.createObjectStore("events", {
          keyPath: "event.id"
        });
        events.createIndex("pubkey", "event.pubkey");
        events.createIndex("created_at", "event.created_at");
        events.createIndex("kind", "event.kind");
        events.createIndex("host", "metadata.host");
      }
    });
  }
  async function saveEvent(event) {
    let db = await openEventsDb();
    return db.put("events", event);
  }

  // node_modules/nostr-tools/lib/esm/nip44.js
  var utf8Decoder2 = new TextDecoder("utf-8");
  var utf8Encoder2 = new TextEncoder();
  var minPlaintextSize2 = 1;
  var maxPlaintextSize2 = 65535;
  function getConversationKey2(privkeyA, pubkeyB) {
    const sharedX = secp256k1.getSharedSecret(privkeyA, hexToBytes("02" + pubkeyB)).subarray(1, 33);
    return extract(sha256, sharedX, utf8Encoder2.encode("nip44-v2"));
  }
  function getMessageKeys2(conversationKey, nonce) {
    const keys = expand(sha256, conversationKey, nonce, 76);
    return {
      chacha_key: keys.subarray(0, 32),
      chacha_nonce: keys.subarray(32, 44),
      hmac_key: keys.subarray(44, 76)
    };
  }
  function calcPaddedLen2(len) {
    if (!Number.isSafeInteger(len) || len < 1)
      throw new Error("expected positive integer");
    if (len <= 32)
      return 32;
    const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
    const chunk = nextPower <= 256 ? 32 : nextPower / 8;
    return chunk * (Math.floor((len - 1) / chunk) + 1);
  }
  function writeU16BE2(num2) {
    if (!Number.isSafeInteger(num2) || num2 < minPlaintextSize2 || num2 > maxPlaintextSize2)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const arr = new Uint8Array(2);
    new DataView(arr.buffer).setUint16(0, num2, false);
    return arr;
  }
  function pad2(plaintext) {
    const unpadded = utf8Encoder2.encode(plaintext);
    const unpaddedLen = unpadded.length;
    const prefix = writeU16BE2(unpaddedLen);
    const suffix = new Uint8Array(calcPaddedLen2(unpaddedLen) - unpaddedLen);
    return concatBytes(prefix, unpadded, suffix);
  }
  function unpad2(padded) {
    const unpaddedLen = new DataView(padded.buffer).getUint16(0);
    const unpadded = padded.subarray(2, 2 + unpaddedLen);
    if (unpaddedLen < minPlaintextSize2 || unpaddedLen > maxPlaintextSize2 || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen2(unpaddedLen))
      throw new Error("invalid padding");
    return utf8Decoder2.decode(unpadded);
  }
  function hmacAad2(key, message, aad) {
    if (aad.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const combined = concatBytes(aad, message);
    return hmac(sha256, key, combined);
  }
  function decodePayload2(payload) {
    if (typeof payload !== "string")
      throw new Error("payload must be a valid string");
    const plen = payload.length;
    if (plen < 132 || plen > 87472)
      throw new Error("invalid payload length: " + plen);
    if (payload[0] === "#")
      throw new Error("unknown encryption version");
    let data;
    try {
      data = base64.decode(payload);
    } catch (error) {
      throw new Error("invalid base64: " + error.message);
    }
    const dlen = data.length;
    if (dlen < 99 || dlen > 65603)
      throw new Error("invalid data length: " + dlen);
    const vers = data[0];
    if (vers !== 2)
      throw new Error("unknown encryption version " + vers);
    return {
      nonce: data.subarray(1, 33),
      ciphertext: data.subarray(33, -32),
      mac: data.subarray(-32)
    };
  }
  function encrypt5(plaintext, conversationKey, nonce = randomBytes(32)) {
    const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys2(conversationKey, nonce);
    const padded = pad2(plaintext);
    const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
    const mac = hmacAad2(hmac_key, ciphertext, nonce);
    return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac));
  }
  function decrypt5(payload, conversationKey) {
    const { nonce, ciphertext, mac } = decodePayload2(payload);
    const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys2(conversationKey, nonce);
    const calculatedMac = hmacAad2(hmac_key, ciphertext, nonce);
    if (!equalBytes(calculatedMac, mac))
      throw new Error("invalid MAC");
    const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
    return unpad2(padded);
  }
  var v22 = {
    utils: {
      getConversationKey: getConversationKey2,
      calcPaddedLen: calcPaddedLen2
    },
    encrypt: encrypt5,
    decrypt: decrypt5
  };

  // src/utilities/nip46.js
  var storage2 = api.storage.local;
  var log = (msg) => console.log("NIP-46: ", msg);
  var sessions = /* @__PURE__ */ new Map();
  function parseBunkerUrl(url) {
    if (!url.startsWith("bunker://")) {
      throw new Error("Invalid bunker URL: must start with bunker://");
    }
    const parsed = new URL(url);
    const remotePubkey = parsed.hostname || parsed.pathname.replace("//", "");
    if (!/^[0-9a-f]{64}$/i.test(remotePubkey)) {
      throw new Error("Invalid bunker URL: pubkey must be 64 hex characters");
    }
    const relays = parsed.searchParams.getAll("relay");
    if (relays.length === 0) {
      throw new Error("Invalid bunker URL: at least one relay is required");
    }
    for (const relay of relays) {
      try {
        const r = new URL(relay);
        if (r.protocol !== "wss:" && r.protocol !== "ws:") {
          throw new Error(`Invalid relay protocol: ${r.protocol}`);
        }
      } catch (e) {
        throw new Error(`Invalid relay URL: ${relay}`);
      }
    }
    const secret = parsed.searchParams.get("secret") || null;
    return { remotePubkey, relays, secret };
  }
  var RelayConnection = class {
    constructor(url) {
      this.url = url;
      this.ws = null;
      this.subscriptions = /* @__PURE__ */ new Map();
      this.eoseCallbacks = /* @__PURE__ */ new Map();
      this.connected = false;
      this.reconnectTimer = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 5;
    }
    connect() {
      return new Promise((resolve, reject) => {
        try {
          this.ws = new WebSocket(this.url);
        } catch (e) {
          reject(new Error(`Failed to create WebSocket: ${e.message}`));
          return;
        }
        const timeout = setTimeout(() => {
          this.ws?.close();
          reject(new Error(`Connection timeout: ${this.url}`));
        }, 1e4);
        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.connected = true;
          this.reconnectAttempts = 0;
          log(`Connected to ${this.url}`);
          resolve();
        };
        this.ws.onerror = (err) => {
          clearTimeout(timeout);
          log(`WebSocket error: ${this.url}`);
          reject(new Error(`WebSocket error: ${this.url}`));
        };
        this.ws.onclose = () => {
          this.connected = false;
          log(`Disconnected from ${this.url}`);
          this.scheduleReconnect();
        };
        this.ws.onmessage = (msg) => {
          try {
            const data = JSON.parse(msg.data);
            this.handleMessage(data);
          } catch (e) {
            log(`Failed to parse message: ${e.message}`);
          }
        };
      });
    }
    handleMessage(data) {
      const [type, subId, ...rest] = data;
      if (type === "EVENT" && subId && rest[0]) {
        const event = rest[0];
        const handler = this.subscriptions.get(subId);
        if (handler) {
          handler(event);
        }
      } else if (type === "EOSE" && subId) {
        const eoseHandler = this.eoseCallbacks.get(subId);
        if (eoseHandler) {
          this.eoseCallbacks.delete(subId);
          eoseHandler();
        }
      } else if (type === "OK") {
      } else if (type === "NOTICE") {
        log(`Relay notice: ${rest[0]}`);
      }
    }
    subscribe(subId, filters, onEvent, onEose = null) {
      if (!this.connected || !this.ws) {
        throw new Error("Not connected");
      }
      this.subscriptions.set(subId, onEvent);
      if (onEose) {
        this.eoseCallbacks.set(subId, onEose);
      }
      this.ws.send(JSON.stringify(["REQ", subId, ...filters]));
    }
    unsubscribe(subId) {
      if (this.ws && this.connected) {
        this.ws.send(JSON.stringify(["CLOSE", subId]));
      }
      this.subscriptions.delete(subId);
      this.eoseCallbacks.delete(subId);
    }
    publish(event) {
      if (!this.connected || !this.ws) {
        throw new Error("Not connected");
      }
      this.ws.send(JSON.stringify(["EVENT", event]));
    }
    scheduleReconnect() {
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        log(`Max reconnect attempts reached for ${this.url}`);
        return;
      }
      const delay = Math.min(1e3 * Math.pow(2, this.reconnectAttempts), 3e4);
      this.reconnectAttempts++;
      this.reconnectTimer = setTimeout(() => {
        log(`Reconnecting to ${this.url} (attempt ${this.reconnectAttempts})`);
        this.connect().catch(() => {
        });
      }, delay);
    }
    close() {
      clearTimeout(this.reconnectTimer);
      this.maxReconnectAttempts = 0;
      this.subscriptions.clear();
      this.eoseCallbacks.clear();
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      this.connected = false;
    }
  };
  var BunkerSession = class {
    constructor({ remotePubkey, relays, secret }) {
      this.remotePubkey = remotePubkey;
      this.relayUrls = relays;
      this.secret = secret;
      this.sessionPrivkey = null;
      this.sessionPubkey = null;
      this.conversationKey = null;
      this.relays = [];
      this.pendingRequests = /* @__PURE__ */ new Map();
      this.connected = false;
      this.subId = `nostrkey-${crypto.randomUUID().slice(0, 8)}`;
    }
    /**
     * Initialize the ephemeral session keypair (async)
     */
    async init() {
      if (this.sessionPrivkey) return;
      const keyPair = await generateKeyPair();
      this.sessionPrivkey = hexToBytes(keyPair.privateKey);
      this.sessionPubkey = keyPair.publicKey.hex;
      this.conversationKey = v22.utils.getConversationKey(
        this.sessionPrivkey,
        this.remotePubkey
      );
    }
    /**
     * Connect to all relays and subscribe for responses
     */
    async connect() {
      await this.init();
      const connections = this.relayUrls.map((url) => {
        const relay = new RelayConnection(url);
        return relay.connect().then(() => {
          this.relays.push(relay);
          return relay;
        });
      });
      const results = await Promise.allSettled(connections);
      const connected = results.filter((r) => r.status === "fulfilled");
      if (connected.length === 0) {
        throw new Error("Failed to connect to any relay");
      }
      log(`Connected to ${connected.length}/${this.relayUrls.length} relays`);
      for (const relay of this.relays) {
        relay.subscribe(
          this.subId,
          [{ kinds: [24133], "#p": [this.sessionPubkey] }],
          (event) => this.handleResponse(event)
        );
      }
      this.connected = true;
      if (this.secret) {
        await this.sendRequest("connect", [this.remotePubkey, this.secret]);
      } else {
        await this.sendRequest("connect", [this.remotePubkey]);
      }
    }
    /**
     * Handle an incoming NIP-46 response event
     */
    handleResponse(event) {
      if (event.pubkey !== this.remotePubkey) {
        log(`Ignoring event from unknown pubkey: ${event.pubkey}`);
        return;
      }
      try {
        const plaintext = v22.decrypt(event.content, this.conversationKey);
        const response = JSON.parse(plaintext);
        log(`Response: ${response.id} -> ${response.result ? "ok" : response.error}`);
        const pending = this.pendingRequests.get(response.id);
        if (pending) {
          this.pendingRequests.delete(response.id);
          if (response.error) {
            pending.reject(new Error(response.error));
          } else {
            pending.resolve(response.result);
          }
        }
      } catch (e) {
        log(`Failed to handle response: ${e.message}`);
      }
    }
    /**
     * Send an encrypted NIP-46 request to the bunker
     */
    async sendRequest(method, params = []) {
      if (!this.connected && method !== "connect") {
        throw new Error("Not connected to bunker");
      }
      const id = crypto.randomUUID();
      const request = JSON.stringify({ id, method, params });
      const encrypted = v22.encrypt(request, this.conversationKey);
      const event = finalizeEvent({
        kind: 24133,
        content: encrypted,
        tags: [["p", this.remotePubkey]],
        created_at: Math.floor(Date.now() / 1e3)
      }, this.sessionPrivkey);
      for (const relay of this.relays) {
        try {
          relay.publish(event);
        } catch (e) {
          log(`Failed to publish to ${relay.url}: ${e.message}`);
        }
      }
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          this.pendingRequests.delete(id);
          reject(new Error(`Request timeout: ${method}`));
        }, 3e4);
        this.pendingRequests.set(id, {
          resolve: (result) => {
            clearTimeout(timeout);
            resolve(result);
          },
          reject: (error) => {
            clearTimeout(timeout);
            reject(error);
          }
        });
      });
    }
    /**
     * NIP-46 Methods
     */
    async getPublicKey() {
      return await this.sendRequest("get_public_key");
    }
    async signEvent(event) {
      const result = await this.sendRequest("sign_event", [JSON.stringify(event)]);
      return JSON.parse(result);
    }
    async nip04Encrypt(thirdPartyPubkey, plaintext) {
      return await this.sendRequest("nip04_encrypt", [thirdPartyPubkey, plaintext]);
    }
    async nip04Decrypt(thirdPartyPubkey, ciphertext) {
      return await this.sendRequest("nip04_decrypt", [thirdPartyPubkey, ciphertext]);
    }
    async nip44Encrypt(thirdPartyPubkey, plaintext) {
      return await this.sendRequest("nip44_encrypt", [thirdPartyPubkey, plaintext]);
    }
    async nip44Decrypt(thirdPartyPubkey, ciphertext) {
      return await this.sendRequest("nip44_decrypt", [thirdPartyPubkey, ciphertext]);
    }
    async ping() {
      return await this.sendRequest("ping");
    }
    /**
     * Get session info for persistence
     */
    getSessionInfo() {
      return {
        remotePubkey: this.remotePubkey,
        relayUrls: this.relayUrls,
        secret: this.secret,
        sessionPrivkey: bytesToHex(this.sessionPrivkey),
        sessionPubkey: this.sessionPubkey
      };
    }
    /**
     * Disconnect from all relays
     */
    disconnect() {
      for (const relay of this.relays) {
        relay.unsubscribe(this.subId);
        relay.close();
      }
      this.relays = [];
      this.pendingRequests.clear();
      this.connected = false;
      log("Disconnected from bunker");
    }
  };
  function restoreSession(sessionInfo) {
    const session = new BunkerSession({
      remotePubkey: sessionInfo.remotePubkey,
      relays: sessionInfo.relayUrls,
      secret: sessionInfo.secret
    });
    session.sessionPrivkey = hexToBytes(sessionInfo.sessionPrivkey);
    session.sessionPubkey = sessionInfo.sessionPubkey;
    session.conversationKey = v22.utils.getConversationKey(
      session.sessionPrivkey,
      session.remotePubkey
    );
    return session;
  }
  async function getOrCreateSession(profileIndex) {
    if (sessions.has(profileIndex)) {
      const session2 = sessions.get(profileIndex);
      if (session2.connected) {
        return session2;
      }
      session2.disconnect();
      sessions.delete(profileIndex);
    }
    const data = await storage2.get({ bunkerSessions: {} });
    const sessionInfo = data.bunkerSessions?.[profileIndex];
    if (!sessionInfo) {
      throw new Error("No bunker session configured for this profile");
    }
    const session = restoreSession(sessionInfo);
    await session.connect();
    sessions.set(profileIndex, session);
    return session;
  }
  async function createSession(profileIndex, bunkerUrl) {
    if (sessions.has(profileIndex)) {
      sessions.get(profileIndex).disconnect();
      sessions.delete(profileIndex);
    }
    const config = parseBunkerUrl(bunkerUrl);
    const session = new BunkerSession(config);
    await session.connect();
    const data = await storage2.get({ bunkerSessions: {} });
    const bunkerSessions = data.bunkerSessions || {};
    bunkerSessions[profileIndex] = session.getSessionInfo();
    await storage2.set({ bunkerSessions });
    sessions.set(profileIndex, session);
    return session;
  }
  async function disconnectSession(profileIndex) {
    if (sessions.has(profileIndex)) {
      sessions.get(profileIndex).disconnect();
      sessions.delete(profileIndex);
    }
    const data = await storage2.get({ bunkerSessions: {} });
    const bunkerSessions = data.bunkerSessions || {};
    delete bunkerSessions[profileIndex];
    await storage2.set({ bunkerSessions });
  }
  function isSessionActive(profileIndex) {
    return sessions.has(profileIndex) && sessions.get(profileIndex).connected;
  }
  function validateBunkerUrl(url) {
    try {
      parseBunkerUrl(url);
      return { valid: true, error: null };
    } catch (e) {
      return { valid: false, error: e.message };
    }
  }

  // src/utilities/nip78.js
  var KIND_APP_DATA = 30078;
  var KIND_DELETION = 5;
  var DTAG_PREFIX = "nostrkey:";
  var CLIENT_TAG = "nostrkey";
  function buildVaultEvent(path, encryptedContent) {
    return {
      kind: KIND_APP_DATA,
      content: encryptedContent,
      tags: [
        ["d", `${DTAG_PREFIX}${path}`],
        ["client", CLIENT_TAG]
      ],
      created_at: Math.floor(Date.now() / 1e3)
    };
  }
  function buildVaultDeletion(eventId, path) {
    return {
      kind: KIND_DELETION,
      content: "vault document deleted",
      tags: [
        ["e", eventId],
        ["a", `${KIND_APP_DATA}::${DTAG_PREFIX}${path}`]
      ],
      created_at: Math.floor(Date.now() / 1e3)
    };
  }
  function buildVaultFilter(pubkey) {
    return {
      kinds: [KIND_APP_DATA],
      authors: [pubkey]
    };
  }
  function parseVaultEvent(event) {
    if (event.kind !== KIND_APP_DATA) return null;
    const dTag = event.tags?.find((t) => t[0] === "d");
    if (!dTag || !dTag[1]?.startsWith(DTAG_PREFIX)) return null;
    const path = dTag[1].slice(DTAG_PREFIX.length);
    if (!path) return null;
    return {
      path,
      content: event.content,
      createdAt: event.created_at,
      eventId: event.id
    };
  }

  // src/background.js
  var storage3 = api.storage.local;
  var log2 = (msg) => console.log("Background: ", msg);
  var validations = {};
  var prompt = { mutex: new Mutex(), release: null, tabId: null };
  var rateLimits = /* @__PURE__ */ new Map();
  var RATE_LIMIT_MAX = 5;
  var RATE_LIMIT_WINDOW = 1e4;
  function isRateLimited(host) {
    const now2 = Date.now();
    let timestamps = rateLimits.get(host) || [];
    timestamps = timestamps.filter((t) => now2 - t < RATE_LIMIT_WINDOW);
    if (timestamps.length >= RATE_LIMIT_MAX) {
      rateLimits.set(host, timestamps);
      return true;
    }
    timestamps.push(now2);
    rateLimits.set(host, timestamps);
    return false;
  }
  var sessionKeys = /* @__PURE__ */ new Map();
  var sessionPassword = null;
  var locked = true;
  var autoLockTimeout = 15 * 60 * 1e3;
  var autoLockTimer = null;
  (async () => {
    const { autoLockMinutes } = await storage3.get({ autoLockMinutes: 15 });
    autoLockTimeout = autoLockMinutes * 60 * 1e3;
  })();
  function resetAutoLock() {
    if (autoLockTimer) clearTimeout(autoLockTimer);
    if (!locked && autoLockTimeout > 0) {
      autoLockTimer = setTimeout(() => {
        lockSession();
      }, autoLockTimeout);
    }
  }
  function lockSession() {
    sessionKeys.clear();
    sessionPassword = null;
    locked = true;
    if (autoLockTimer) {
      clearTimeout(autoLockTimer);
      autoLockTimer = null;
    }
    log2("Session locked.");
  }
  async function unlockSession(password) {
    const valid = await checkPassword(password);
    if (!valid) return { success: false, error: "Invalid password" };
    const profiles = await getProfiles();
    for (let i2 = 0; i2 < profiles.length; i2++) {
      if (profiles[i2].type === "bunker") continue;
      const hex = await getDecryptedPrivKey(profiles[i2], password);
      sessionKeys.set(i2, hex);
    }
    sessionPassword = password;
    locked = false;
    resetAutoLock();
    log2("Session unlocked.");
    return { success: true };
  }
  async function checkLockState() {
    const encrypted = await isEncrypted();
    if (!encrypted) {
      locked = false;
      return false;
    }
    return locked;
  }
  api.runtime.onMessage.addListener((message, _sender, sendResponse) => {
    log2(message);
    let uuid = crypto.randomUUID();
    let sr;
    switch (message.kind) {
      // General
      case "closePrompt":
        prompt.release?.();
        return Promise.resolve(true);
      case "allowed":
        resetAutoLock();
        complete(message);
        return Promise.resolve(true);
      case "denied":
        deny(message);
        return Promise.resolve(true);
      case "generatePrivateKey":
        (async () => {
          try {
            const result = await generatePrivateKey_();
            sendResponse(result);
          } catch (e) {
            console.error("generatePrivateKey error:", e);
            sendResponse(null);
          }
        })();
        return true;
      // Keep message channel open for async sendResponse
      case "savePrivateKey":
        resetAutoLock();
        return savePrivateKey(message.payload);
      case "getNpub":
        resetAutoLock();
        (async () => {
          try {
            const result = await getNpub(message.payload);
            sendResponse(result);
          } catch (e) {
            console.error("getNpub error:", e);
            sendResponse(null);
          }
        })();
        return true;
      case "getNsec":
        resetAutoLock();
        (async () => {
          try {
            const result = await getNsec(message.payload);
            sendResponse(result);
          } catch (e) {
            console.error("getNsec error:", e);
            sendResponse(null);
          }
        })();
        return true;
      case "calcPubKey":
        return Promise.resolve(getPublicKey(message.payload));
      case "npubEncode":
        return Promise.resolve(nip19_exports.npubEncode(message.payload));
      case "copy":
        if (typeof navigator !== "undefined" && navigator.clipboard?.writeText) {
          return navigator.clipboard.writeText(message.payload);
        }
        return Promise.resolve(false);
      // --- Master password / lock handlers ---
      case "isLocked":
        return checkLockState();
      case "isEncrypted":
        return isEncrypted();
      case "unlock":
        return unlockSession(message.payload);
      case "lock":
        lockSession();
        return Promise.resolve(true);
      case "setPassword":
        (async () => {
          try {
            await encryptAllKeys(message.payload);
            const result = await unlockSession(message.payload);
            sendResponse(result);
          } catch (e) {
            sendResponse({ success: false, error: e.message });
          }
        })();
        return true;
      case "changePassword":
        (async () => {
          try {
            const { oldPassword, newPassword } = message.payload;
            const valid = await checkPassword(oldPassword);
            if (!valid) {
              sendResponse({ success: false, error: "Invalid current password" });
              return;
            }
            await changePasswordForKeys(oldPassword, newPassword);
            const result = await unlockSession(newPassword);
            sendResponse(result);
          } catch (e) {
            sendResponse({ success: false, error: e.message });
          }
        })();
        return true;
      case "removePassword":
        (async () => {
          try {
            await removePasswordProtection(message.payload);
            sessionKeys.clear();
            sessionPassword = null;
            locked = false;
            sendResponse({ success: true });
          } catch (e) {
            sendResponse({ success: false, error: e.message });
          }
        })();
        return true;
      case "setAutoLockTimeout":
        autoLockTimeout = message.payload * 60 * 1e3;
        storage3.set({ autoLockMinutes: message.payload });
        resetAutoLock();
        return Promise.resolve(true);
      case "getAutoLockTimeout":
        return (async () => {
          const { autoLockMinutes } = await storage3.get({ autoLockMinutes: 15 });
          return autoLockMinutes;
        })();
      case "resetAutoLock":
        resetAutoLock();
        return Promise.resolve(true);
      // --- NIP-49 ncryptsec handlers ---
      case "ncryptsec.decrypt":
        return (async () => {
          try {
            const { ncryptsec, password } = message.payload;
            const hexKey = bytesToHex(decrypt3(ncryptsec, password));
            return { success: true, hexKey };
          } catch (e) {
            return { success: false, error: e.message || "Decryption failed" };
          }
        })();
      case "ncryptsec.encrypt":
        return (async () => {
          try {
            const { profileIndex: ei, password } = message.payload;
            const profile = await getProfile(ei);
            if (profile?.type === "bunker") {
              return { success: false, error: "Cannot export bunker profile as ncryptsec" };
            }
            const hexKey = await getPlaintextPrivKey(ei, profile);
            const ncryptsec = encrypt3(hexToBytes(hexKey), password);
            return { success: true, ncryptsec };
          } catch (e) {
            return { success: false, error: e.message || "Encryption failed" };
          }
        })();
      // --- NIP-46 Bunker handlers ---
      case "getProfileType":
        return (async () => {
          const pi = message.payload ?? await getProfileIndex();
          const profile = await getProfile(pi);
          return profile?.type || "local";
        })();
      case "bunker.connect":
        return (async () => {
          try {
            const { profileIndex: bi, bunkerUrl } = message.payload;
            const session = await createSession(bi, bunkerUrl);
            const remotePubkey = await session.getPublicKey();
            const profiles = await getProfiles();
            profiles[bi].remotePubkey = remotePubkey;
            profiles[bi].bunkerUrl = bunkerUrl;
            await storage3.set({ profiles });
            return { success: true, remotePubkey };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "bunker.disconnect":
        return (async () => {
          try {
            const bi = message.payload;
            await disconnectSession(bi);
            return { success: true };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "bunker.status":
        return (async () => {
          const bi = message.payload ?? await getProfileIndex();
          return { connected: isSessionActive(bi) };
        })();
      case "bunker.ping":
        return (async () => {
          try {
            const bi = message.payload ?? await getProfileIndex();
            const session = await getOrCreateSession(bi);
            const result = await session.ping();
            return { success: true, result };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "bunker.validateUrl":
        return Promise.resolve(validateBunkerUrl(message.payload));
      // --- Vault handlers ---
      case "vault.publish":
        return (async () => {
          try {
            const { path, content } = message.payload;
            const pubkey = await getPubKey();
            const encrypted = await nip44Encrypt2({ pubKey: pubkey, plainText: content });
            const unsigned = buildVaultEvent(path, encrypted);
            const pi = await getProfileIndex();
            const profile = await getProfile(pi);
            let signed;
            if (profile.type === "bunker") {
              const session = await getOrCreateSession(pi);
              signed = await session.signEvent(unsigned);
            } else {
              const sk = await getPrivKey();
              signed = finalizeEvent(unsigned, sk);
            }
            await withRelays("write", async (relays) => {
              for (const relay of relays) {
                try {
                  relay.publish(signed);
                } catch (_) {
                }
              }
            });
            return { success: true, eventId: signed.id, createdAt: signed.created_at };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "vault.fetch":
        return (async () => {
          try {
            const pubkey = await getPubKey();
            const filter = buildVaultFilter(pubkey);
            const allEvents = [];
            await withRelays("read", async (relays) => {
              const perRelay = relays.map((relay) => new Promise((resolve) => {
                const subId = `vault-${crypto.randomUUID().slice(0, 8)}`;
                const timeout = setTimeout(() => {
                  try {
                    relay.unsubscribe(subId);
                  } catch (_) {
                  }
                  resolve();
                }, 15e3);
                relay.subscribe(
                  subId,
                  [filter],
                  (event) => {
                    allEvents.push(event);
                  },
                  () => {
                    clearTimeout(timeout);
                    try {
                      relay.unsubscribe(subId);
                    } catch (_) {
                    }
                    resolve();
                  }
                );
              }));
              await Promise.all(perRelay);
            });
            const byDtag = /* @__PURE__ */ new Map();
            for (const event of allEvents) {
              const parsed = parseVaultEvent(event);
              if (!parsed) continue;
              const existing = byDtag.get(parsed.path);
              if (!existing || parsed.createdAt > existing.createdAt) {
                byDtag.set(parsed.path, { event, parsed });
              }
            }
            const documents = [];
            const pubkey_ = await getPubKey();
            for (const { event, parsed } of byDtag.values()) {
              try {
                const decrypted = await nip44Decrypt2({ pubKey: pubkey_, cipherText: event.content });
                documents.push({
                  path: parsed.path,
                  content: decrypted,
                  createdAt: parsed.createdAt,
                  eventId: parsed.eventId
                });
              } catch (_) {
              }
            }
            return { success: true, documents };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "vault.delete":
        return (async () => {
          try {
            const { path, eventId } = message.payload;
            const unsigned = buildVaultDeletion(eventId, path);
            const pi = await getProfileIndex();
            const profile = await getProfile(pi);
            let signed;
            if (profile.type === "bunker") {
              const session = await getOrCreateSession(pi);
              signed = await session.signEvent(unsigned);
            } else {
              const sk = await getPrivKey();
              signed = finalizeEvent(unsigned, sk);
            }
            await withRelays("write", async (relays) => {
              for (const relay of relays) {
                try {
                  relay.publish(signed);
                } catch (_) {
                }
              }
            });
            return { success: true };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "vault.getRelays":
        return (async () => {
          try {
            const profile = await currentProfile();
            const relays = profile.relays || [];
            const read = relays.filter((r) => r.read).map((r) => r.url);
            const write = relays.filter((r) => r.write).map((r) => r.url);
            return { read, write };
          } catch (e) {
            return { read: [], write: [] };
          }
        })();
      // --- API Key Vault handlers ---
      case "apikeys.publish":
        return (async () => {
          try {
            const { keys } = message.payload;
            const pubkey = await getPubKey();
            const plainText = JSON.stringify(keys);
            const encrypted = await nip44Encrypt2({ pubKey: pubkey, plainText });
            const unsigned = buildVaultEvent("vault/api-keys", encrypted);
            const pi = await getProfileIndex();
            const profile = await getProfile(pi);
            let signed;
            if (profile.type === "bunker") {
              const session = await getOrCreateSession(pi);
              signed = await session.signEvent(unsigned);
            } else {
              const sk = await getPrivKey();
              signed = finalizeEvent(unsigned, sk);
            }
            await withRelays("write", async (relays) => {
              for (const relay of relays) {
                try {
                  relay.publish(signed);
                } catch (_) {
                }
              }
            });
            return { success: true, eventId: signed.id, createdAt: signed.created_at };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "apikeys.fetch":
        return (async () => {
          try {
            const pubkey = await getPubKey();
            const filter = {
              kinds: [30078],
              authors: [pubkey],
              "#d": ["nostrkey:vault/api-keys"]
            };
            const allEvents = [];
            await withRelays("read", async (relays) => {
              const perRelay = relays.map((relay) => new Promise((resolve) => {
                const subId = `apikeys-${crypto.randomUUID().slice(0, 8)}`;
                const timeout = setTimeout(() => {
                  try {
                    relay.unsubscribe(subId);
                  } catch (_) {
                  }
                  resolve();
                }, 15e3);
                relay.subscribe(
                  subId,
                  [filter],
                  (event) => {
                    allEvents.push(event);
                  },
                  () => {
                    clearTimeout(timeout);
                    try {
                      relay.unsubscribe(subId);
                    } catch (_) {
                    }
                    resolve();
                  }
                );
              }));
              await Promise.all(perRelay);
            });
            let latest = null;
            for (const event of allEvents) {
              if (!latest || event.created_at > latest.created_at) {
                latest = event;
              }
            }
            if (!latest) {
              return { success: true, keys: null, eventId: null, createdAt: null };
            }
            const decrypted = await nip44Decrypt2({ pubKey: pubkey, cipherText: latest.content });
            const keys = JSON.parse(decrypted);
            return { success: true, keys, eventId: latest.id, createdAt: latest.created_at };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "apikeys.delete":
        return (async () => {
          try {
            const { eventId } = message.payload;
            const unsigned = buildVaultDeletion(eventId, "vault/api-keys");
            const pi = await getProfileIndex();
            const profile = await getProfile(pi);
            let signed;
            if (profile.type === "bunker") {
              const session = await getOrCreateSession(pi);
              signed = await session.signEvent(unsigned);
            } else {
              const sk = await getPrivKey();
              signed = finalizeEvent(unsigned, sk);
            }
            await withRelays("write", async (relays) => {
              for (const relay of relays) {
                try {
                  relay.publish(signed);
                } catch (_) {
                }
              }
            });
            return { success: true };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "apikeys.encrypt":
        return (async () => {
          try {
            const { plainText } = message.payload;
            const pubkey = await getPubKey();
            const cipherText = await nip44Encrypt2({ pubKey: pubkey, plainText });
            return { success: true, cipherText };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      case "apikeys.decrypt":
        return (async () => {
          try {
            const { cipherText } = message.payload;
            const pubkey = await getPubKey();
            const plainText = await nip44Decrypt2({ pubKey: pubkey, cipherText });
            return { success: true, plainText };
          } catch (e) {
            return { success: false, error: e.message };
          }
        })();
      // nostr: protocol URL handler ‚Äî no key access needed, no permission prompt
      case "replaceURL":
        return (async () => {
          const { protocol_handler } = await storage3.get(["protocol_handler"]);
          if (!protocol_handler) return false;
          const { url } = message.payload;
          const raw = url.split("nostr:")[1];
          if (!raw) return false;
          try {
            const { type, data } = nip19_exports.decode(raw);
            const replacements = {
              raw,
              hrp: type,
              hex: type === "npub" || type === "note" ? data : type === "nprofile" ? data.pubkey : type === "nevent" ? data.id : type === "naddr" ? data.pubkey : raw,
              p_or_e: { npub: "p", note: "e", nprofile: "p", nevent: "e", naddr: "a" }[type] || "",
              u_or_n: { npub: "u", note: "n", nprofile: "u", nevent: "n", naddr: "n" }[type] || "",
              relay0: data?.relays?.[0] || "",
              relay1: data?.relays?.[1] || "",
              relay2: data?.relays?.[2] || ""
            };
            let result = protocol_handler;
            for (const [pattern, value] of Object.entries(replacements)) {
              result = result.replace(new RegExp(`\\{ *${pattern} *\\}`, "g"), value);
            }
            return result;
          } catch {
            return false;
          }
        })();
      // window.nostr
      case "getPubKey":
      case "signEvent":
      case "nip04.encrypt":
      case "nip04.decrypt":
      case "nip44.encrypt":
      case "nip44.decrypt":
      case "getRelays":
        validations[uuid] = sendResponse;
        ask(uuid, message);
        setTimeout(() => {
          if (validations[uuid]) {
            deny({ payload: uuid, origKind: message.kind, host: message.host });
          }
          prompt.release?.();
        }, 1e4);
        return true;
      default:
        return Promise.resolve();
    }
  });
  async function forceRelease() {
    if (prompt.tabId !== null) {
      try {
        await api.tabs.get(prompt.tabId);
      } catch (error) {
        prompt.release?.();
        prompt.tabId = null;
      }
    }
  }
  async function generatePrivateKey_() {
    const keyPair = await generateKeyPair();
    return keyPair.privateKey;
  }
  async function ask(uuid, { kind, host, payload }) {
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    const isBunker = profile?.type === "bunker";
    if (!isBunker) {
      const isLocked = await checkLockState();
      if (isLocked) {
        const sendResponse = validations[uuid];
        delete validations[uuid];
        sendResponse?.({ error: "locked", message: "Extension is locked. Please unlock with your master password." });
        return;
      }
    }
    if (isRateLimited(host)) {
      const sendResponse = validations[uuid];
      delete validations[uuid];
      sendResponse?.({ error: "rate_limited", message: "Too many requests. Please wait." });
      log2(`Rate limited: ${host}`);
      return;
    }
    resetAutoLock();
    await forceRelease();
    prompt.release = await prompt.mutex.acquire();
    let mKind = kind === "signEvent" ? `signEvent:${payload.kind}` : kind;
    let permission = await getPermission(host, mKind);
    if (permission === "allow") {
      complete({
        payload: uuid,
        origKind: kind,
        event: payload,
        remember: false,
        host
      });
      prompt.release();
      return;
    }
    if (permission === "deny") {
      deny({ payload: uuid, origKind: kind, host });
      prompt.release();
      return;
    }
    try {
      const [activeTab] = await api.tabs.query({ active: true, currentWindow: true });
      if (activeTab?.id) {
        const result = await api.tabs.sendMessage(activeTab.id, {
          kind: "showPermissionSheet",
          host,
          permissionKind: kind
        });
        if (result) {
          if (result.allowed) {
            complete({
              payload: uuid,
              origKind: kind,
              event: payload,
              remember: result.remember,
              host
            });
          } else {
            deny({
              payload: uuid,
              origKind: kind,
              event: payload,
              remember: result.remember,
              host
            });
          }
          prompt.release();
          return;
        }
      }
    } catch (e) {
      log2("Bottom sheet unavailable, falling back to tab:", e.message);
    }
    let qs = new URLSearchParams({
      uuid,
      kind,
      host,
      payload: JSON.stringify(payload || false)
    });
    let tab = await api.tabs.getCurrent();
    let p = await api.tabs.create({
      url: api.runtime.getURL(`permission/permission.html?${qs.toString()}`),
      openerTabId: tab?.id
    });
    prompt.tabId = p.id;
    return true;
  }
  function complete({ payload, origKind, event, remember, host }) {
    const sendResponse = validations[payload];
    delete validations[payload];
    if (remember) {
      let mKind = origKind === "signEvent" ? `signEvent:${event.kind}` : origKind;
      setPermission(host, mKind, "allow");
    }
    if (sendResponse) {
      const onError = (e) => {
        log2(`Error in ${origKind}: ${e.message}`);
        sendResponse({ error: "bunker_error", message: e.message });
      };
      switch (origKind) {
        case "getPubKey":
          getPubKey().then((pk) => sendResponse(pk)).catch(onError);
          break;
        case "signEvent":
          signEvent_(event, host).then((e) => sendResponse(e)).catch(onError);
          break;
        case "nip04.encrypt":
          nip04Encrypt(event).then((e) => sendResponse(e)).catch(onError);
          break;
        case "nip04.decrypt":
          nip04Decrypt(event).then((e) => sendResponse(e)).catch(onError);
          break;
        case "nip44.encrypt":
          nip44Encrypt2(event).then((e) => sendResponse(e)).catch(onError);
          break;
        case "nip44.decrypt":
          nip44Decrypt2(event).then((e) => sendResponse(e)).catch(onError);
          break;
        case "getRelays":
          getRelays().then((e) => sendResponse(e)).catch(onError);
          break;
      }
    }
  }
  function deny({ origKind, host, payload, remember, event }) {
    const sendResponse = validations[payload];
    delete validations[payload];
    if (remember) {
      let mKind = origKind === "signEvent" ? `signEvent:${event.kind}` : origKind;
      setPermission(host, mKind, "deny");
    }
    sendResponse?.(void 0);
    return false;
  }
  async function savePrivateKey([index, privKey]) {
    const profile = await getProfile(index);
    if (profile?.type === "bunker") {
      throw new Error("Cannot set private key on a bunker profile");
    }
    if (typeof privKey !== "string" || privKey.length === 0) {
      throw new Error("Invalid private key: must be a non-empty string");
    }
    let hexKey;
    if (privKey.startsWith("nsec")) {
      try {
        const decoded = nip19_exports.decode(privKey).data;
        hexKey = bytesToHex(decoded);
      } catch (e) {
        throw new Error("Invalid nsec key");
      }
    } else {
      hexKey = privKey;
    }
    if (!/^[0-9a-f]{64}$/i.test(hexKey)) {
      throw new Error("Invalid private key: must be 64 hex characters or valid nsec");
    }
    let profiles = await get("profiles");
    if (!profiles || index < 0 || index >= profiles.length) {
      throw new Error("Invalid profile index");
    }
    const encrypted = await isEncrypted();
    if (encrypted && sessionPassword) {
      profiles[index].privKey = await encrypt4(hexKey, sessionPassword);
      sessionKeys.set(index, hexKey);
    } else {
      profiles[index].privKey = hexKey;
    }
    await storage3.set({ profiles });
    return true;
  }
  async function getNsec(index) {
    let profile = await getProfile(index);
    if (profile.type === "bunker") return null;
    let hexKey = await getPlaintextPrivKey(index, profile);
    let nsec = nip19_exports.nsecEncode(hexToBytes(hexKey));
    return nsec;
  }
  async function getNpub(index) {
    let profile = await getProfile(index);
    if (!profile) return null;
    if (profile.type === "bunker") {
      if (profile.remotePubkey) return nip19_exports.npubEncode(profile.remotePubkey);
      return null;
    }
    try {
      let hexKey = await getPlaintextPrivKey(index, profile);
      if (!hexKey || typeof hexKey !== "string" || hexKey.length !== 64) {
        return null;
      }
      let pubKey = getPublicKey(hexToBytes(hexKey));
      let npub = nip19_exports.npubEncode(pubKey);
      return npub;
    } catch (e) {
      console.error("getNpub error:", e);
      return null;
    }
  }
  async function getPlaintextPrivKey(index, profile) {
    if (isEncryptedBlob(profile.privKey)) {
      if (sessionKeys.has(index)) {
        return sessionKeys.get(index);
      }
      throw new Error("Extension is locked \u2014 cannot access private key");
    }
    return profile.privKey;
  }
  async function getPrivKey() {
    let index = await getProfileIndex();
    let profile = await currentProfile();
    let hexKey = await getPlaintextPrivKey(index, profile);
    return hexToBytes(hexKey);
  }
  async function getPubKey() {
    let pi = await getProfileIndex();
    let profile = await getProfile(pi);
    if (profile.type === "bunker") {
      if (profile.remotePubkey) return profile.remotePubkey;
      const session = await getOrCreateSession(pi);
      const pubkey = await session.getPublicKey();
      const profiles = await get("profiles");
      profiles[pi].remotePubkey = pubkey;
      await storage3.set({ profiles });
      return pubkey;
    }
    let privKey = await getPrivKey();
    let pubKey = getPublicKey(privKey);
    return pubKey;
  }
  async function currentProfile() {
    let index = await getProfileIndex();
    let profiles = await get("profiles");
    return profiles[index];
  }
  async function signEvent_(event, host) {
    event = JSON.parse(JSON.stringify(event));
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    if (profile.type === "bunker") {
      const session = await getOrCreateSession(pi);
      event = await session.signEvent(event);
    } else {
      let sk = await getPrivKey();
      event = finalizeEvent(event, sk);
    }
    saveEvent({
      event,
      metadata: { host, signed_at: Math.round(Date.now() / 1e3) }
    });
    return event;
  }
  async function nip04Encrypt({ pubKey, plainText }) {
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    if (profile.type === "bunker") {
      const session = await getOrCreateSession(pi);
      return session.nip04Encrypt(pubKey, plainText);
    }
    let privKey = await getPrivKey();
    return nip04_exports.encrypt(privKey, pubKey, plainText);
  }
  async function nip04Decrypt({ pubKey, cipherText }) {
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    if (profile.type === "bunker") {
      const session = await getOrCreateSession(pi);
      return session.nip04Decrypt(pubKey, cipherText);
    }
    let privKey = await getPrivKey();
    return nip04_exports.decrypt(privKey, pubKey, cipherText);
  }
  async function nip44Encrypt2({ pubKey, plainText }) {
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    if (profile.type === "bunker") {
      const session = await getOrCreateSession(pi);
      return session.nip44Encrypt(pubKey, plainText);
    }
    let privKey = await getPrivKey();
    let conversationKey = nip44_exports.v2.utils.getConversationKey(privKey, pubKey);
    return nip44_exports.v2.encrypt(plainText, conversationKey);
  }
  async function nip44Decrypt2({ pubKey, cipherText }) {
    const pi = await getProfileIndex();
    const profile = await getProfile(pi);
    if (profile.type === "bunker") {
      const session = await getOrCreateSession(pi);
      return session.nip44Decrypt(pubKey, cipherText);
    }
    let privKey = await getPrivKey();
    let conversationKey = nip44_exports.v2.utils.getConversationKey(privKey, pubKey);
    return nip44_exports.v2.decrypt(cipherText, conversationKey);
  }
  async function getRelays() {
    let profile = await currentProfile();
    let relays = profile.relays;
    let relayObj = {};
    relays.forEach((relay) => {
      let { url, read, write } = relay;
      relayObj[url] = { read, write };
    });
    return relayObj;
  }
  async function withRelays(mode, callback) {
    const profile = await currentProfile();
    const relayList = profile.relays || [];
    const urls = relayList.filter((r) => mode === "read" ? r.read : r.write).map((r) => r.url);
    if (urls.length === 0) {
      throw new Error("No relays configured");
    }
    const connections = [];
    const connectPromises = urls.map(async (url) => {
      const relay = new RelayConnection(url);
      try {
        await relay.connect();
        connections.push(relay);
      } catch (_) {
      }
    });
    await Promise.allSettled(connectPromises);
    if (connections.length === 0) {
      throw new Error("Failed to connect to any relay");
    }
    try {
      await callback(connections);
    } finally {
      for (const relay of connections) {
        relay.close();
      }
    }
  }

  // src/background-sw.js
  if (typeof chrome !== "undefined" && chrome.sidePanel) {
    chrome.action.onClicked.addListener(async (tab) => {
      try {
        await chrome.sidePanel.open({ tabId: tab.id });
      } catch (e) {
        console.error("Failed to open side panel:", e);
      }
    });
    chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true }).catch(() => {
    });
  }
})();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3V0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy9fbWQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3NoYTIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL3V0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9hYnN0cmFjdC9tb2R1bGFyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9hYnN0cmFjdC9jdXJ2ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvaG1hYy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zcmMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL3NlY3AyNTZrMS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy91dGlscy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvc3JjL2Flcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvc3JjL19hcngudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy9fcG9seTEzMDUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy9jaGFjaGEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2hrZGYudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3Bia2RmMi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvc2NyeXB0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL25pcDQ5LmpzIiwgIi4uLy4uL3NyYy91dGlsaXRpZXMva2V5cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvaW5kZXgubWpzIiwgIi4uLy4uL3NyYy91dGlsaXRpZXMvYnJvd3Nlci1wb2x5ZmlsbC5qcyIsICIuLi8uLi9zcmMvdXRpbGl0aWVzL2NyeXB0by5qcyIsICIuLi8uLi9zcmMvdXRpbGl0aWVzL3V0aWxzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCAiLi4vLi4vc3JjL3V0aWxpdGllcy9kYi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9uaXA0NC5qcyIsICIuLi8uLi9zcmMvdXRpbGl0aWVzL25pcDQ2LmpzIiwgIi4uLy4uL3NyYy91dGlsaXRpZXMvbmlwNzguanMiLCAiLi4vLi4vc3JjL2JhY2tncm91bmQuanMiLCAiLi4vLi4vc3JjL2JhY2tncm91bmQtc3cuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGE6IHVua25vd24pOiBhIGlzIFVpbnQ4QXJyYXkge1xuICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG5cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBwb3NpdGl2ZSBpbnRlZ2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFudW1iZXIobjogbnVtYmVyLCB0aXRsZTogc3RyaW5nID0gJycpOiB2b2lkIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cHJlZml4fWV4cGVjdGVkIGludGVnZXIgPj0gMCwgZ290ICR7bn1gKTtcbiAgfVxufVxuXG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXModmFsdWU6IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlciwgdGl0bGU6IHN0cmluZyA9ICcnKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJ5dGVzID0gaXNCeXRlcyh2YWx1ZSk7XG4gIGNvbnN0IGxlbiA9IHZhbHVlPy5sZW5ndGg7XG4gIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gIGlmICghYnl0ZXMgfHwgKG5lZWRzTGVuICYmIGxlbiAhPT0gbGVuZ3RoKSkge1xuICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICBjb25zdCBvZkxlbiA9IG5lZWRzTGVuID8gYCBvZiBsZW5ndGggJHtsZW5ndGh9YCA6ICcnO1xuICAgIGNvbnN0IGdvdCA9IGJ5dGVzID8gYGxlbmd0aD0ke2xlbn1gIDogYHR5cGU9JHt0eXBlb2YgdmFsdWV9YDtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFoYXNoKGg6IENIYXNoKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIG11c3Qgd3JhcHBlZCBieSB1dGlscy5jcmVhdGVIYXNoZXInKTtcbiAgYW51bWJlcihoLm91dHB1dExlbik7XG4gIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG5cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlOiBhbnksIGNoZWNrRmluaXNoZWQgPSB0cnVlKTogdm9pZCB7XG4gIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuXG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0OiBhbnksIGluc3RhbmNlOiBhbnkpOiB2b2lkIHtcbiAgYWJ5dGVzKG91dCwgdW5kZWZpbmVkLCAnZGlnZXN0SW50bygpIG91dHB1dCcpO1xuICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImRpZ2VzdEludG8oKSBvdXRwdXRcIiBleHBlY3RlZCB0byBiZSBvZiBsZW5ndGggPj0nICsgbWluKTtcbiAgfVxufVxuXG4vKiogR2VuZXJpYyB0eXBlIGVuY29tcGFzc2luZyA4LzE2LzMyLWJ5dGUgYXJyYXlzIC0gYnV0IG5vdCA2NC1ieXRlLiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhDbGFtcGVkQXJyYXkgfCBVaW50OEFycmF5IHxcbiAgVWludDE2QXJyYXkgfCBJbnQxNkFycmF5IHwgVWludDMyQXJyYXkgfCBJbnQzMkFycmF5O1xuXG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnI6IFR5cGVkQXJyYXkpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyOiBUeXBlZEFycmF5KTogVWludDMyQXJyYXkge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuXG4vKiogWmVyb2l6ZSBhIGJ5dGUgYXJyYXkuIFdhcm5pbmc6IEpTIHByb3ZpZGVzIG5vIGd1YXJhbnRlZXMuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzOiBUeXBlZEFycmF5W10pOiB2b2lkIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgfVxufVxuXG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyOiBUeXBlZEFycmF5KTogRGF0YVZpZXcge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKiBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RyKHdvcmQ6IG51bWJlciwgc2hpZnQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cblxuLyoqIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RsKHdvcmQ6IG51bWJlciwgc2hpZnQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuXG4vKiogSXMgY3VycmVudCBwbGF0Zm9ybSBsaXR0bGUtZW5kaWFuPyBNb3N0IGFyZS4gQmlnLUVuZGlhbiBwbGF0Zm9ybTogSUJNICovXG5leHBvcnQgY29uc3QgaXNMRTogYm9vbGVhbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NCkoKTtcblxuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKFxuICAgICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKVxuICApO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRTogKG46IG51bWJlcikgPT4gbnVtYmVyID0gaXNMRVxuICA/IChuOiBudW1iZXIpID0+IG5cbiAgOiAobjogbnVtYmVyKSA9PiBieXRlU3dhcChuKTtcblxuLyoqIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcDMyKGFycjogVWludDMyQXJyYXkpOiBVaW50MzJBcnJheSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgY29uc3Qgc3dhcDMySWZCRTogKHU6IFVpbnQzMkFycmF5KSA9PiBVaW50MzJBcnJheSA9IGlzTEVcbiAgPyAodTogVWludDMyQXJyYXkpID0+IHVcbiAgOiBieXRlU3dhcDMyO1xuXG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbjogYm9vbGVhbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuXG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PlxuICBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpXG4pO1xuXG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBhYnl0ZXMoYnl0ZXMpO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChoYXNIZXhCdWlsdGluKSByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gIGxldCBoZXggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cblxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9IGFzIGNvbnN0O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaDogbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRikgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGhhc0hleEJ1aWx0aW4pIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgaWYgKGhsICUgMikgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICB9XG4gICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7fTtcblxuLyoqIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmcuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKFxuICBpdGVyczogbnVtYmVyLFxuICB0aWNrOiBudW1iZXIsXG4gIGNiOiAoaTogbnVtYmVyKSA9PiB2b2lkXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgY2IoaSk7XG4gICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spIGNvbnRpbnVlO1xuICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgdHMgKz0gZGlmZjtcbiAgfVxufVxuXG4vLyBHbG9iYWwgc3ltYm9scywgYnV0IHRzIGRvZXNuJ3Qgc2VlIHRoZW06IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE1MzVcbmRlY2xhcmUgY29uc3QgVGV4dEVuY29kZXI6IGFueTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gYnl0ZXMgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEJ1aWx0LWluIGRvZXNuJ3QgdmFsaWRhdGUgaW5wdXQgdG8gYmUgc3RyaW5nOiB3ZSBkbyB0aGUgY2hlY2suXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuXG4vKiogS0RGcyBjYW4gYWNjZXB0IHN0cmluZyBvciBVaW50OEFycmF5IGZvciB1c2VyIGNvbnZlbmllbmNlLiAqL1xuZXhwb3J0IHR5cGUgS0RGSW5wdXQgPSBzdHJpbmcgfCBVaW50OEFycmF5O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgS0RGczogY29uc3VtZXMgdWludDhhcnJheSBvciBzdHJpbmcuXG4gKiBXaGVuIHN0cmluZyBpcyBwYXNzZWQsIGRvZXMgdXRmOCBkZWNvZGluZywgdXNpbmcgVGV4dERlY29kZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZGZJbnB1dFRvQnl0ZXMoZGF0YTogS0RGSW5wdXQsIGVycm9yVGl0bGUgPSAnJyk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSByZXR1cm4gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gIHJldHVybiBhYnl0ZXMoZGF0YSwgdW5kZWZpbmVkLCBlcnJvclRpdGxlKTtcbn1cblxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5czogVWludDhBcnJheVtdKTogVWludDhBcnJheSB7XG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgYWJ5dGVzKGEpO1xuICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgfVxuICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgcmVzLnNldChhLCBwYWQpO1xuICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG50eXBlIEVtcHR5T2JqID0ge307XG4vKiogTWVyZ2VzIGRlZmF1bHQgb3B0aW9ucyBhbmQgcGFzc2VkIG9wdGlvbnMuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzPFQxIGV4dGVuZHMgRW1wdHlPYmosIFQyIGV4dGVuZHMgRW1wdHlPYmo+KFxuICBkZWZhdWx0czogVDEsXG4gIG9wdHM/OiBUMlxuKTogVDEgJiBUMiB7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgcmV0dXJuIG1lcmdlZCBhcyBUMSAmIFQyO1xufVxuXG4vKiogQ29tbW9uIGludGVyZmFjZSBmb3IgYWxsIGhhc2hlcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaDxUPiB7XG4gIGJsb2NrTGVuOiBudW1iZXI7IC8vIEJ5dGVzIHBlciBibG9ja1xuICBvdXRwdXRMZW46IG51bWJlcjsgLy8gQnl0ZXMgaW4gb3V0cHV0XG4gIHVwZGF0ZShidWY6IFVpbnQ4QXJyYXkpOiB0aGlzO1xuICBkaWdlc3RJbnRvKGJ1ZjogVWludDhBcnJheSk6IHZvaWQ7XG4gIGRpZ2VzdCgpOiBVaW50OEFycmF5O1xuICBkZXN0cm95KCk6IHZvaWQ7XG4gIF9jbG9uZUludG8odG8/OiBUKTogVDtcbiAgY2xvbmUoKTogVDtcbn1cblxuLyoqIFBzZXVkb1JhbmRvbSAobnVtYmVyKSBHZW5lcmF0b3IgKi9cbmV4cG9ydCBpbnRlcmZhY2UgUFJHIHtcbiAgYWRkRW50cm9weShzZWVkOiBVaW50OEFycmF5KTogdm9pZDtcbiAgcmFuZG9tQnl0ZXMobGVuZ3RoOiBudW1iZXIpOiBVaW50OEFycmF5O1xuICBjbGVhbigpOiB2b2lkO1xufVxuXG4vKipcbiAqIFhPRjogc3RyZWFtaW5nIEFQSSB0byByZWFkIGRpZ2VzdCBpbiBjaHVua3MuXG4gKiBTYW1lIGFzICdzcXVlZXplJyBpbiBrZWNjYWsvazEyIGFuZCAnc2VlaycgaW4gYmxha2UzLCBidXQgbW9yZSBnZW5lcmljIG5hbWUuXG4gKiBXaGVuIGhhc2ggdXNlZCBpbiBYT0YgbW9kZSBpdCBpcyB1cCB0byB1c2VyIHRvIGNhbGwgJy5kZXN0cm95JyBhZnRlcndhcmRzLCBzaW5jZSB3ZSBjYW5ub3RcbiAqIGRlc3Ryb3kgc3RhdGUsIG5leHQgY2FsbCBjYW4gcmVxdWlyZSBtb3JlIGJ5dGVzLlxuICovXG5leHBvcnQgdHlwZSBIYXNoWE9GPFQgZXh0ZW5kcyBIYXNoPFQ+PiA9IEhhc2g8VD4gJiB7XG4gIHhvZihieXRlczogbnVtYmVyKTogVWludDhBcnJheTsgLy8gUmVhZCAnYnl0ZXMnIGJ5dGVzIGZyb20gZGlnZXN0IHN0cmVhbVxuICB4b2ZJbnRvKGJ1ZjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7IC8vIHJlYWQgYnVmLmxlbmd0aCBieXRlcyBmcm9tIGRpZ2VzdCBzdHJlYW0gaW50byBidWZcbn07XG5cbi8qKiBIYXNoIGNvbnN0cnVjdG9yICovXG5leHBvcnQgdHlwZSBIYXNoZXJDb25zPFQsIE9wdHMgPSB1bmRlZmluZWQ+ID0gT3B0cyBleHRlbmRzIHVuZGVmaW5lZCA/ICgpID0+IFQgOiAob3B0cz86IE9wdHMpID0+IFQ7XG4vKiogT3B0aW9uYWwgaGFzaCBwYXJhbXMuICovXG5leHBvcnQgdHlwZSBIYXNoSW5mbyA9IHtcbiAgb2lkPzogVWludDhBcnJheTsgLy8gREVSIGVuY29kZWQgT0lEIGluIGJ5dGVzXG59O1xuLyoqIEhhc2ggZnVuY3Rpb24gKi9cbmV4cG9ydCB0eXBlIENIYXNoPFQgZXh0ZW5kcyBIYXNoPFQ+ID0gSGFzaDxhbnk+LCBPcHRzID0gdW5kZWZpbmVkPiA9IHtcbiAgb3V0cHV0TGVuOiBudW1iZXI7XG4gIGJsb2NrTGVuOiBudW1iZXI7XG59ICYgSGFzaEluZm8gJlxuICAoT3B0cyBleHRlbmRzIHVuZGVmaW5lZFxuICAgID8ge1xuICAgICAgICAobXNnOiBVaW50OEFycmF5KTogVWludDhBcnJheTtcbiAgICAgICAgY3JlYXRlKCk6IFQ7XG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIChtc2c6IFVpbnQ4QXJyYXksIG9wdHM/OiBPcHRzKTogVWludDhBcnJheTtcbiAgICAgICAgY3JlYXRlKG9wdHM/OiBPcHRzKTogVDtcbiAgICAgIH0pO1xuLyoqIFhPRiB3aXRoIG91dHB1dCAqL1xuZXhwb3J0IHR5cGUgQ0hhc2hYT0Y8VCBleHRlbmRzIEhhc2hYT0Y8VD4gPSBIYXNoWE9GPGFueT4sIE9wdHMgPSB1bmRlZmluZWQ+ID0gQ0hhc2g8VCwgT3B0cz47XG5cbi8qKiBDcmVhdGVzIGZ1bmN0aW9uIHdpdGggb3V0cHV0TGVuLCBibG9ja0xlbiwgY3JlYXRlIHByb3BlcnRpZXMgZnJvbSBhIGNsYXNzIGNvbnN0cnVjdG9yLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcjxUIGV4dGVuZHMgSGFzaDxUPiwgT3B0cyA9IHVuZGVmaW5lZD4oXG4gIGhhc2hDb25zOiBIYXNoZXJDb25zPFQsIE9wdHM+LFxuICBpbmZvOiBIYXNoSW5mbyA9IHt9XG4pOiBDSGFzaDxULCBPcHRzPiB7XG4gIGNvbnN0IGhhc2hDOiBhbnkgPSAobXNnOiBVaW50OEFycmF5LCBvcHRzPzogT3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKG1zZykuZGlnZXN0KCk7XG4gIGNvbnN0IHRtcCA9IGhhc2hDb25zKHVuZGVmaW5lZCk7XG4gIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICBoYXNoQy5jcmVhdGUgPSAob3B0cz86IE9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICBPYmplY3QuYXNzaWduKGhhc2hDLCBpbmZvKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoaGFzaEMpO1xufVxuXG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgY3IgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyAoZ2xvYmFsVGhpcyBhcyBhbnkpLmNyeXB0byA6IG51bGw7XG4gIGlmICh0eXBlb2YgY3I/LmdldFJhbmRvbVZhbHVlcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIHJldHVybiBjci5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbn1cblxuLyoqIENyZWF0ZXMgT0lEIG9wdHMgZm9yIE5JU1QgaGFzaGVzLCB3aXRoIHByZWZpeCAwNiAwOSA2MCA4NiA0OCAwMSA2NSAwMyAwNCAwMi4gKi9cbmV4cG9ydCBjb25zdCBvaWROaXN0ID0gKHN1ZmZpeDogbnVtYmVyKTogUmVxdWlyZWQ8SGFzaEluZm8+ID0+ICh7XG4gIG9pZDogVWludDhBcnJheS5mcm9tKFsweDA2LCAweDA5LCAweDYwLCAweDg2LCAweDQ4LCAweDAxLCAweDY1LCAweDAzLCAweDA0LCAweDAyLCBzdWZmaXhdKSxcbn0pO1xuIiwgIi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlVmlldywgdHlwZSBIYXNoIH0gZnJvbSAnLi91dGlscy50cyc7XG5cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhOiBudW1iZXIsIGI6IG51bWJlciwgYzogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cblxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gTWFqKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xufVxuXG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhc2hNRDxUIGV4dGVuZHMgSGFzaE1EPFQ+PiBpbXBsZW1lbnRzIEhhc2g8VD4ge1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcHJvY2VzcyhidWY6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXQoKTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzZXQoLi4uYXJnczogbnVtYmVyW10pOiB2b2lkO1xuICBhYnN0cmFjdCBkZXN0cm95KCk6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByb3VuZENsZWFuKCk6IHZvaWQ7XG5cbiAgcmVhZG9ubHkgYmxvY2tMZW46IG51bWJlcjtcbiAgcmVhZG9ubHkgb3V0cHV0TGVuOiBudW1iZXI7XG4gIHJlYWRvbmx5IHBhZE9mZnNldDogbnVtYmVyO1xuICByZWFkb25seSBpc0xFOiBib29sZWFuO1xuXG4gIC8vIEZvciBwYXJ0aWFsIHVwZGF0ZXMgbGVzcyB0aGFuIGJsb2NrIHNpemVcbiAgcHJvdGVjdGVkIGJ1ZmZlcjogVWludDhBcnJheTtcbiAgcHJvdGVjdGVkIHZpZXc6IERhdGFWaWV3O1xuICBwcm90ZWN0ZWQgZmluaXNoZWQgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIGxlbmd0aCA9IDA7XG4gIHByb3RlY3RlZCBwb3MgPSAwO1xuICBwcm90ZWN0ZWQgZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoYmxvY2tMZW46IG51bWJlciwgb3V0cHV0TGVuOiBudW1iZXIsIHBhZE9mZnNldDogbnVtYmVyLCBpc0xFOiBib29sZWFuKSB7XG4gICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlKGRhdGE6IFVpbnQ4QXJyYXkpOiB0aGlzIHtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyApIHtcbiAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhvdXQ6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAvLyBQYWRkaW5nXG4gICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgcG9zID0gMDtcbiAgICB9XG4gICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspIGJ1ZmZlcltpXSA9IDA7XG4gICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgIHZpZXcuc2V0QmlnVWludDY0KGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBtdXN0IGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICBpZiAobGVuICUgNCkgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIG11c3QgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICB9XG4gIGRpZ2VzdCgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgX2Nsb25lSW50byh0bz86IFQpOiBUIHtcbiAgICB0byB8fD0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSkoKSBhcyBUO1xuICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0by5wb3MgPSBwb3M7XG4gICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKSB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIHRvIGFzIHVua25vd24gYXMgYW55O1xuICB9XG4gIGNsb25lKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWwgU0hBLTIgc3RhdGU6IGZyYWN0aW9uYWwgcGFydHMgb2Ygc3F1YXJlIHJvb3RzIG9mIGZpcnN0IDE2IHByaW1lcyAyLi41My5cbiAqIENoZWNrIG91dCBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYCBmb3IgcmVjb21wdXRhdGlvbiBndWlkZS5cbiAqL1xuXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBMjU2X0lWOiBVaW50MzJBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuXG4vKiogSW5pdGlhbCBTSEEyMjQgc3RhdGUuIEJpdHMgMzIuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjRfSVY6IFVpbnQzMkFycmF5ID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG5cbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMzg0X0lWOiBVaW50MzJBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCwgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNywgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNywgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuXG4vKiogSW5pdGlhbCBTSEE1MTIgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBNTEyX0lWOiBVaW50MzJBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSxcbl0pO1xuIiwgIi8qKlxuICogU0hBMiBoYXNoIGZ1bmN0aW9uLiBBLmsuYS4gc2hhMjU2LCBzaGEzODQsIHNoYTUxMiwgc2hhNTEyXzIyNCwgc2hhNTEyXzI1Ni5cbiAqIFNIQTI1NiBpcyB0aGUgZmFzdGVzdCBoYXNoIGltcGxlbWVudGFibGUgaW4gSlMsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogQ2hlY2sgb3V0IFtSRkMgNDYzNF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqLCBTSEEyMjRfSVYsIFNIQTI1Nl9JViwgU0hBMzg0X0lWLCBTSEE1MTJfSVYgfSBmcm9tICcuL19tZC50cyc7XG5pbXBvcnQgKiBhcyB1NjQgZnJvbSAnLi9fdTY0LnRzJztcbmltcG9ydCB7IHR5cGUgQ0hhc2gsIGNsZWFuLCBjcmVhdGVIYXNoZXIsIG9pZE5pc3QsIHJvdHIgfSBmcm9tICcuL3V0aWxzLnRzJztcblxuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuXG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcblxuLyoqIEludGVybmFsIDMyLWJ5dGUgYmFzZSBTSEEyIGhhc2ggY2xhc3MuICovXG5hYnN0cmFjdCBjbGFzcyBTSEEyXzMyQjxUIGV4dGVuZHMgU0hBMl8zMkI8VD4+IGV4dGVuZHMgSGFzaE1EPFQ+IHtcbiAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBBOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBCOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBDOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBEOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBFOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBGOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBHOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBIOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3V0cHV0TGVuOiBudW1iZXIpIHtcbiAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gIH1cbiAgcHJvdGVjdGVkIGdldCgpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgcHJvdGVjdGVkIHNldChcbiAgICBBOiBudW1iZXIsIEI6IG51bWJlciwgQzogbnVtYmVyLCBEOiBudW1iZXIsIEU6IG51bWJlciwgRjogbnVtYmVyLCBHOiBudW1iZXIsIEg6IG51bWJlclxuICApOiB2b2lkIHtcbiAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICB0aGlzLkggPSBIIHwgMDtcbiAgfVxuICBwcm90ZWN0ZWQgcHJvY2Vzcyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICBIID0gRztcbiAgICAgIEcgPSBGO1xuICAgICAgRiA9IEU7XG4gICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgRCA9IEM7XG4gICAgICBDID0gQjtcbiAgICAgIEIgPSBBO1xuICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gIH1cbiAgcHJvdGVjdGVkIHJvdW5kQ2xlYW4oKTogdm9pZCB7XG4gICAgY2xlYW4oU0hBMjU2X1cpO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICB9XG59XG5cbi8qKiBJbnRlcm5hbCBTSEEyLTI1NiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEEyNTYgZXh0ZW5kcyBTSEEyXzMyQjxfU0hBMjU2PiB7XG4gIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICBwcm90ZWN0ZWQgQTogbnVtYmVyID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgcHJvdGVjdGVkIEI6IG51bWJlciA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBDOiBudW1iZXIgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICBwcm90ZWN0ZWQgRDogbnVtYmVyID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgcHJvdGVjdGVkIEU6IG51bWJlciA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBGOiBudW1iZXIgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICBwcm90ZWN0ZWQgRzogbnVtYmVyID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgcHJvdGVjdGVkIEg6IG51bWJlciA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDMyKTtcbiAgfVxufVxuXG4vKiogSW50ZXJuYWwgU0hBMi0yMjQgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBMjI0IGV4dGVuZHMgU0hBMl8zMkI8X1NIQTIyND4ge1xuICBwcm90ZWN0ZWQgQTogbnVtYmVyID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgcHJvdGVjdGVkIEI6IG51bWJlciA9IFNIQTIyNF9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBDOiBudW1iZXIgPSBTSEEyMjRfSVZbMl0gfCAwO1xuICBwcm90ZWN0ZWQgRDogbnVtYmVyID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgcHJvdGVjdGVkIEU6IG51bWJlciA9IFNIQTIyNF9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBGOiBudW1iZXIgPSBTSEEyMjRfSVZbNV0gfCAwO1xuICBwcm90ZWN0ZWQgRzogbnVtYmVyID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgcHJvdGVjdGVkIEg6IG51bWJlciA9IFNIQTIyNF9JVls3XSB8IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDI4KTtcbiAgfVxufVxuXG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cblxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuY29uc3QgU0hBNTEyX0toID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzBdKSgpO1xuY29uc3QgU0hBNTEyX0tsID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzFdKSgpO1xuXG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuXG4vKiogSW50ZXJuYWwgNjQtYnl0ZSBiYXNlIFNIQTIgaGFzaCBjbGFzcy4gKi9cbmFic3RyYWN0IGNsYXNzIFNIQTJfNjRCPFQgZXh0ZW5kcyBTSEEyXzY0QjxUPj4gZXh0ZW5kcyBIYXNoTUQ8VD4ge1xuICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEFoOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBBbDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgQmg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEJsOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBDaDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgQ2w6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IERoOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBEbDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgRWg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEVsOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBGaDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgRmw6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEdoOiBudW1iZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBHbDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgSGg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IEhsOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3V0cHV0TGVuOiBudW1iZXIpIHtcbiAgICBzdXBlcigxMjgsIG91dHB1dExlbiwgMTYsIGZhbHNlKTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgcHJvdGVjdGVkIGdldCgpOiBbXG4gICAgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsXG4gICAgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJcbiAgXSB7XG4gICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgcHJvdGVjdGVkIHNldChcbiAgICBBaDogbnVtYmVyLCBBbDogbnVtYmVyLCBCaDogbnVtYmVyLCBCbDogbnVtYmVyLCBDaDogbnVtYmVyLCBDbDogbnVtYmVyLCBEaDogbnVtYmVyLCBEbDogbnVtYmVyLFxuICAgIEVoOiBudW1iZXIsIEVsOiBudW1iZXIsIEZoOiBudW1iZXIsIEZsOiBudW1iZXIsIEdoOiBudW1iZXIsIEdsOiBudW1iZXIsIEhoOiBudW1iZXIsIEhsOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgfVxuICBwcm90ZWN0ZWQgcHJvY2Vzcyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgSGggPSBHaCB8IDA7XG4gICAgICBIbCA9IEdsIHwgMDtcbiAgICAgIEdoID0gRmggfCAwO1xuICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICBGaCA9IEVoIHwgMDtcbiAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICBEaCA9IENoIHwgMDtcbiAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICBDbCA9IEJsIHwgMDtcbiAgICAgIEJoID0gQWggfCAwO1xuICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgIEFsID0gQWxsIHwgMDtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICB9XG4gIHByb3RlY3RlZCByb3VuZENsZWFuKCk6IHZvaWQge1xuICAgIGNsZWFuKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICB9XG59XG5cbi8qKiBJbnRlcm5hbCBTSEEyLTUxMiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEE1MTIgZXh0ZW5kcyBTSEEyXzY0QjxfU0hBNTEyPiB7XG4gIHByb3RlY3RlZCBBaDogbnVtYmVyID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgcHJvdGVjdGVkIEFsOiBudW1iZXIgPSBTSEE1MTJfSVZbMV0gfCAwO1xuICBwcm90ZWN0ZWQgQmg6IG51bWJlciA9IFNIQTUxMl9JVlsyXSB8IDA7XG4gIHByb3RlY3RlZCBCbDogbnVtYmVyID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgcHJvdGVjdGVkIENoOiBudW1iZXIgPSBTSEE1MTJfSVZbNF0gfCAwO1xuICBwcm90ZWN0ZWQgQ2w6IG51bWJlciA9IFNIQTUxMl9JVls1XSB8IDA7XG4gIHByb3RlY3RlZCBEaDogbnVtYmVyID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgcHJvdGVjdGVkIERsOiBudW1iZXIgPSBTSEE1MTJfSVZbN10gfCAwO1xuICBwcm90ZWN0ZWQgRWg6IG51bWJlciA9IFNIQTUxMl9JVls4XSB8IDA7XG4gIHByb3RlY3RlZCBFbDogbnVtYmVyID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgcHJvdGVjdGVkIEZoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTBdIHwgMDtcbiAgcHJvdGVjdGVkIEZsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTFdIHwgMDtcbiAgcHJvdGVjdGVkIEdoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgcHJvdGVjdGVkIEdsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTNdIHwgMDtcbiAgcHJvdGVjdGVkIEhoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTRdIHwgMDtcbiAgcHJvdGVjdGVkIEhsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTVdIHwgMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcig2NCk7XG4gIH1cbn1cblxuLyoqIEludGVybmFsIFNIQTItMzg0IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTM4NCBleHRlbmRzIFNIQTJfNjRCPF9TSEEzODQ+IHtcbiAgcHJvdGVjdGVkIEFoOiBudW1iZXIgPSBTSEEzODRfSVZbMF0gfCAwO1xuICBwcm90ZWN0ZWQgQWw6IG51bWJlciA9IFNIQTM4NF9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBCaDogbnVtYmVyID0gU0hBMzg0X0lWWzJdIHwgMDtcbiAgcHJvdGVjdGVkIEJsOiBudW1iZXIgPSBTSEEzODRfSVZbM10gfCAwO1xuICBwcm90ZWN0ZWQgQ2g6IG51bWJlciA9IFNIQTM4NF9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBDbDogbnVtYmVyID0gU0hBMzg0X0lWWzVdIHwgMDtcbiAgcHJvdGVjdGVkIERoOiBudW1iZXIgPSBTSEEzODRfSVZbNl0gfCAwO1xuICBwcm90ZWN0ZWQgRGw6IG51bWJlciA9IFNIQTM4NF9JVls3XSB8IDA7XG4gIHByb3RlY3RlZCBFaDogbnVtYmVyID0gU0hBMzg0X0lWWzhdIHwgMDtcbiAgcHJvdGVjdGVkIEVsOiBudW1iZXIgPSBTSEEzODRfSVZbOV0gfCAwO1xuICBwcm90ZWN0ZWQgRmg6IG51bWJlciA9IFNIQTM4NF9JVlsxMF0gfCAwO1xuICBwcm90ZWN0ZWQgRmw6IG51bWJlciA9IFNIQTM4NF9JVlsxMV0gfCAwO1xuICBwcm90ZWN0ZWQgR2g6IG51bWJlciA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICBwcm90ZWN0ZWQgR2w6IG51bWJlciA9IFNIQTM4NF9JVlsxM10gfCAwO1xuICBwcm90ZWN0ZWQgSGg6IG51bWJlciA9IFNIQTM4NF9JVlsxNF0gfCAwO1xuICBwcm90ZWN0ZWQgSGw6IG51bWJlciA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDQ4KTtcbiAgfVxufVxuXG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG5cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG5cbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5cbi8qKiBJbnRlcm5hbCBTSEEyLTUxMi8yMjQgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyXzIyNCBleHRlbmRzIFNIQTJfNjRCPF9TSEE1MTJfMjI0PiB7XG4gIHByb3RlY3RlZCBBaDogbnVtYmVyID0gVDIyNF9JVlswXSB8IDA7XG4gIHByb3RlY3RlZCBBbDogbnVtYmVyID0gVDIyNF9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBCaDogbnVtYmVyID0gVDIyNF9JVlsyXSB8IDA7XG4gIHByb3RlY3RlZCBCbDogbnVtYmVyID0gVDIyNF9JVlszXSB8IDA7XG4gIHByb3RlY3RlZCBDaDogbnVtYmVyID0gVDIyNF9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBDbDogbnVtYmVyID0gVDIyNF9JVls1XSB8IDA7XG4gIHByb3RlY3RlZCBEaDogbnVtYmVyID0gVDIyNF9JVls2XSB8IDA7XG4gIHByb3RlY3RlZCBEbDogbnVtYmVyID0gVDIyNF9JVls3XSB8IDA7XG4gIHByb3RlY3RlZCBFaDogbnVtYmVyID0gVDIyNF9JVls4XSB8IDA7XG4gIHByb3RlY3RlZCBFbDogbnVtYmVyID0gVDIyNF9JVls5XSB8IDA7XG4gIHByb3RlY3RlZCBGaDogbnVtYmVyID0gVDIyNF9JVlsxMF0gfCAwO1xuICBwcm90ZWN0ZWQgRmw6IG51bWJlciA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgcHJvdGVjdGVkIEdoOiBudW1iZXIgPSBUMjI0X0lWWzEyXSB8IDA7XG4gIHByb3RlY3RlZCBHbDogbnVtYmVyID0gVDIyNF9JVlsxM10gfCAwO1xuICBwcm90ZWN0ZWQgSGg6IG51bWJlciA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgcHJvdGVjdGVkIEhsOiBudW1iZXIgPSBUMjI0X0lWWzE1XSB8IDA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoMjgpO1xuICB9XG59XG5cbi8qKiBJbnRlcm5hbCBTSEEyLTUxMi8yNTYgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyXzI1NiBleHRlbmRzIFNIQTJfNjRCPF9TSEE1MTJfMjU2PiB7XG4gIHByb3RlY3RlZCBBaDogbnVtYmVyID0gVDI1Nl9JVlswXSB8IDA7XG4gIHByb3RlY3RlZCBBbDogbnVtYmVyID0gVDI1Nl9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBCaDogbnVtYmVyID0gVDI1Nl9JVlsyXSB8IDA7XG4gIHByb3RlY3RlZCBCbDogbnVtYmVyID0gVDI1Nl9JVlszXSB8IDA7XG4gIHByb3RlY3RlZCBDaDogbnVtYmVyID0gVDI1Nl9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBDbDogbnVtYmVyID0gVDI1Nl9JVls1XSB8IDA7XG4gIHByb3RlY3RlZCBEaDogbnVtYmVyID0gVDI1Nl9JVls2XSB8IDA7XG4gIHByb3RlY3RlZCBEbDogbnVtYmVyID0gVDI1Nl9JVls3XSB8IDA7XG4gIHByb3RlY3RlZCBFaDogbnVtYmVyID0gVDI1Nl9JVls4XSB8IDA7XG4gIHByb3RlY3RlZCBFbDogbnVtYmVyID0gVDI1Nl9JVls5XSB8IDA7XG4gIHByb3RlY3RlZCBGaDogbnVtYmVyID0gVDI1Nl9JVlsxMF0gfCAwO1xuICBwcm90ZWN0ZWQgRmw6IG51bWJlciA9IFQyNTZfSVZbMTFdIHwgMDtcbiAgcHJvdGVjdGVkIEdoOiBudW1iZXIgPSBUMjU2X0lWWzEyXSB8IDA7XG4gIHByb3RlY3RlZCBHbDogbnVtYmVyID0gVDI1Nl9JVlsxM10gfCAwO1xuICBwcm90ZWN0ZWQgSGg6IG51bWJlciA9IFQyNTZfSVZbMTRdIHwgMDtcbiAgcHJvdGVjdGVkIEhsOiBudW1iZXIgPSBUMjU2X0lWWzE1XSB8IDA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoMzIpO1xuICB9XG59XG5cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiBJbiBKUyBpdCdzIHRoZSBmYXN0ZXN0OiBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy4gU29tZSBpbmZvOlxuICpcbiAqIC0gVHJ5aW5nIDJeMTI4IGhhc2hlcyB3b3VsZCBnZXQgNTAlIGNoYW5jZSBvZiBjb2xsaXNpb24sIHVzaW5nIGJpcnRoZGF5IGF0dGFjay5cbiAqIC0gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqIC0gRWFjaCBzaGEyNTYgaGFzaCBpcyBleGVjdXRpbmcgMl4xOCBiaXQgb3BlcmF0aW9ucy5cbiAqIC0gR29vZCAyMDI0IEFTSUNzIGNhbiBkbyAyMDBUaC9zZWMgd2l0aCAzNTAwIHdhdHRzIG9mIHBvd2VyLCBjb3JyZXNwb25kaW5nIHRvIDJeMzYgaGFzaGVzL2pvdWxlLlxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2OiBDSGFzaDxfU0hBMjU2PiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoXG4gICgpID0+IG5ldyBfU0hBMjU2KCksXG4gIC8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDEpXG4pO1xuLyoqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNCAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNDogQ0hhc2g8X1NIQTIyND4gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKFxuICAoKSA9PiBuZXcgX1NIQTIyNCgpLFxuICAvKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDA0KVxuKTtcblxuLyoqIFNIQTItNTEyIGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTI6IENIYXNoPF9TSEE1MTI+ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcihcbiAgKCkgPT4gbmV3IF9TSEE1MTIoKSxcbiAgLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwMylcbik7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTM4NDogQ0hhc2g8X1NIQTM4ND4gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKFxuICAoKSA9PiBuZXcgX1NIQTM4NCgpLFxuICAvKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDAyKVxuKTtcblxuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTY6IENIYXNoPF9TSEE1MTJfMjU2PiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoXG4gICgpID0+IG5ldyBfU0hBNTEyXzI1NigpLFxuICAvKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDA2KVxuKTtcbi8qKlxuICogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0OiBDSGFzaDxfU0hBNTEyXzIyND4gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKFxuICAoKSA9PiBuZXcgX1NIQTUxMl8yMjQoKSxcbiAgLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwNSlcbik7XG4iLCAiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQge1xuICBhYnl0ZXMgYXMgYWJ5dGVzXyxcbiAgYW51bWJlcixcbiAgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4XyxcbiAgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXNfLFxuICBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNfLFxufSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmV4cG9ydCB7XG4gIGFieXRlcyxcbiAgYW51bWJlcixcbiAgYnl0ZXNUb0hleCxcbiAgY29uY2F0Qnl0ZXMsXG4gIGhleFRvQnl0ZXMsXG4gIGlzQnl0ZXMsXG4gIHJhbmRvbUJ5dGVzLFxufSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuXG5leHBvcnQgdHlwZSBDSGFzaCA9IHtcbiAgKG1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgY3JlYXRlKG9wdHM/OiB7IGRrTGVuPzogbnVtYmVyIH0pOiBhbnk7IC8vIEZvciBzaGFrZVxufTtcbmV4cG9ydCB0eXBlIEZIYXNoID0gKG1lc3NhZ2U6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXk7XG5leHBvcnQgZnVuY3Rpb24gYWJvb2wodmFsdWU6IGJvb2xlYW4sIHRpdGxlOiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBib29sZWFuLCBnb3QgdHlwZT0nICsgdHlwZW9mIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIFVzZWQgaW4gd2VpZXJzdHJhc3MsIGRlclxuZnVuY3Rpb24gYWJpZ251bWJlcihuOiBudW1iZXIgfCBiaWdpbnQpIHtcbiAgaWYgKHR5cGVvZiBuID09PSAnYmlnaW50Jykge1xuICAgIGlmICghaXNQb3NCaWcobikpIHRocm93IG5ldyBFcnJvcigncG9zaXRpdmUgYmlnaW50IGV4cGVjdGVkLCBnb3QgJyArIG4pO1xuICB9IGVsc2UgYW51bWJlcihuKTtcbiAgcmV0dXJuIG47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2FmZW51bWJlcih2YWx1ZTogbnVtYmVyLCB0aXRsZTogc3RyaW5nID0gJycpOiB2b2lkIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBzYWZlIGludGVnZXIsIGdvdCB0eXBlPScgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bTogbnVtYmVyIHwgYmlnaW50KTogc3RyaW5nIHtcbiAgY29uc3QgaGV4ID0gYWJpZ251bWJlcihudW0pLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4OiBzdHJpbmcpOiBiaWdpbnQge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cblxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXhfKGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXhfKGNvcHlCeXRlcyhhYnl0ZXNfKGJ5dGVzKSkucmV2ZXJzZSgpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobjogbnVtYmVyIHwgYmlnaW50LCBsZW46IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICBhbnVtYmVyKGxlbik7XG4gIG4gPSBhYmlnbnVtYmVyKG4pO1xuICBjb25zdCByZXMgPSBoZXhUb0J5dGVzXyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbiAgaWYgKHJlcy5sZW5ndGggIT09IGxlbikgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgdG9vIGxhcmdlJyk7XG4gIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG46IG51bWJlciB8IGJpZ2ludCwgbGVuOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuOiBudW1iZXIgfCBiaWdpbnQpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGhleFRvQnl0ZXNfKG51bWJlclRvSGV4VW5wYWRkZWQoYWJpZ251bWJlcihuKSkpO1xufVxuXG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGE6IFVpbnQ4QXJyYXksIGI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZGlmZiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG5cbi8qKlxuICogQ29waWVzIFVpbnQ4QXJyYXkuIFdlIGNhbid0IHVzZSB1OGEuc2xpY2UoKSwgYmVjYXVzZSB1OGEgY2FuIGJlIEJ1ZmZlcixcbiAqIGFuZCBCdWZmZXIjc2xpY2UgY3JlYXRlcyBtdXRhYmxlIGNvcHkuIE5ldmVyIHVzZSBCdWZmZXJzIVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuXG4vKipcbiAqIERlY29kZXMgNy1iaXQgQVNDSUkgc3RyaW5nIHRvIFVpbnQ4QXJyYXksIHRocm93cyBvbiBub24tYXNjaWkgc3ltYm9sc1xuICogU2hvdWxkIGJlIHNhZmUgdG8gdXNlIGZvciB0aGluZ3MgZXhwZWN0ZWQgdG8gYmUgQVNDSUkuXG4gKiBSZXR1cm5zIGV4YWN0IHNhbWUgcmVzdWx0IGFzIGBUZXh0RW5jb2RlcmAgZm9yIEFTQ0lJIG9yIHRocm93cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhhc2NpaTogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYXNjaWksIChjLCBpKSA9PiB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGMubGVuZ3RoICE9PSAxIHx8IGNoYXJDb2RlID4gMTI3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlciBcIiR7YXNjaWlbaV19XCIgd2l0aCBjb2RlICR7Y2hhckNvZGV9IGF0IHBvc2l0aW9uICR7aX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH0pO1xufVxuXG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG46IGJpZ2ludCkgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZShuOiBiaWdpbnQsIG1pbjogYmlnaW50LCBtYXg6IGJpZ2ludCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG5cbi8qKlxuICogQXNzZXJ0cyBtaW4gPD0gbiA8IG1heC4gTk9URTogSXQncyA8IG1heCBhbmQgbm90IDw9IG1heC5cbiAqIEBleGFtcGxlXG4gKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYUluUmFuZ2UodGl0bGU6IHN0cmluZywgbjogYmlnaW50LCBtaW46IGJpZ2ludCwgbWF4OiBiaWdpbnQpOiB2b2lkIHtcbiAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cblxuLy8gQml0IG9wZXJhdGlvbnNcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKiBUT0RPOiBtZXJnZSB3aXRoIG5MZW5ndGggaW4gbW9kdWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG46IGJpZ2ludCk6IG51bWJlciB7XG4gIGxldCBsZW47XG4gIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSk7XG4gIHJldHVybiBsZW47XG59XG5cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuOiBiaWdpbnQsIHBvczogbnVtYmVyKTogYmlnaW50IHtcbiAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cblxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobjogYmlnaW50LCBwb3M6IG51bWJlciwgdmFsdWU6IGJvb2xlYW4pOiBiaWdpbnQge1xuICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuOiBudW1iZXIpOiBiaWdpbnQgPT4gKF8xbiA8PCBCaWdJbnQobikpIC0gXzFuO1xuXG4vLyBEUkJHXG5cbnR5cGUgUHJlZDxUPiA9ICh2OiBVaW50OEFycmF5KSA9PiBUIHwgdW5kZWZpbmVkO1xuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZzxUPihcbiAgaGFzaExlbjogbnVtYmVyLFxuICBxQnl0ZUxlbjogbnVtYmVyLFxuICBobWFjRm46IChrZXk6IFVpbnQ4QXJyYXksIG1lc3NhZ2U6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbik6IChzZWVkOiBVaW50OEFycmF5LCBwcmVkaWNhdGU6IFByZWQ8VD4pID0+IFQge1xuICBhbnVtYmVyKGhhc2hMZW4sICdoYXNoTGVuJyk7XG4gIGFudW1iZXIocUJ5dGVMZW4sICdxQnl0ZUxlbicpO1xuICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIGNvbnN0IHU4biA9IChsZW46IG51bWJlcik6IFVpbnQ4QXJyYXkgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gIGNvbnN0IE5VTEwgPSBVaW50OEFycmF5Lm9mKCk7XG4gIGNvbnN0IGJ5dGUwID0gVWludDhBcnJheS5vZigweDAwKTtcbiAgY29uc3QgYnl0ZTEgPSBVaW50OEFycmF5Lm9mKDB4MDEpO1xuICBjb25zdCBfbWF4RHJiZ0l0ZXJzID0gMTAwMDtcblxuICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIHYuZmlsbCgxKTtcbiAgICBrLmZpbGwoMCk7XG4gICAgaSA9IDA7XG4gIH07XG4gIGNvbnN0IGggPSAoLi4ubXNnczogVWludDhBcnJheVtdKSA9PiBobWFjRm4oaywgY29uY2F0Qnl0ZXNfKHYsIC4uLm1zZ3MpKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gIGNvbnN0IHJlc2VlZCA9IChzZWVkOiBVaW50OEFycmF5ID0gTlVMTCkgPT4ge1xuICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgayA9IGgoYnl0ZTAsIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBrID0gaChieXRlMSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICB9O1xuICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICBpZiAoaSsrID49IF9tYXhEcmJnSXRlcnMpIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgbWF4IGFtb3VudCBvZiBpdGVyYXRpb25zJyk7XG4gICAgbGV0IGxlbiA9IDA7XG4gICAgY29uc3Qgb3V0OiBVaW50OEFycmF5W10gPSBbXTtcbiAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgIHYgPSBoKCk7XG4gICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzXyguLi5vdXQpO1xuICB9O1xuICBjb25zdCBnZW5VbnRpbCA9IChzZWVkOiBVaW50OEFycmF5LCBwcmVkOiBQcmVkPFQ+KTogVCA9PiB7XG4gICAgcmVzZXQoKTtcbiAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgIGxldCByZXM6IFQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSkgcmVzZWVkKCk7XG4gICAgcmVzZXQoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZXR1cm4gZ2VuVW50aWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChcbiAgb2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSxcbiAgb3B0RmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbik6IHZvaWQge1xuICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBvcHRpb25zIG9iamVjdCcpO1xuICB0eXBlIEl0ZW0gPSBrZXlvZiB0eXBlb2Ygb2JqZWN0O1xuICBmdW5jdGlvbiBjaGVja0ZpZWxkKGZpZWxkTmFtZTogSXRlbSwgZXhwZWN0ZWRUeXBlOiBzdHJpbmcsIGlzT3B0OiBib29sZWFuKSB7XG4gICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgaWYgKGlzT3B0ICYmIHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudCA9IHR5cGVvZiB2YWw7XG4gICAgaWYgKGN1cnJlbnQgIT09IGV4cGVjdGVkVHlwZSB8fCB2YWwgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmFtIFwiJHtmaWVsZE5hbWV9XCIgaXMgaW52YWxpZDogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHtjdXJyZW50fWApO1xuICB9XG4gIGNvbnN0IGl0ZXIgPSAoZjogdHlwZW9mIGZpZWxkcywgaXNPcHQ6IGJvb2xlYW4pID0+XG4gICAgT2JqZWN0LmVudHJpZXMoZikuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIGlzT3B0KSk7XG4gIGl0ZXIoZmllbGRzLCBmYWxzZSk7XG4gIGl0ZXIob3B0RmllbGRzLCB0cnVlKTtcbn1cblxuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpOiBuZXZlciA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQ8VCBleHRlbmRzIG9iamVjdCwgUiwgTyBleHRlbmRzIGFueVtdPihcbiAgZm46IChhcmc6IFQsIC4uLmFyZ3M6IE8pID0+IFJcbik6IChhcmc6IFQsIC4uLmFyZ3M6IE8pID0+IFIge1xuICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcDxULCBSPigpO1xuICByZXR1cm4gKGFyZzogVCwgLi4uYXJnczogTyk6IFIgPT4ge1xuICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHJldHVybiB2YWw7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyeXB0b0tleXMge1xuICBsZW5ndGhzOiB7IHNlZWQ/OiBudW1iZXI7IHB1YmxpYz86IG51bWJlcjsgc2VjcmV0PzogbnVtYmVyIH07XG4gIGtleWdlbjogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiB7IHNlY3JldEtleTogVWludDhBcnJheTsgcHVibGljS2V5OiBVaW50OEFycmF5IH07XG4gIGdldFB1YmxpY0tleTogKHNlY3JldEtleTogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbn1cblxuLyoqIEdlbmVyaWMgaW50ZXJmYWNlIGZvciBzaWduYXR1cmVzLiBIYXMga2V5Z2VuLCBzaWduIGFuZCB2ZXJpZnkuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25lciBleHRlbmRzIENyeXB0b0tleXMge1xuICAvLyBJbnRlcmZhY2VzIGFyZSBmdW4uIFdlIGNhbm5vdCBqdXN0IGFkZCBuZXcgZmllbGRzIHdpdGhvdXQgY29weWluZyBvbGQgb25lcy5cbiAgbGVuZ3Roczoge1xuICAgIHNlZWQ/OiBudW1iZXI7XG4gICAgcHVibGljPzogbnVtYmVyO1xuICAgIHNlY3JldD86IG51bWJlcjtcbiAgICBzaWduUmFuZD86IG51bWJlcjtcbiAgICBzaWduYXR1cmU/OiBudW1iZXI7XG4gIH07XG4gIHNpZ246IChtc2c6IFVpbnQ4QXJyYXksIHNlY3JldEtleTogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgdmVyaWZ5OiAoc2lnOiBVaW50OEFycmF5LCBtc2c6IFVpbnQ4QXJyYXksIHB1YmxpY0tleTogVWludDhBcnJheSkgPT4gYm9vbGVhbjtcbn1cbiIsICIvKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaWVsZHMuXG4gKiBGaWVsZCBvdmVyIDExIGlzIGEgZmluaXRlIChHYWxvaXMpIGZpZWxkIGlzIGludGVnZXIgbnVtYmVyIG9wZXJhdGlvbnMgYG1vZCAxMWAuXG4gKiBUaGVyZSBpcyBubyBkaXZpc2lvbjogaXQgaXMgcmVwbGFjZWQgYnkgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQge1xuICBhYnl0ZXMsXG4gIGFudW1iZXIsXG4gIGJ5dGVzVG9OdW1iZXJCRSxcbiAgYnl0ZXNUb051bWJlckxFLFxuICBudW1iZXJUb0J5dGVzQkUsXG4gIG51bWJlclRvQnl0ZXNMRSxcbiAgdmFsaWRhdGVPYmplY3QsXG59IGZyb20gJy4uL3V0aWxzLnRzJztcblxuLy8gTnVtYmVycyBhcmVuJ3QgdXNlZCBpbiB4MjU1MTkgLyB4NDQ4IGJ1aWxkc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApLCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpLCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfM24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpLCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpLCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpLCBfOW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDkpO1xuY29uc3QgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuXG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYTogYmlnaW50LCBiOiBiaWdpbnQpOiBiaWdpbnQge1xuICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW06IGJpZ2ludCwgcG93ZXI6IGJpZ2ludCwgbW9kdWxvOiBiaWdpbnQpOiBiaWdpbnQge1xuICByZXR1cm4gRnBQb3coRmllbGQobW9kdWxvKSwgbnVtLCBwb3dlcik7XG59XG5cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeDogYmlnaW50LCBwb3dlcjogYmlnaW50LCBtb2R1bG86IGJpZ2ludCk6IGJpZ2ludCB7XG4gIGxldCByZXMgPSB4O1xuICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgIHJlcyAqPSByZXM7XG4gICAgcmVzICU9IG1vZHVsbztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyOiBiaWdpbnQsIG1vZHVsbzogYmlnaW50KTogYmlnaW50IHtcbiAgaWYgKG51bWJlciA9PT0gXzBuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gIGlmIChtb2R1bG8gPD0gXzBuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICBsZXQgYiA9IG1vZHVsbztcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICBjb25zdCByID0gYiAlIGE7XG4gICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gIH1cbiAgY29uc3QgZ2NkID0gYjtcbiAgaWYgKGdjZCAhPT0gXzFuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc1NxdWFyZTxUPihGcDogSUZpZWxkPFQ+LCByb290OiBULCBuOiBUKTogdm9pZCB7XG4gIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbn1cblxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpIHtcbiAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBzcXJ0NW1vZDg8VD4oRnA6IElGaWVsZDxUPiwgbjogVCkge1xuICBjb25zdCBwNWRpdjggPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuO1xuICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICBjb25zdCB2ID0gRnAucG93KG4yLCBwNWRpdjgpO1xuICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8vIEJhc2VkIG9uIFJGQzkzODAsIEtvbmcgYWxnb3JpdGhtXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIHNxcnQ5bW9kMTYoUDogYmlnaW50KTogPFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpID0+IFQge1xuICBjb25zdCBGcF8gPSBGaWVsZChQKTtcbiAgY29uc3QgdG4gPSB0b25lbGxpU2hhbmtzKFApO1xuICBjb25zdCBjMSA9IHRuKEZwXywgRnBfLm5lZyhGcF8uT05FKSk7Ly8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgY29uc3QgYzIgPSB0bihGcF8sIGMxKTsgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gIGNvbnN0IGMzID0gdG4oRnBfLCBGcF8ubmVnKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIHJldHVybiA8VD4oRnA6IElGaWVsZDxUPiwgbjogVCkgPT4ge1xuICAgIGxldCB0djEgPSBGcC5wb3cobiwgYzQpOyAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICBsZXQgdHYyID0gRnAubXVsKHR2MSwgYzEpOyAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgIGNvbnN0IHR2MyA9IEZwLm11bCh0djEsIGMyKTsgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgY29uc3QgdHY0ID0gRnAubXVsKHR2MSwgYzMpOyAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICBjb25zdCBlMiA9IEZwLmVxbChGcC5zcXIodHYzKSwgbik7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7ICAgICAgIC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7ICAgICAgIC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICBjb25zdCBlMyA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICBjb25zdCByb290ID0gRnAuY21vdih0djEsIHR2MiwgZTMpOy8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgICMgU2VsZWN0IHNxcnQgZnJvbSB0djEgJiB0djJcbiAgICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG59XG5cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUDogYmlnaW50KTogPFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpID0+IFQge1xuICAvLyBJbml0aWFsaXphdGlvbiAocHJlY29tcHV0YXRpb24pLlxuICAvLyBDYWNoaW5nIGluaXRpYWxpemF0aW9uIGNvdWxkIGJvb3N0IHBlcmYgYnkgNyUuXG4gIGlmIChQIDwgXzNuKSB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgaXMgbm90IGRlZmluZWQgZm9yIHNtYWxsIGZpZWxkJyk7XG4gIC8vIEZhY3RvciBQIC0gMSA9IFEgKiAyXlMsIHdoZXJlIFEgaXMgb2RkXG4gIGxldCBRID0gUCAtIF8xbjtcbiAgbGV0IFMgPSAwO1xuICB3aGlsZSAoUSAlIF8ybiA9PT0gXzBuKSB7XG4gICAgUSAvPSBfMm47XG4gICAgUysrO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgZmlyc3QgcXVhZHJhdGljIG5vbi1yZXNpZHVlIFogPj0gMlxuICBsZXQgWiA9IF8ybjtcbiAgY29uc3QgX0ZwID0gRmllbGQoUCk7XG4gIHdoaWxlIChGcExlZ2VuZHJlKF9GcCwgWikgPT09IDEpIHtcbiAgICAvLyBCYXNpYyBwcmltYWxpdHkgdGVzdCBmb3IgUC4gQWZ0ZXIgeCBpdGVyYXRpb25zLCBjaGFuY2Ugb2ZcbiAgICAvLyBub3QgZmluZGluZyBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgaXMgMl54LCBzbyAyXjEwMDAuXG4gICAgaWYgKForKyA+IDEwMDApIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IHByb2JhYmx5IG5vbi1wcmltZSBQJyk7XG4gIH1cbiAgLy8gRmFzdC1wYXRoOyB1c3VhbGx5IGRvbmUgYmVmb3JlIFosIGJ1dCB3ZSBkbyBcInByaW1hbGl0eSB0ZXN0XCIuXG4gIGlmIChTID09PSAxKSByZXR1cm4gc3FydDNtb2Q0O1xuXG4gIC8vIFNsb3ctcGF0aFxuICAvLyBUT0RPOiB0ZXN0IG9uIEZwMiBhbmQgb3RoZXJzXG4gIGxldCBjYyA9IF9GcC5wb3coWiwgUSk7IC8vIGMgPSB6XlFcbiAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3c8VD4oRnA6IElGaWVsZDxUPiwgbjogVCk6IFQge1xuICAgIGlmIChGcC5pczAobikpIHJldHVybiBuO1xuICAgIC8vIENoZWNrIGlmIG4gaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB1c2luZyBMZWdlbmRyZSBzeW1ib2xcbiAgICBpZiAoRnBMZWdlbmRyZShGcCwgbikgIT09IDEpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcblxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGZvciB0aGUgbWFpbiBsb29wXG4gICAgbGV0IE0gPSBTO1xuICAgIGxldCBjID0gRnAubXVsKEZwLk9ORSwgY2MpOyAvLyBjID0gel5RLCBtb3ZlIGNjIGZyb20gZmllbGQgX0ZwIGludG8gZmllbGQgRnBcbiAgICBsZXQgdCA9IEZwLnBvdyhuLCBRKTsgLy8gdCA9IG5eUSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgIGxldCBSID0gRnAucG93KG4sIFExZGl2Mik7IC8vIFIgPSBuXigoUSsxKS8yKSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICAvLyB3aGlsZSB0ICE9IDFcbiAgICB3aGlsZSAoIUZwLmVxbCh0LCBGcC5PTkUpKSB7XG4gICAgICBpZiAoRnAuaXMwKHQpKSByZXR1cm4gRnAuWkVSTzsgLy8gaWYgdD0wIHJldHVybiBSPTBcbiAgICAgIGxldCBpID0gMTtcblxuICAgICAgLy8gRmluZCB0aGUgc21hbGxlc3QgaSA+PSAxIHN1Y2ggdGhhdCB0XigyXmkpIFx1MjI2MSAxIChtb2QgUClcbiAgICAgIGxldCB0X3RtcCA9IEZwLnNxcih0KTsgLy8gdF4oMl4xKVxuICAgICAgd2hpbGUgKCFGcC5lcWwodF90bXAsIEZwLk9ORSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICB0X3RtcCA9IEZwLnNxcih0X3RtcCk7IC8vIHReKDJeMikuLi5cbiAgICAgICAgaWYgKGkgPT09IE0pIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBmb3IgYjogMl4oTSAtIGkgLSAxKVxuICAgICAgY29uc3QgZXhwb25lbnQgPSBfMW4gPDwgQmlnSW50KE0gLSBpIC0gMSk7IC8vIGJpZ2ludCBpcyBpbXBvcnRhbnRcbiAgICAgIGNvbnN0IGIgPSBGcC5wb3coYywgZXhwb25lbnQpOyAvLyBiID0gMl4oTSAtIGkgLSAxKVxuXG4gICAgICAvLyBVcGRhdGUgdmFyaWFibGVzXG4gICAgICBNID0gaTtcbiAgICAgIGMgPSBGcC5zcXIoYik7IC8vIGMgPSBiXjJcbiAgICAgIHQgPSBGcC5tdWwodCwgYyk7IC8vIHQgPSAodCAqIGJeMilcbiAgICAgIFIgPSBGcC5tdWwoUiwgYik7IC8vIFIgPSBSKmJcbiAgICB9XG4gICAgcmV0dXJuIFI7XG4gIH07XG59XG5cbi8qKlxuICogU3F1YXJlIHJvb3QgZm9yIGEgZmluaXRlIGZpZWxkLiBXaWxsIHRyeSBvcHRpbWl6ZWQgdmVyc2lvbnMgZmlyc3Q6XG4gKlxuICogMS4gUCBcdTIyNjEgMyAobW9kIDQpXG4gKiAyLiBQIFx1MjI2MSA1IChtb2QgOClcbiAqIDMuIFAgXHUyMjYxIDkgKG1vZCAxNilcbiAqIDQuIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICpcbiAqIERpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAqIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFA6IGJpZ2ludCk6IDxUPihGcDogSUZpZWxkPFQ+LCBuOiBUKSA9PiBUIHtcbiAgLy8gUCBcdTIyNjEgMyAobW9kIDQpID0+IFx1MjIxQW4gPSBuXigoUCsxKS80KVxuICBpZiAoUCAlIF80biA9PT0gXzNuKSByZXR1cm4gc3FydDNtb2Q0O1xuICAvLyBQIFx1MjI2MSA1IChtb2QgOCkgPT4gQXRraW4gYWxnb3JpdGhtLCBwYWdlIDEwIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuICBpZiAoUCAlIF84biA9PT0gXzVuKSByZXR1cm4gc3FydDVtb2Q4O1xuICAvLyBQIFx1MjI2MSA5IChtb2QgMTYpID0+IEtvbmcgYWxnb3JpdGhtLCBwYWdlIDExIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAoYWxnb3JpdGhtIDQpXG4gIGlmIChQICUgXzE2biA9PT0gXzluKSByZXR1cm4gc3FydDltb2QxNihQKTtcbiAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtOiBiaWdpbnQsIG1vZHVsbzogYmlnaW50KTogYm9vbGVhbiA9PlxuICAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcblxuLyoqIEZpZWxkIGlzIG5vdCBhbHdheXMgb3ZlciBwcmltZTogZm9yIGV4YW1wbGUsIEZwMiBoYXMgT1JERVIocSk9cF5tLiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRmllbGQ8VD4ge1xuICBPUkRFUjogYmlnaW50O1xuICBCWVRFUzogbnVtYmVyO1xuICBCSVRTOiBudW1iZXI7XG4gIGlzTEU6IGJvb2xlYW47XG4gIFpFUk86IFQ7XG4gIE9ORTogVDtcbiAgLy8gMS1hcmdcbiAgY3JlYXRlOiAobnVtOiBUKSA9PiBUO1xuICBpc1ZhbGlkOiAobnVtOiBUKSA9PiBib29sZWFuO1xuICBpczA6IChudW06IFQpID0+IGJvb2xlYW47XG4gIGlzVmFsaWROb3QwOiAobnVtOiBUKSA9PiBib29sZWFuO1xuICBuZWcobnVtOiBUKTogVDtcbiAgaW52KG51bTogVCk6IFQ7XG4gIHNxcnQobnVtOiBUKTogVDtcbiAgc3FyKG51bTogVCk6IFQ7XG4gIC8vIDItYXJnc1xuICBlcWwobGhzOiBULCByaHM6IFQpOiBib29sZWFuO1xuICBhZGQobGhzOiBULCByaHM6IFQpOiBUO1xuICBzdWIobGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWwobGhzOiBULCByaHM6IFQgfCBiaWdpbnQpOiBUO1xuICBwb3cobGhzOiBULCBwb3dlcjogYmlnaW50KTogVDtcbiAgZGl2KGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgLy8gTiBmb3IgTm9uTm9ybWFsaXplZCAoZm9yIG5vdylcbiAgYWRkTihsaHM6IFQsIHJoczogVCk6IFQ7XG4gIHN1Yk4obGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWxOKGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgc3FyTihudW06IFQpOiBUO1xuXG4gIC8vIE9wdGlvbmFsXG4gIC8vIFNob3VsZCBiZSBzYW1lIGFzIHNnbjAgZnVuY3Rpb24gaW5cbiAgLy8gW1JGQzkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNC4xKS5cbiAgLy8gTk9URTogc2duMCBpcyAnbmVnYXRpdmUgaW4gTEUnLCB3aGljaCBpcyBzYW1lIGFzIG9kZC4gQW5kIG5lZ2F0aXZlIGluIExFIGlzIGtpbmRhIHN0cmFuZ2UgZGVmaW5pdGlvbiBhbnl3YXkuXG4gIGlzT2RkPyhudW06IFQpOiBib29sZWFuOyAvLyBPZGQgaW5zdGVhZCBvZiBldmVuIHNpbmNlIHdlIGhhdmUgaXQgZm9yIEZwMlxuICAvLyBsZWdlbmRyZT8obnVtOiBUKTogVDtcbiAgaW52ZXJ0QmF0Y2g6IChsc3Q6IFRbXSkgPT4gVFtdO1xuICB0b0J5dGVzKG51bTogVCk6IFVpbnQ4QXJyYXk7XG4gIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSwgc2tpcFZhbGlkYXRpb24/OiBib29sZWFuKTogVDtcbiAgLy8gSWYgYyBpcyBGYWxzZSwgQ01PViByZXR1cm5zIGEsIG90aGVyd2lzZSBpdCByZXR1cm5zIGIuXG4gIGNtb3YoYTogVCwgYjogVCwgYzogYm9vbGVhbik6IFQ7XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dIGFzIGNvbnN0O1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQ8VD4oZmllbGQ6IElGaWVsZDxUPik6IElGaWVsZDxUPiB7XG4gIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgT1JERVI6ICdiaWdpbnQnLFxuICAgIEJZVEVTOiAnbnVtYmVyJyxcbiAgICBCSVRTOiAnbnVtYmVyJyxcbiAgfSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWw6IHN0cmluZykgPT4ge1xuICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gbWFwO1xuICB9LCBpbml0aWFsKTtcbiAgdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xuICAvLyBjb25zdCBtYXggPSAxNjM4NDtcbiAgLy8gaWYgKGZpZWxkLkJZVEVTIDwgMSB8fCBmaWVsZC5CWVRFUyA+IG1heCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkJyk7XG4gIC8vIGlmIChmaWVsZC5CSVRTIDwgMSB8fCBmaWVsZC5CSVRTID4gOCAqIG1heCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkJyk7XG4gIHJldHVybiBmaWVsZDtcbn1cblxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcblxuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3c8VD4oRnA6IElGaWVsZDxUPiwgbnVtOiBULCBwb3dlcjogYmlnaW50KTogVCB7XG4gIGlmIChwb3dlciA8IF8wbikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgaWYgKHBvd2VyID09PSBfMG4pIHJldHVybiBGcC5PTkU7XG4gIGlmIChwb3dlciA9PT0gXzFuKSByZXR1cm4gbnVtO1xuICBsZXQgcCA9IEZwLk9ORTtcbiAgbGV0IGQgPSBudW07XG4gIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgIGlmIChwb3dlciAmIF8xbikgcCA9IEZwLm11bChwLCBkKTtcbiAgICBkID0gRnAuc3FyKGQpO1xuICAgIHBvd2VyID4+PSBfMW47XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogRXhjZXB0aW9uLWZyZWUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvciAwIGVsZW1lbnRzLlxuICogQHBhcmFtIHBhc3NaZXJvIG1hcCAwIHRvIDAgKGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaDxUPihGcDogSUZpZWxkPFQ+LCBudW1zOiBUW10sIHBhc3NaZXJvID0gZmFsc2UpOiBUW10ge1xuICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gIGNvbnN0IG11bHRpcGxpZWRBY2MgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICBpZiAoRnAuaXMwKG51bSkpIHJldHVybiBhY2M7XG4gICAgaW52ZXJ0ZWRbaV0gPSBhY2M7XG4gICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gIH0sIEZwLk9ORSk7XG4gIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgY29uc3QgaW52ZXJ0ZWRBY2MgPSBGcC5pbnYobXVsdGlwbGllZEFjYyk7XG4gIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICBpZiAoRnAuaXMwKG51bSkpIHJldHVybiBhY2M7XG4gICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gIH0sIGludmVydGVkQWNjKTtcbiAgcmV0dXJuIGludmVydGVkO1xufVxuXG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdjxUPihGcDogSUZpZWxkPFQ+LCBsaHM6IFQsIHJoczogVCB8IGJpZ2ludCk6IFQge1xuICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG5cbi8qKlxuICogTGVnZW5kcmUgc3ltYm9sLlxuICogTGVnZW5kcmUgY29uc3RhbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcClcbiAqIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gKlxuICogKiAoYSB8IHApIFx1MjI2MSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIHJlc2lkdWVcbiAqICogKGEgfCBwKSBcdTIyNjEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAqICogKGEgfCBwKSBcdTIyNjEgMCAgICBpZiBhIFx1MjI2MSAwIChtb2QgcClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwTGVnZW5kcmU8VD4oRnA6IElGaWVsZDxUPiwgbjogVCk6IC0xIHwgMCB8IDEge1xuICAvLyBXZSBjYW4gdXNlIDNyZCBhcmd1bWVudCBhcyBvcHRpb25hbCBjYWNoZSBvZiB0aGlzIHZhbHVlXG4gIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgY29uc3QgcDFtb2QyID0gKEZwLk9SREVSIC0gXzFuKSAvIF8ybjtcbiAgY29uc3QgcG93ZXJlZCA9IEZwLnBvdyhuLCBwMW1vZDIpO1xuICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgY29uc3QgemVybyA9IEZwLmVxbChwb3dlcmVkLCBGcC5aRVJPKTtcbiAgY29uc3Qgbm8gPSBGcC5lcWwocG93ZXJlZCwgRnAubmVnKEZwLk9ORSkpO1xuICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gIHJldHVybiB5ZXMgPyAxIDogemVybyA/IDAgOiAtMTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZTxUPihGcDogSUZpZWxkPFQ+LCBuOiBUKTogYm9vbGVhbiB7XG4gIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgcmV0dXJuIGwgPT09IDE7XG59XG5cbmV4cG9ydCB0eXBlIE5MZW5ndGggPSB7IG5CeXRlTGVuZ3RoOiBudW1iZXI7IG5CaXRMZW5ndGg6IG51bWJlciB9O1xuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuOiBiaWdpbnQsIG5CaXRMZW5ndGg/OiBudW1iZXIpOiBOTGVuZ3RoIHtcbiAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpIGFudW1iZXIobkJpdExlbmd0aCk7XG4gIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cblxudHlwZSBGcEZpZWxkID0gSUZpZWxkPGJpZ2ludD4gJiBSZXF1aXJlZDxQaWNrPElGaWVsZDxiaWdpbnQ+LCAnaXNPZGQnPj47XG50eXBlIFNxcnRGbiA9IChuOiBiaWdpbnQpID0+IGJpZ2ludDtcbnR5cGUgRmllbGRPcHRzID0gUGFydGlhbDx7XG4gIGlzTEU6IGJvb2xlYW47XG4gIEJJVFM6IG51bWJlcjtcbiAgc3FydDogU3FydEZuO1xuICBhbGxvd2VkTGVuZ3Rocz86IHJlYWRvbmx5IG51bWJlcltdOyAvLyBmb3IgUDUyMSAoYWRkcyBwYWRkaW5nIGZvciBzbWFsbGVyIHNpemVzKVxuICBtb2RGcm9tQnl0ZXM6IGJvb2xlYW47IC8vIGJsczEyLTM4MSByZXF1aXJlcyBtb2QobikgaW5zdGVhZCBvZiByZWplY3Rpbmcga2V5cyA+PSBuXG59PjtcbmNsYXNzIF9GaWVsZCBpbXBsZW1lbnRzIElGaWVsZDxiaWdpbnQ+IHtcbiAgcmVhZG9ubHkgT1JERVI6IGJpZ2ludDtcbiAgcmVhZG9ubHkgQklUUzogbnVtYmVyO1xuICByZWFkb25seSBCWVRFUzogbnVtYmVyO1xuICByZWFkb25seSBpc0xFOiBib29sZWFuO1xuICByZWFkb25seSBaRVJPID0gXzBuO1xuICByZWFkb25seSBPTkUgPSBfMW47XG4gIHJlYWRvbmx5IF9sZW5ndGhzPzogbnVtYmVyW107XG4gIHByaXZhdGUgX3NxcnQ6IFJldHVyblR5cGU8dHlwZW9mIEZwU3FydD4gfCB1bmRlZmluZWQ7IC8vIGNhY2hlZCBzcXJ0XG4gIHByaXZhdGUgcmVhZG9ubHkgX21vZD86IGJvb2xlYW47XG4gIGNvbnN0cnVjdG9yKE9SREVSOiBiaWdpbnQsIG9wdHM6IEZpZWxkT3B0cyA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiA+IDAsIGdvdCAnICsgT1JERVIpO1xuICAgIGxldCBfbmJpdExlbmd0aDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNMRSA9IGZhbHNlO1xuICAgIGlmIChvcHRzICE9IG51bGwgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMuQklUUyA9PT0gJ251bWJlcicpIF9uYml0TGVuZ3RoID0gb3B0cy5CSVRTO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnNxcnQgPT09ICdmdW5jdGlvbicpIHRoaXMuc3FydCA9IG9wdHMuc3FydDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5pc0xFID09PSAnYm9vbGVhbicpIHRoaXMuaXNMRSA9IG9wdHMuaXNMRTtcbiAgICAgIGlmIChvcHRzLmFsbG93ZWRMZW5ndGhzKSB0aGlzLl9sZW5ndGhzID0gb3B0cy5hbGxvd2VkTGVuZ3Rocz8uc2xpY2UoKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5tb2RGcm9tQnl0ZXMgPT09ICdib29sZWFuJykgdGhpcy5fbW9kID0gb3B0cy5tb2RGcm9tQnl0ZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAobkJ5dGVMZW5ndGggPiAyMDQ4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICB0aGlzLk9SREVSID0gT1JERVI7XG4gICAgdGhpcy5CSVRTID0gbkJpdExlbmd0aDtcbiAgICB0aGlzLkJZVEVTID0gbkJ5dGVMZW5ndGg7XG4gICAgdGhpcy5fc3FydCA9IHVuZGVmaW5lZDtcbiAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gIH1cblxuICBjcmVhdGUobnVtOiBiaWdpbnQpIHtcbiAgICByZXR1cm4gbW9kKG51bSwgdGhpcy5PUkRFUik7XG4gIH1cbiAgaXNWYWxpZChudW06IGJpZ2ludCkge1xuICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgdGhpcy5PUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICB9XG4gIGlzMChudW06IGJpZ2ludCkge1xuICAgIHJldHVybiBudW0gPT09IF8wbjtcbiAgfVxuICAvLyBpcyB2YWxpZCBhbmQgaW52ZXJ0aWJsZVxuICBpc1ZhbGlkTm90MChudW06IGJpZ2ludCkge1xuICAgIHJldHVybiAhdGhpcy5pczAobnVtKSAmJiB0aGlzLmlzVmFsaWQobnVtKTtcbiAgfVxuICBpc09kZChudW06IGJpZ2ludCkge1xuICAgIHJldHVybiAobnVtICYgXzFuKSA9PT0gXzFuO1xuICB9XG4gIG5lZyhudW06IGJpZ2ludCkge1xuICAgIHJldHVybiBtb2QoLW51bSwgdGhpcy5PUkRFUik7XG4gIH1cbiAgZXFsKGxoczogYmlnaW50LCByaHM6IGJpZ2ludCkge1xuICAgIHJldHVybiBsaHMgPT09IHJocztcbiAgfVxuXG4gIHNxcihudW06IGJpZ2ludCkge1xuICAgIHJldHVybiBtb2QobnVtICogbnVtLCB0aGlzLk9SREVSKTtcbiAgfVxuICBhZGQobGhzOiBiaWdpbnQsIHJoczogYmlnaW50KSB7XG4gICAgcmV0dXJuIG1vZChsaHMgKyByaHMsIHRoaXMuT1JERVIpO1xuICB9XG4gIHN1YihsaHM6IGJpZ2ludCwgcmhzOiBiaWdpbnQpIHtcbiAgICByZXR1cm4gbW9kKGxocyAtIHJocywgdGhpcy5PUkRFUik7XG4gIH1cbiAgbXVsKGxoczogYmlnaW50LCByaHM6IGJpZ2ludCkge1xuICAgIHJldHVybiBtb2QobGhzICogcmhzLCB0aGlzLk9SREVSKTtcbiAgfVxuICBwb3cobnVtOiBiaWdpbnQsIHBvd2VyOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBGcFBvdyh0aGlzLCBudW0sIHBvd2VyKTtcbiAgfVxuICBkaXYobGhzOiBiaWdpbnQsIHJoczogYmlnaW50KSB7XG4gICAgcmV0dXJuIG1vZChsaHMgKiBpbnZlcnQocmhzLCB0aGlzLk9SREVSKSwgdGhpcy5PUkRFUik7XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgc3FyTihudW06IGJpZ2ludCkge1xuICAgIHJldHVybiBudW0gKiBudW07XG4gIH1cbiAgYWRkTihsaHM6IGJpZ2ludCwgcmhzOiBiaWdpbnQpIHtcbiAgICByZXR1cm4gbGhzICsgcmhzO1xuICB9XG4gIHN1Yk4obGhzOiBiaWdpbnQsIHJoczogYmlnaW50KSB7XG4gICAgcmV0dXJuIGxocyAtIHJocztcbiAgfVxuICBtdWxOKGxoczogYmlnaW50LCByaHM6IGJpZ2ludCkge1xuICAgIHJldHVybiBsaHMgKiByaHM7XG4gIH1cblxuICBpbnYobnVtOiBiaWdpbnQpIHtcbiAgICByZXR1cm4gaW52ZXJ0KG51bSwgdGhpcy5PUkRFUik7XG4gIH1cbiAgc3FydChudW06IGJpZ2ludCk6IGJpZ2ludCB7XG4gICAgLy8gQ2FjaGluZyBfc3FydCBzcGVlZHMgdXAgc3FydDltb2QxNiBieSA1eCBhbmQgdG9ubmVsaS1zaGFua3MgYnkgMTAlXG4gICAgaWYgKCF0aGlzLl9zcXJ0KSB0aGlzLl9zcXJ0ID0gRnBTcXJ0KHRoaXMuT1JERVIpO1xuICAgIHJldHVybiB0aGlzLl9zcXJ0KHRoaXMsIG51bSk7XG4gIH1cbiAgdG9CeXRlcyhudW06IGJpZ2ludCkge1xuICAgIHJldHVybiB0aGlzLmlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCB0aGlzLkJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIHRoaXMuQllURVMpO1xuICB9XG4gIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSwgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgY29uc3QgeyBfbGVuZ3RoczogYWxsb3dlZExlbmd0aHMsIEJZVEVTLCBpc0xFLCBPUkRFUiwgX21vZDogbW9kRnJvbUJ5dGVzIH0gPSB0aGlzO1xuICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgaWYgKCFhbGxvd2VkTGVuZ3Rocy5pbmNsdWRlcyhieXRlcy5sZW5ndGgpIHx8IGJ5dGVzLmxlbmd0aCA+IEJZVEVTKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgYWxsb3dlZExlbmd0aHMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoQllURVMpO1xuICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICBwYWRkZWQuc2V0KGJ5dGVzLCBpc0xFID8gMCA6IHBhZGRlZC5sZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgICAgYnl0ZXMgPSBwYWRkZWQ7XG4gICAgfVxuICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBCWVRFUyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoKTtcbiAgICBsZXQgc2NhbGFyID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIGlmIChtb2RGcm9tQnl0ZXMpIHNjYWxhciA9IG1vZChzY2FsYXIsIE9SREVSKTtcbiAgICBpZiAoIXNraXBWYWxpZGF0aW9uKVxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoc2NhbGFyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IG91dHNpZGUgb2YgcmFuZ2UgMC4uT1JERVInKTtcbiAgICAvLyBOT1RFOiB3ZSBkb24ndCB2YWxpZGF0ZSBzY2FsYXIgaGVyZSwgcGxlYXNlIHVzZSBpc1ZhbGlkLiBUaGlzIGRvbmUgc3VjaCB3YXkgYmVjYXVzZSBzb21lXG4gICAgLy8gcHJvdG9jb2wgbWF5IGFsbG93IG5vbi1yZWR1Y2VkIHNjYWxhciB0aGF0IHJlZHVjZWQgbGF0ZXIgb3IgY2hhbmdlZCBzb21lIG90aGVyIHdheS5cbiAgICByZXR1cm4gc2NhbGFyO1xuICB9XG4gIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgaW52ZXJ0QmF0Y2gobHN0OiBiaWdpbnRbXSk6IGJpZ2ludFtdIHtcbiAgICByZXR1cm4gRnBJbnZlcnRCYXRjaCh0aGlzLCBsc3QpO1xuICB9XG4gIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gIC8vIGFuZCBpdCdzIHVuY2xlYXIgd2hhdCB0byByZXR1cm4gaW4gdGhlcmUuXG4gIGNtb3YoYTogYmlnaW50LCBiOiBiaWdpbnQsIGNvbmRpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBiIDogYTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmaW5pdGUgZmllbGQuIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIDEuIERlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bC5cbiAqICogMi4gSWRlbnRpY2FsIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzLlxuICogKiAzLiBgT2JqZWN0LmZyZWV6ZWAuXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqXG4gKiBOb3RlIGFib3V0IGZpZWxkIHByb3BlcnRpZXM6XG4gKiAqIENIQVJBQ1RFUklTVElDIHAgPSBwcmltZSBudW1iZXIsIG51bWJlciBvZiBlbGVtZW50cyBpbiBtYWluIHN1Ymdyb3VwLlxuICogKiBPUkRFUiBxID0gc2ltaWxhciB0byBjb2ZhY3RvciBpbiBjdXJ2ZXMsIG1heSBiZSBjb21wb3NpdGUgYHEgPSBwXm1gLlxuICpcbiAqIEBwYXJhbSBPUkRFUiBmaWVsZCBvcmRlciwgcHJvYmFibHkgcHJpbWUsIG9yIGNvdWxkIGJlIGNvbXBvc2l0ZVxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZmF1bHQ6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVI6IGJpZ2ludCwgb3B0czogRmllbGRPcHRzID0ge30pOiBSZWFkb25seTxGcEZpZWxkPiB7XG4gIHJldHVybiBuZXcgX0ZpZWxkKE9SREVSLCBvcHRzKTtcbn1cblxuLy8gR2VuZXJpYyByYW5kb20gc2NhbGFyLCB3ZSBjYW4gZG8gc2FtZSBmb3Igb3RoZXIgZmllbGRzIGlmIHZpYSBGcDIubXVsKEZwMi5PTkUsIEZwMi5yYW5kb20pP1xuLy8gVGhpcyBhbGxvd3MgdW5zYWZlIG1ldGhvZHMgbGlrZSBpZ25vcmUgYmlhcyBvciB6ZXJvLiBUaGVzZSB1bnNhZmUsIGJ1dCBvZnRlbiB1c2VkIGluIGRpZmZlcmVudCBwcm90b2NvbHMgKGlmIGRldGVybWluaXN0aWMgUk5HKS5cbi8vIHdoaWNoIG1lYW4gd2UgY2Fubm90IGZvcmNlIHRoaXMgdmlhIG9wdHMuXG4vLyBOb3Qgc3VyZSB3aGF0IHRvIGRvIHdpdGggcmFuZG9tQnl0ZXMsIHdlIGNhbiBhY2NlcHQgaXQgaW5zaWRlIG9wdHMgaWYgd2FudGVkLlxuLy8gUHJvYmFibHkgbmVlZCB0byBleHBvcnQgZ2V0TWluSGFzaExlbmd0aCBzb21ld2hlcmU/XG4vLyByYW5kb20oYnl0ZXM/OiBVaW50OEFycmF5LCB1bnNhZmVBbGxvd1plcm8gPSBmYWxzZSwgdW5zYWZlQWxsb3dCaWFzID0gZmFsc2UpIHtcbi8vICAgY29uc3QgTEVOID0gIXVuc2FmZUFsbG93QmlhcyA/IGdldE1pbkhhc2hMZW5ndGgoT1JERVIpIDogQllURVM7XG4vLyAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSBieXRlcyA9IHJhbmRvbUJ5dGVzKExFTik7IC8vIF9vcHRzLnJhbmRvbUJ5dGVzP1xuLy8gICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4vLyAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbi8vICAgY29uc3QgcmVkdWNlZCA9IHVuc2FmZUFsbG93WmVybyA/IG1vZChudW0sIE9SREVSKSA6IG1vZChudW0sIE9SREVSIC0gXzFuKSArIF8xbjtcbi8vICAgcmV0dXJuIHJlZHVjZWQ7XG4vLyB9LFxuXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkPFQ+KEZwOiBJRmllbGQ8VD4sIGVsbTogVCk6IFQge1xuICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuPFQ+KEZwOiBJRmllbGQ8VD4sIGVsbTogVCk6IFQge1xuICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcjogYmlnaW50KTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JykgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXI6IGJpZ2ludCk6IG51bWJlciB7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG5cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLlBvaW50LkZuLk9SREVSKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5OiBVaW50OEFycmF5LCBmaWVsZE9yZGVyOiBiaWdpbnQsIGlzTEUgPSBmYWxzZSk6IFVpbnQ4QXJyYXkge1xuICBhYnl0ZXMoa2V5KTtcbiAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XG4gIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuIiwgIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlci5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB0eXBlIFNpZ25lciB9IGZyb20gJy4uL3V0aWxzLnRzJztcbmltcG9ydCB7IEZpZWxkLCBGcEludmVydEJhdGNoLCB2YWxpZGF0ZUZpZWxkLCB0eXBlIElGaWVsZCB9IGZyb20gJy4vbW9kdWxhci50cyc7XG5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuXG5leHBvcnQgdHlwZSBBZmZpbmVQb2ludDxUPiA9IHtcbiAgeDogVDtcbiAgeTogVDtcbn0gJiB7IFo/OiBuZXZlciB9O1xuXG4vLyBXZSBjYW4ndCBcImFic3RyYWN0IG91dFwiIGNvb3JkaW5hdGVzIChYLCBZLCBaOyBhbmQgVCBpbiBFZHdhcmRzKTogYXJndW1lbnQgbmFtZXMgb2YgY29uc3RydWN0b3Jcbi8vIGFyZSBub3QgYWNjZXNzaWJsZS4gU2VlIFR5cGVzY3JpcHQgZ2gtNTYwOTMsIGdoLTQxNTk0LlxuLy9cbi8vIFdlIGhhdmUgdG8gdXNlIHJlY3Vyc2l2ZSB0eXBlcywgc28gaXQgd2lsbCByZXR1cm4gYWN0dWFsIHBvaW50LCBub3QgY29uc3RhaW5lZCBgQ3VydmVQb2ludGAuXG4vLyBJZiwgYXQgYW55IHBvaW50LCBQIGlzIGBhbnlgLCBpdCB3aWxsIGVyYXNlIGFsbCB0eXBlcyBhbmQgcmVwbGFjZSBpdFxuLy8gd2l0aCBgYW55YCwgYmVjYXVzZSBvZiByZWN1cnNpb24sIGBhbnkgaW1wbGVtZW50cyBDdXJ2ZVBvaW50YCxcbi8vIGJ1dCB3ZSBsb3NlIGFsbCBjb25zdHJhaW5zIG9uIG1ldGhvZHMuXG5cbi8qKiBCYXNlIGludGVyZmFjZSBmb3IgYWxsIGVsbGlwdGljIGN1cnZlIFBvaW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VydmVQb2ludDxGLCBQIGV4dGVuZHMgQ3VydmVQb2ludDxGLCBQPj4ge1xuICAvKiogQWZmaW5lIHggY29vcmRpbmF0ZS4gRGlmZmVyZW50IGZyb20gcHJvamVjdGl2ZSAvIGV4dGVuZGVkIFggY29vcmRpbmF0ZS4gKi9cbiAgeDogRjtcbiAgLyoqIEFmZmluZSB5IGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIHByb2plY3RpdmUgLyBleHRlbmRlZCBZIGNvb3JkaW5hdGUuICovXG4gIHk6IEY7XG4gIFo/OiBGO1xuICBkb3VibGUoKTogUDtcbiAgbmVnYXRlKCk6IFA7XG4gIGFkZChvdGhlcjogUCk6IFA7XG4gIHN1YnRyYWN0KG90aGVyOiBQKTogUDtcbiAgZXF1YWxzKG90aGVyOiBQKTogYm9vbGVhbjtcbiAgbXVsdGlwbHkoc2NhbGFyOiBiaWdpbnQpOiBQO1xuICBhc3NlcnRWYWxpZGl0eSgpOiB2b2lkO1xuICBjbGVhckNvZmFjdG9yKCk6IFA7XG4gIGlzMCgpOiBib29sZWFuO1xuICBpc1RvcnNpb25GcmVlKCk6IGJvb2xlYW47XG4gIGlzU21hbGxPcmRlcigpOiBib29sZWFuO1xuICBtdWx0aXBseVVuc2FmZShzY2FsYXI6IGJpZ2ludCk6IFA7XG4gIC8qKlxuICAgKiBNYXNzaXZlbHkgc3BlZWRzIHVwIGBwLm11bHRpcGx5KG4pYCBieSB1c2luZyBwcmVjb21wdXRlIHRhYmxlcyAoY2FjaGluZykuIFNlZSB7QGxpbmsgd05BRn0uXG4gICAqIEBwYXJhbSBpc0xhenkgY2FsY3VsYXRlIGNhY2hlIG5vdy4gRGVmYXVsdCAodHJ1ZSkgZW5zdXJlcyBpdCdzIGRlZmVycmVkIHRvIGZpcnN0IGBtdWx0aXBseSgpYFxuICAgKi9cbiAgcHJlY29tcHV0ZSh3aW5kb3dTaXplPzogbnVtYmVyLCBpc0xhenk/OiBib29sZWFuKTogUDtcbiAgLyoqIENvbnZlcnRzIHBvaW50IHRvIDJEIHh5IGFmZmluZSBjb29yZGluYXRlcyAqL1xuICB0b0FmZmluZShpbnZlcnRlZFo/OiBGKTogQWZmaW5lUG9pbnQ8Rj47XG4gIHRvQnl0ZXMoKTogVWludDhBcnJheTtcbiAgdG9IZXgoKTogc3RyaW5nO1xufVxuXG4vKiogQmFzZSBpbnRlcmZhY2UgZm9yIGFsbCBlbGxpcHRpYyBjdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvcnMuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1cnZlUG9pbnRDb25zPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4+IHtcbiAgW1N5bWJvbC5oYXNJbnN0YW5jZV06IChpdGVtOiB1bmtub3duKSA9PiBib29sZWFuO1xuICBCQVNFOiBQO1xuICBaRVJPOiBQO1xuICAvKiogRmllbGQgZm9yIGJhc2ljIGN1cnZlIG1hdGggKi9cbiAgRnA6IElGaWVsZDxQX0Y8UD4+O1xuICAvKiogU2NhbGFyIGZpZWxkLCBmb3Igc2NhbGFycyBpbiBtdWx0aXBseSBhbmQgb3RoZXJzICovXG4gIEZuOiBJRmllbGQ8YmlnaW50PjtcbiAgLyoqIENyZWF0ZXMgcG9pbnQgZnJvbSB4LCB5LiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICBmcm9tQWZmaW5lKHA6IEFmZmluZVBvaW50PFBfRjxQPj4pOiBQO1xuICBmcm9tQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBQO1xuICBmcm9tSGV4KGhleDogc3RyaW5nKTogUDtcbn1cblxuLy8gVHlwZSBpbmZlcmVuY2UgaGVscGVyczogUEMgLSBQb2ludENvbnN0cnVjdG9yLCBQIC0gUG9pbnQsIEZwIC0gRmllbGQgZWxlbWVudFxuLy8gU2hvcnQgbmFtZXMsIGJlY2F1c2Ugd2UgdXNlIHRoZW0gYSBsb3QgaW4gcmVzdWx0IHR5cGVzOlxuLy8gKiB3ZSBjYW4ndCBkbyAnUCA9IEdldEN1cnZlUG9pbnQ8UEM+JzogdGhpcyBpcyBkZWZhdWx0IHZhbHVlIGFuZCBkb2Vzbid0IGNvbnN0cmFpbiBhbnl0aGluZ1xuLy8gKiB3ZSBjYW4ndCBkbyAndHlwZSBYID0gR2V0Q3VydmVQb2ludDxQQz4nOiBpdCB3b24ndCBiZSBhY2Nlc2libGUgZm9yIGFyZ3VtZW50cy9yZXR1cm4gdHlwZXNcbi8vICogYEN1cnZlUG9pbnRDb25zPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4+YCBjb25zdHJhaW50cyBmcm9tIGludGVyZmFjZSBkZWZpbml0aW9uXG4vLyAgIHdvbid0IHByb3BhZ2F0ZSwgaWYgYFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8YW55PmA6IHRoZSBQIHdvdWxkIGJlICdhbnknLCB3aGljaCBpcyBpbmNvcnJlY3Rcbi8vICogUEMgY291bGQgYmUgc3VwZXIgc3BlY2lmaWMgd2l0aCBzdXBlciBzcGVjaWZpYyBQLCB3aGljaCBpbXBsZW1lbnRzIEN1cnZlUG9pbnQ8YW55LCBQPi5cbi8vICAgdGhpcyBtZWFucyB3ZSBuZWVkIHRvIGRvIHN0dWZmIGxpa2Vcbi8vICAgYGZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIEN1cnZlUG9pbnQ8YW55LCBQPiwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPj4oYFxuLy8gICBpZiB3ZSB3YW50IHR5cGUgc2FmZXR5IGFyb3VuZCBQLCBvdGhlcndpc2UgUENfUDxQQz4gd2lsbCBiZSBhbnlcblxuLyoqIFJldHVybnMgRnAgdHlwZSBmcm9tIFBvaW50IChQX0Y8UD4gPT0gUC5GKSAqL1xuZXhwb3J0IHR5cGUgUF9GPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4+ID0gUCBleHRlbmRzIEN1cnZlUG9pbnQ8aW5mZXIgRiwgUD4gPyBGIDogbmV2ZXI7XG4vKiogUmV0dXJucyBGcCB0eXBlIGZyb20gUG9pbnRDb25zIChQQ19GPFBDPiA9PSBQQy5QLkYpICovXG5leHBvcnQgdHlwZSBQQ19GPFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8Q3VydmVQb2ludDxhbnksIGFueT4+PiA9IFBDWydGcCddWydaRVJPJ107XG4vKiogUmV0dXJucyBQb2ludCB0eXBlIGZyb20gUG9pbnRDb25zIChQQ19QPFBDPiA9PSBQQy5QKSAqL1xuZXhwb3J0IHR5cGUgUENfUDxQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPEN1cnZlUG9pbnQ8YW55LCBhbnk+Pj4gPSBQQ1snWkVSTyddO1xuXG4vLyBVZ2x5IGhhY2sgdG8gZ2V0IHByb3BlciB0eXBlIGluZmVyZW5jZSwgYmVjYXVzZSBpbiB0eXBlc2NyaXB0IGZhaWxzIHRvIGluZmVyIHJlc3Vyc2l2ZWx5LlxuLy8gVGhlIGhhY2sgYWxsb3dzIHRvIGRvIHVwIHRvIDEwIGNoYWluZWQgb3BlcmF0aW9ucyB3aXRob3V0IGFwcGx5aW5nIHR5cGUgZXJhc3VyZS5cbi8vXG4vLyBUeXBlcyB3aGljaCB3b24ndCB3b3JrOlxuLy8gKiBgQ3VydmVQb2ludENvbnM8Q3VydmVQb2ludDxhbnksIGFueT4+YCwgd2lsbCByZXR1cm4gYGFueWAgYWZ0ZXIgMSBvcGVyYXRpb25cbi8vICogYEN1cnZlUG9pbnRDb25zPGFueT46IFdlaWVyc3RyYXNzUG9pbnRDb25zPGJpZ2ludD4gZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxhbnk+ID0gZmFsc2VgXG4vLyAqIGBQIGV4dGVuZHMgQ3VydmVQb2ludCwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPmBcbi8vICAgICAqIEl0IGNhbid0IGluZmVyIFAgZnJvbSBQQyBhbG9uZVxuLy8gICAgICogVG9vIG1hbnkgcmVsYXRpb25zIGJldHdlZW4gRiwgUCAmIFBDXG4vLyAgICAgKiBJdCB3aWxsIGluZmVyIFAvRiBpZiBgYXJnOiBDdXJ2ZVBvaW50Q29uczxGLCBQPmAsIGJ1dCB3aWxsIGZhaWwgaWYgUEMgaXMgZ2VuZXJpY1xuLy8gICAgICogSXQgd2lsbCB3b3JrIGNvcnJlY3RseSBpZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IG9mIHR5cGUgUFxuLy8gICAgICogQnV0IGdlbmVyYWxseSwgd2UgZG9uJ3Qgd2FudCB0byBwYXJhbWV0cml6ZSBgQ3VydmVQb2ludENvbnNgIG92ZXIgYEZgOiBpdCB3aWxsIGNvbXBsaWNhdGVcbi8vICAgICAgIHR5cGVzLCBtYWtpbmcgdGhlbSB1bi1pbmZlcmFibGVcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHR5cGUgUENfQU5ZID0gQ3VydmVQb2ludENvbnM8XG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LCBhbnk+XG4gID4+Pj4+Pj4+PlxuPjtcblxuZXhwb3J0IGludGVyZmFjZSBDdXJ2ZUxlbmd0aHMge1xuICBzZWNyZXRLZXk/OiBudW1iZXI7XG4gIHB1YmxpY0tleT86IG51bWJlcjtcbiAgcHVibGljS2V5VW5jb21wcmVzc2VkPzogbnVtYmVyO1xuICBwdWJsaWNLZXlIYXNQcmVmaXg/OiBib29sZWFuO1xuICBzaWduYXR1cmU/OiBudW1iZXI7XG4gIHNlZWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIE1hcHBlcjxUPiA9IChpOiBUW10pID0+IFRbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZUN0PFQgZXh0ZW5kcyB7IG5lZ2F0ZTogKCkgPT4gVCB9Pihjb25kaXRpb246IGJvb2xlYW4sIGl0ZW06IFQpOiBUIHtcbiAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWjxQIGV4dGVuZHMgQ3VydmVQb2ludDxhbnksIFA+LCBQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPFA+PihcbiAgYzogUEMsXG4gIHBvaW50czogUFtdXG4pOiBQW10ge1xuICBjb25zdCBpbnZlcnRlZFpzID0gRnBJbnZlcnRCYXRjaChcbiAgICBjLkZwLFxuICAgIHBvaW50cy5tYXAoKHApID0+IHAuWiEpXG4gICk7XG4gIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBjLmZyb21BZmZpbmUocC50b0FmZmluZShpbnZlcnRlZFpzW2ldKSkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVcoVzogbnVtYmVyLCBiaXRzOiBudW1iZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdpbmRvdyBzaXplLCBleHBlY3RlZCBbMS4uJyArIGJpdHMgKyAnXSwgZ290IFc9JyArIFcpO1xufVxuXG4vKiogSW50ZXJuYWwgd05BRiBvcHRzIGZvciBzcGVjaWZpYyBXIGFuZCBzY2FsYXJCaXRzICovXG50eXBlIFdPcHRzID0ge1xuICB3aW5kb3dzOiBudW1iZXI7XG4gIHdpbmRvd1NpemU6IG51bWJlcjtcbiAgbWFzazogYmlnaW50O1xuICBtYXhOdW1iZXI6IG51bWJlcjtcbiAgc2hpZnRCeTogYmlnaW50O1xufTtcblxuZnVuY3Rpb24gY2FsY1dPcHRzKFc6IG51bWJlciwgc2NhbGFyQml0czogbnVtYmVyKTogV09wdHMge1xuICB2YWxpZGF0ZVcoVywgc2NhbGFyQml0cyk7XG4gIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIFc9OCAxMjguIE5vdCAyNTYsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gIGNvbnN0IG1heE51bWJlciA9IDIgKiogVzsgLy8gVz04IDI1NlxuICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH07XG59XG5cbmZ1bmN0aW9uIGNhbGNPZmZzZXRzKG46IGJpZ2ludCwgd2luZG93OiBudW1iZXIsIHdPcHRzOiBXT3B0cykge1xuICBjb25zdCB7IHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9ID0gd09wdHM7XG4gIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7IC8vIGV4dHJhY3QgVyBiaXRzLlxuICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG5cbiAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gIC8vIGNvbnN0IGhpZ2hlc3RCaXQgPSBOdW1iZXIobWFzayBeIChtYXNrID4+IDFuKSk7XG4gIC8vIGxldCB3Yml0czIgPSB3Yml0cyAtIDE7IC8vIHNraXAgemVyb1xuICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG5cbiAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICB3Yml0cyAtPSBtYXhOdW1iZXI7IC8vIC0zMiwgY2FuIGJlIG1heE51bWJlciAtIHdiaXRzLCBidXQgdGhlbiB3ZSBuZWVkIHRvIHNldCBpc05lZyBoZXJlLlxuICAgIG5leHROICs9IF8xbjsgLy8gKzI1NiAoY2FycnkpXG4gIH1cbiAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTdGFydCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gIGNvbnN0IGlzWmVybyA9IHdiaXRzID09PSAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBhIDA/XG4gIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgY29uc3QgaXNOZWdGID0gd2luZG93ICUgMiAhPT0gMDsgLy8gZmFrZSByYW5kb20gc3RhdGVtZW50IGZvciBub2lzZVxuICBjb25zdCBvZmZzZXRGID0gb2Zmc2V0U3RhcnQ7IC8vIGZha2Ugb2Zmc2V0IGZvciBub2lzZVxuICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzOiBhbnlbXSwgYzogYW55KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKSB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQgYXQgaW5kZXggJyArIGkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzOiBhbnlbXSwgZmllbGQ6IGFueSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICBzY2FsYXJzLmZvckVhY2goKHMsIGkpID0+IHtcbiAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICB9KTtcbn1cblxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXA8YW55LCBhbnlbXT4oKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcDxhbnksIG51bWJlcj4oKTtcblxuZnVuY3Rpb24gZ2V0VyhQOiBhbnkpOiBudW1iZXIge1xuICAvLyBUbyBkaXNhYmxlIHByZWNvbXB1dGVzOlxuICAvLyByZXR1cm4gMTtcbiAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG59XG5cbmZ1bmN0aW9uIGFzc2VydDAobjogYmlnaW50KTogdm9pZCB7XG4gIGlmIChuICE9PSBfMG4pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3TkFGJyk7XG59XG5cbi8qKlxuICogRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuICogVGFibGUgZ2VuZXJhdGlvbiB0YWtlcyAqKjMwTUIgb2YgcmFtIGFuZCAxMG1zIG9uIGhpZ2gtZW5kIENQVSoqLFxuICogYnV0IG1heSB0YWtlIG11Y2ggbG9uZ2VyIG9uIHNsb3cgZGV2aWNlcy4gQWN0dWFsIGdlbmVyYXRpb24gd2lsbCBoYXBwZW4gb25cbiAqIGZpcnN0IGNhbGwgb2YgYG11bHRpcGx5KClgLiBCeSBkZWZhdWx0LCBgQkFTRWAgcG9pbnQgaXMgcHJlY29tcHV0ZWQuXG4gKlxuICogU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4gKiBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbiAqIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuICogLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuICogLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuICogLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyBcdUQ4MzVcdURDNEEpICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyB3TkFGPFBDIGV4dGVuZHMgUENfQU5ZPiB7XG4gIHByaXZhdGUgcmVhZG9ubHkgQkFTRTogUENfUDxQQz47XG4gIHByaXZhdGUgcmVhZG9ubHkgWkVSTzogUENfUDxQQz47XG4gIHByaXZhdGUgcmVhZG9ubHkgRm46IFBDWydGbiddO1xuICByZWFkb25seSBiaXRzOiBudW1iZXI7XG5cbiAgLy8gUGFyYW1ldHJpemVkIHdpdGggYSBnaXZlbiBQb2ludCBjbGFzcyAobm90IGluZGl2aWR1YWwgcG9pbnQpXG4gIGNvbnN0cnVjdG9yKFBvaW50OiBQQywgYml0czogbnVtYmVyKSB7XG4gICAgdGhpcy5CQVNFID0gUG9pbnQuQkFTRTtcbiAgICB0aGlzLlpFUk8gPSBQb2ludC5aRVJPO1xuICAgIHRoaXMuRm4gPSBQb2ludC5GbjtcbiAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICB9XG5cbiAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gIF91bnNhZmVMYWRkZXIoZWxtOiBQQ19QPFBDPiwgbjogYmlnaW50LCBwOiBQQ19QPFBDPiA9IHRoaXMuWkVSTyk6IFBDX1A8UEM+IHtcbiAgICBsZXQgZDogUENfUDxQQz4gPSBlbG07XG4gICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgIGlmIChuICYgXzFuKSBwID0gcC5hZGQoZCk7XG4gICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgIG4gPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgKiAyXihcdUQ4MzVcdURDNEFcdTIyMTIxKSAqIChNYXRoLmNlaWwoXHVEODM1XHVEQzVCIC8gXHVEODM1XHVEQzRBKSArIDEpLCB3aGVyZTpcbiAgICogLSBcdUQ4MzVcdURDNEEgaXMgdGhlIHdpbmRvdyBzaXplXG4gICAqIC0gXHVEODM1XHVEQzVCIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAqIEBwYXJhbSBwb2ludCBQb2ludCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAqL1xuICBwcml2YXRlIHByZWNvbXB1dGVXaW5kb3cocG9pbnQ6IFBDX1A8UEM+LCBXOiBudW1iZXIpOiBQQ19QPFBDPltdIHtcbiAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCB0aGlzLmJpdHMpO1xuICAgIGNvbnN0IHBvaW50czogUENfUDxQQz5bXSA9IFtdO1xuICAgIGxldCBwOiBQQ19QPFBDPiA9IHBvaW50O1xuICAgIGxldCBiYXNlID0gcDtcbiAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgYmFzZSA9IHA7XG4gICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgIC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgfVxuICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgKiBNb3JlIGNvbXBhY3QgaW1wbGVtZW50YXRpb246XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgKi9cbiAgcHJpdmF0ZSB3TkFGKFc6IG51bWJlciwgcHJlY29tcHV0ZXM6IFBDX1A8UEM+W10sIG46IGJpZ2ludCk6IHsgcDogUENfUDxQQz47IGY6IFBDX1A8UEM+IH0ge1xuICAgIC8vIFNjYWxhciBzaG91bGQgYmUgc21hbGxlciB0aGFuIGZpZWxkIG9yZGVyXG4gICAgaWYgKCF0aGlzLkZuLmlzVmFsaWQobikpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXInKTtcbiAgICAvLyBBY2N1bXVsYXRvcnNcbiAgICBsZXQgcCA9IHRoaXMuWkVSTztcbiAgICBsZXQgZiA9IHRoaXMuQkFTRTtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgLy8gKG4gPT09IF8wbikgaXMgaGFuZGxlZCBhbmQgbm90IGVhcmx5LWV4aXRlZC4gaXNFdmVuIGFuZCBvZmZzZXRGIGFyZSB1c2VkIGZvciBub2lzZVxuICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgbiA9IG5leHROO1xuICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAvLyBiaXRzIGFyZSAwOiBhZGQgZ2FyYmFnZSB0byBmYWtlIHBvaW50XG4gICAgICAgIC8vIEltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleTogYWRkIHJhbmRvbSBcIm5vaXNlXCIgcG9pbnQgdG8gZi5cbiAgICAgICAgZiA9IGYuYWRkKG5lZ2F0ZUN0KGlzTmVnRiwgcHJlY29tcHV0ZXNbb2Zmc2V0Rl0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJpdHMgYXJlIDE6IGFkZCB0byByZXN1bHQgcG9pbnRcbiAgICAgICAgcCA9IHAuYWRkKG5lZ2F0ZUN0KGlzTmVnLCBwcmVjb21wdXRlc1tvZmZzZXRdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2VydDAobik7XG4gICAgLy8gUmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHM6IEpJVCB3b24ndCBlbGltaW5hdGUgZi5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICByZXR1cm4geyBwLCBmIH07XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBlYyB1bnNhZmUgKG5vbiBjb25zdC10aW1lKSBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICogQHJldHVybnMgcG9pbnRcbiAgICovXG4gIHByaXZhdGUgd05BRlVuc2FmZShcbiAgICBXOiBudW1iZXIsXG4gICAgcHJlY29tcHV0ZXM6IFBDX1A8UEM+W10sXG4gICAgbjogYmlnaW50LFxuICAgIGFjYzogUENfUDxQQz4gPSB0aGlzLlpFUk9cbiAgKTogUENfUDxQQz4ge1xuICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgIGlmIChuID09PSBfMG4pIGJyZWFrOyAvLyBFYXJseS1leGl0LCBza2lwIDAgdmFsdWVcbiAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZyB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICBuID0gbmV4dE47XG4gICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgIC8vIFdpbmRvdyBiaXRzIGFyZSAwOiBza2lwIHByb2Nlc3NpbmcuXG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3aW5kb3cuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHByZWNvbXB1dGVzW29mZnNldF07XG4gICAgICAgIGFjYyA9IGFjYy5hZGQoaXNOZWcgPyBpdGVtLm5lZ2F0ZSgpIDogaXRlbSk7IC8vIFJlLXVzaW5nIGFjYyBhbGxvd3MgdG8gc2F2ZSBhZGRzIGluIE1TTVxuICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnQwKG4pO1xuICAgIHJldHVybiBhY2M7XG4gIH1cblxuICBwcml2YXRlIGdldFByZWNvbXB1dGVzKFc6IG51bWJlciwgcG9pbnQ6IFBDX1A8UEM+LCB0cmFuc2Zvcm0/OiBNYXBwZXI8UENfUDxQQz4+KTogUENfUDxQQz5bXSB7XG4gICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChwb2ludCk7XG4gICAgaWYgKCFjb21wKSB7XG4gICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KHBvaW50LCBXKSBhcyBQQ19QPFBDPltdO1xuICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgLy8gRG9pbmcgdHJhbnNmb3JtIG91dHNpZGUgb2YgaWYgYnJpbmdzIDE1JSBwZXJmIGhpdFxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgY29tcCA9IHRyYW5zZm9ybShjb21wKTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQocG9pbnQsIGNvbXApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcDtcbiAgfVxuXG4gIGNhY2hlZChcbiAgICBwb2ludDogUENfUDxQQz4sXG4gICAgc2NhbGFyOiBiaWdpbnQsXG4gICAgdHJhbnNmb3JtPzogTWFwcGVyPFBDX1A8UEM+PlxuICApOiB7IHA6IFBDX1A8UEM+OyBmOiBQQ19QPFBDPiB9IHtcbiAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIHBvaW50LCB0cmFuc2Zvcm0pLCBzY2FsYXIpO1xuICB9XG5cbiAgdW5zYWZlKHBvaW50OiBQQ19QPFBDPiwgc2NhbGFyOiBiaWdpbnQsIHRyYW5zZm9ybT86IE1hcHBlcjxQQ19QPFBDPj4sIHByZXY/OiBQQ19QPFBDPik6IFBDX1A8UEM+IHtcbiAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgaWYgKFcgPT09IDEpIHJldHVybiB0aGlzLl91bnNhZmVMYWRkZXIocG9pbnQsIHNjYWxhciwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcbiAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSksIHNjYWxhciwgcHJldik7XG4gIH1cblxuICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICBjcmVhdGVDYWNoZShQOiBQQ19QPFBDPiwgVzogbnVtYmVyKTogdm9pZCB7XG4gICAgdmFsaWRhdGVXKFcsIHRoaXMuYml0cyk7XG4gICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gIH1cblxuICBoYXNDYWNoZShlbG06IFBDX1A8UEM+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGdldFcoZWxtKSAhPT0gMTtcbiAgfVxufVxuXG4vKipcbiAqIEVuZG9tb3JwaGlzbS1zcGVjaWZpYyBtdWx0aXBsaWNhdGlvbiBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gKiBDb3N0OiAxMjggZGJsLCAwLTI1NiBhZGRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsRW5kb1Vuc2FmZTxQIGV4dGVuZHMgQ3VydmVQb2ludDxhbnksIFA+LCBQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPFA+PihcbiAgUG9pbnQ6IFBDLFxuICBwb2ludDogUCxcbiAgazE6IGJpZ2ludCxcbiAgazI6IGJpZ2ludFxuKTogeyBwMTogUDsgcDI6IFAgfSB7XG4gIGxldCBhY2MgPSBwb2ludDtcbiAgbGV0IHAxID0gUG9pbnQuWkVSTztcbiAgbGV0IHAyID0gUG9pbnQuWkVSTztcbiAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgaWYgKGsxICYgXzFuKSBwMSA9IHAxLmFkZChhY2MpO1xuICAgIGlmIChrMiAmIF8xbikgcDIgPSBwMi5hZGQoYWNjKTtcbiAgICBhY2MgPSBhY2MuZG91YmxlKCk7XG4gICAgazEgPj49IF8xbjtcbiAgICBrMiA+Pj0gXzFuO1xuICB9XG4gIHJldHVybiB7IHAxLCBwMiB9O1xufVxuXG4vKipcbiAqIFBpcHBlbmdlciBhbGdvcml0aG0gZm9yIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgdGhhbiBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2Egc2VjcmV0IGtleXMgLyBiaWdpbnRzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlwcGVuZ2VyPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4sIFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8UD4+KFxuICBjOiBQQyxcbiAgcG9pbnRzOiBQW10sXG4gIHNjYWxhcnM6IGJpZ2ludFtdXG4pOiBQIHtcbiAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgLy8gVE9ETzpcbiAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gIGNvbnN0IGZpZWxkTiA9IGMuRm47XG4gIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qgc2xlbmd0aCA9IHNjYWxhcnMubGVuZ3RoO1xuICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICBsZXQgd2luZG93U2l6ZSA9IDE7IC8vIGJpdHNcbiAgaWYgKHdiaXRzID4gMTIpIHdpbmRvd1NpemUgPSB3Yml0cyAtIDM7XG4gIGVsc2UgaWYgKHdiaXRzID4gNCkgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgZWxzZSBpZiAod2JpdHMgPiAwKSB3aW5kb3dTaXplID0gMjtcbiAgY29uc3QgTUFTSyA9IGJpdE1hc2sod2luZG93U2l6ZSk7XG4gIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICBsZXQgc3VtID0gemVybztcbiAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgIGJ1Y2tldHMuZmlsbCh6ZXJvKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIE1BU0spO1xuICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICB9XG4gICAgbGV0IHJlc0kgPSB6ZXJvOyAvLyBub3QgdXNpbmcgdGhpcyB3aWxsIGRvIHNtYWxsIHNwZWVkLXVwLCBidXQgd2lsbCBsb3NlIGN0XG4gICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgfVxuICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgaWYgKGkgIT09IDApIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKSBzdW0gPSBzdW0uZG91YmxlKCk7XG4gIH1cbiAgcmV0dXJuIHN1bSBhcyBQO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmU8UCBleHRlbmRzIEN1cnZlUG9pbnQ8YW55LCBQPiwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPj4oXG4gIGM6IFBDLFxuICBwb2ludHM6IFBbXSxcbiAgd2luZG93U2l6ZTogbnVtYmVyXG4pOiAoc2NhbGFyczogYmlnaW50W10pID0+IFAge1xuICAvKipcbiAgICogUGVyZm9ybWFuY2UgQW5hbHlzaXMgb2YgV2luZG93LWJhc2VkIFByZWNvbXB1dGF0aW9uXG4gICAqXG4gICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAqIC0gU3RhbmRhcmQgcHJlY29tcHV0YXRpb24gcmVxdWlyZXM6XG4gICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciBcdTAwRDcgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICogICAtIFBsdXMgMjU1IHN1bW1hcnkgYWRkaXRpb25zID0gOCwxOTEgdG90YWwgb3BzXG4gICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICpcbiAgICogQ2h1bmtlZCBQcmVjb21wdXRhdGlvbiBBbmFseXNpczpcbiAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgKiAgIC0gMjU2IGRvdWJsaW5nc1xuICAgKiAgIC0gVG90YWw6ICgyNTUgXHUwMEQ3IDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgKlxuICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tXG4gICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICogICAgMTAtYml0ICAgfCAgIDEzLDgyNCAgICAgICAgfCAgIDEsMDIzXG4gICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgKlxuICAgKiBLZXkgQWR2YW50YWdlczpcbiAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgKiAgICAtIDE2IGNodW5rczogKDE2IFx1MDBENyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgKlxuICAgKiBMaW1pdGF0aW9uczpcbiAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgKiAtIFBlcmZvcm1hbmNlIGRlZ3JhZGVzIHdpdGggbGFyZ2VyIHNjYWxhciBjb3VudHM6XG4gICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgKi9cbiAgY29uc3QgZmllbGROID0gYy5GbjtcbiAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgY29uc3QgTUFTSyA9IGJpdE1hc2sod2luZG93U2l6ZSk7XG4gIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHA6IFApID0+IHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICByZXMucHVzaChhY2MpO1xuICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG4gIHJldHVybiAoc2NhbGFyczogYmlnaW50W10pOiBQID0+IHtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgIGxldCByZXMgPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICBpZiAocmVzICE9PSB6ZXJvKSBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKykgcmVzID0gcmVzLmRvdWJsZSgpO1xuICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChjaHVua3MgKiB3aW5kb3dTaXplIC0gKGkgKyAxKSAqIHdpbmRvd1NpemUpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgIGlmICghY3VycikgY29udGludWU7IC8vIHNraXAgemVybyBzY2FsYXJzIGNodW5rc1xuICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG5leHBvcnQgdHlwZSBWYWxpZEN1cnZlUGFyYW1zPFQ+ID0ge1xuICBwOiBiaWdpbnQ7XG4gIG46IGJpZ2ludDtcbiAgaDogYmlnaW50O1xuICBhOiBUO1xuICBiPzogVDtcbiAgZD86IFQ7XG4gIEd4OiBUO1xuICBHeTogVDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkPFQ+KG9yZGVyOiBiaWdpbnQsIGZpZWxkPzogSUZpZWxkPFQ+LCBpc0xFPzogYm9vbGVhbik6IElGaWVsZDxUPiB7XG4gIGlmIChmaWVsZCkge1xuICAgIGlmIChmaWVsZC5PUkRFUiAhPT0gb3JkZXIpIHRocm93IG5ldyBFcnJvcignRmllbGQuT1JERVIgbXVzdCBtYXRjaCBvcmRlcjogRnAgPT0gcCwgRm4gPT0gbicpO1xuICAgIHZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgIHJldHVybiBmaWVsZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRmllbGQob3JkZXIsIHsgaXNMRSB9KSBhcyB1bmtub3duIGFzIElGaWVsZDxUPjtcbiAgfVxufVxuZXhwb3J0IHR5cGUgRnBGbjxUPiA9IHsgRnA6IElGaWVsZDxUPjsgRm46IElGaWVsZDxiaWdpbnQ+IH07XG5cbi8qKiBWYWxpZGF0ZXMgQ1VSVkUgb3B0cyBhbmQgY3JlYXRlcyBmaWVsZHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZUZpZWxkczxUPihcbiAgdHlwZTogJ3dlaWVyc3RyYXNzJyB8ICdlZHdhcmRzJyxcbiAgQ1VSVkU6IFZhbGlkQ3VydmVQYXJhbXM8VD4sXG4gIGN1cnZlT3B0czogUGFydGlhbDxGcEZuPFQ+PiA9IHt9LFxuICBGcEZuTEU/OiBib29sZWFuXG4pOiBGcEZuPFQ+ICYgeyBDVVJWRTogVmFsaWRDdXJ2ZVBhcmFtczxUPiB9IHtcbiAgaWYgKEZwRm5MRSA9PT0gdW5kZWZpbmVkKSBGcEZuTEUgPSB0eXBlID09PSAnZWR3YXJkcyc7XG4gIGlmICghQ1VSVkUgfHwgdHlwZW9mIENVUlZFICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCB2YWxpZCAke3R5cGV9IENVUlZFIG9iamVjdGApO1xuICBmb3IgKGNvbnN0IHAgb2YgWydwJywgJ24nLCAnaCddIGFzIGNvbnN0KSB7XG4gICAgY29uc3QgdmFsID0gQ1VSVkVbcF07XG4gICAgaWYgKCEodHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgJiYgdmFsID4gXzBuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtwfSBtdXN0IGJlIHBvc2l0aXZlIGJpZ2ludGApO1xuICB9XG4gIGNvbnN0IEZwID0gY3JlYXRlRmllbGQoQ1VSVkUucCwgY3VydmVPcHRzLkZwLCBGcEZuTEUpO1xuICBjb25zdCBGbiA9IGNyZWF0ZUZpZWxkKENVUlZFLm4sIGN1cnZlT3B0cy5GbiwgRnBGbkxFKTtcbiAgY29uc3QgX2I6ICdiJyB8ICdkJyA9IHR5cGUgPT09ICd3ZWllcnN0cmFzcycgPyAnYicgOiAnZCc7XG4gIGNvbnN0IHBhcmFtcyA9IFsnR3gnLCAnR3knLCAnYScsIF9iXSBhcyBjb25zdDtcbiAgZm9yIChjb25zdCBwIG9mIHBhcmFtcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIUZwLmlzVmFsaWQoQ1VSVkVbcF0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgdmFsaWQgZmllbGQgZWxlbWVudCBvZiBDVVJWRS5GcGApO1xuICB9XG4gIENVUlZFID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCBDVVJWRSkpO1xuICByZXR1cm4geyBDVVJWRSwgRnAsIEZuIH07XG59XG5cbnR5cGUgS2V5Z2VuRm4gPSAoXG4gIHNlZWQ/OiBVaW50OEFycmF5LFxuICBpc0NvbXByZXNzZWQ/OiBib29sZWFuXG4pID0+IHsgc2VjcmV0S2V5OiBVaW50OEFycmF5OyBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkgfTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXlnZW4oXG4gIHJhbmRvbVNlY3JldEtleTogRnVuY3Rpb24sXG4gIGdldFB1YmxpY0tleTogU2lnbmVyWydnZXRQdWJsaWNLZXknXVxuKTogS2V5Z2VuRm4ge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5Z2VuKHNlZWQ/OiBVaW50OEFycmF5KSB7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gcmFuZG9tU2VjcmV0S2V5KHNlZWQpO1xuICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB9O1xuICB9O1xufVxuIiwgIi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYWhhc2gsIGNsZWFuLCB0eXBlIENIYXNoLCB0eXBlIEhhc2ggfSBmcm9tICcuL3V0aWxzLnRzJztcblxuLyoqIEludGVybmFsIGNsYXNzIGZvciBITUFDLiAqL1xuZXhwb3J0IGNsYXNzIF9ITUFDPFQgZXh0ZW5kcyBIYXNoPFQ+PiBpbXBsZW1lbnRzIEhhc2g8X0hNQUM8VD4+IHtcbiAgb0hhc2g6IFQ7XG4gIGlIYXNoOiBUO1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgcHJpdmF0ZSBmaW5pc2hlZCA9IGZhbHNlO1xuICBwcml2YXRlIGRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGhhc2g6IENIYXNoLCBrZXk6IFVpbnQ4QXJyYXkpIHtcbiAgICBhaGFzaChoYXNoKTtcbiAgICBhYnl0ZXMoa2V5LCB1bmRlZmluZWQsICdrZXknKTtcbiAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKSBhcyBUO1xuICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykgcGFkW2ldIF49IDB4MzY7XG4gICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCkgYXMgVDtcbiAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgY2xlYW4ocGFkKTtcbiAgfVxuICB1cGRhdGUoYnVmOiBVaW50OEFycmF5KTogdGhpcyB7XG4gICAgYWV4aXN0cyh0aGlzKTtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8ob3V0OiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgYWV4aXN0cyh0aGlzKTtcbiAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbiwgJ291dHB1dCcpO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIF9jbG9uZUludG8odG8/OiBfSE1BQzxUPik6IF9ITUFDPFQ+IHtcbiAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICB0byB8fD0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KTtcbiAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICB0byA9IHRvIGFzIHRoaXM7XG4gICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgIHJldHVybiB0bztcbiAgfVxuICBjbG9uZSgpOiBfSE1BQzxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmV4cG9ydCBjb25zdCBobWFjOiB7XG4gIChoYXNoOiBDSGFzaCwga2V5OiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5KTogVWludDhBcnJheTtcbiAgY3JlYXRlKGhhc2g6IENIYXNoLCBrZXk6IFVpbnQ4QXJyYXkpOiBfSE1BQzxhbnk+O1xufSA9IChoYXNoOiBDSGFzaCwga2V5OiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5KTogVWludDhBcnJheSA9PlxuICBuZXcgX0hNQUM8YW55PihoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2g6IENIYXNoLCBrZXk6IFVpbnQ4QXJyYXkpID0+IG5ldyBfSE1BQzxhbnk+KGhhc2gsIGtleSk7XG4iLCAiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogeVx1MDBCMiA9IHhcdTAwQjMgKyBheCArIGIuXG4gKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuICogb2Ygbm9taW5hdGl2ZSB0eXBlcyBpbiBUeXBlU2NyaXB0IGFuZCBpbnRlcmZhY2VzIG9ubHkgY2hlY2sgZm9yIHNoYXBlLCBzbyBpdCdzIGhhcmQgdG8gY3JlYXRlXG4gKiB1bmlxdWUgdHlwZSBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBXZSBjYW4gdXNlIGdlbmVyaWMgdHlwZXMgdmlhIHNvbWUgcGFyYW0sIGxpa2UgY3VydmUgb3B0cywgYnV0IHRoYXQgd291bGQ6XG4gKiAgICAgMS4gRW5hYmxlIGludGVyYWN0aW9uIGJldHdlZW4gYGN1cnZlKHBhcmFtcylgIGFuZCBgY3VydmUocGFyYW1zKWAgKGN1cnZlcyBvZiBzYW1lIHBhcmFtcylcbiAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuICogICAgIDIuIFBhcmFtcyBjYW4gYmUgZ2VuZXJpYyBhbmQgd2UgY2FuJ3QgZW5mb3JjZSB0aGVtIHRvIGJlIGNvbnN0YW50IHZhbHVlOlxuICogICAgIGlmIHNvbWVib2R5IGNyZWF0ZXMgY3VydmUgZnJvbSBub24tY29uc3RhbnQgcGFyYW1zLFxuICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG4gKlxuICogQHRvZG8gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNy5odG1sI3VuaXF1ZS1zeW1ib2xcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyBhcyBub2JsZUhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMuanMnO1xuaW1wb3J0IHsgYWhhc2ggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIGFib29sLFxuICBhYnl0ZXMsXG4gIGFJblJhbmdlLFxuICBiaXRMZW4sXG4gIGJpdE1hc2ssXG4gIGJ5dGVzVG9IZXgsXG4gIGJ5dGVzVG9OdW1iZXJCRSxcbiAgY29uY2F0Qnl0ZXMsXG4gIGNyZWF0ZUhtYWNEcmJnLFxuICBoZXhUb0J5dGVzLFxuICBpc0J5dGVzLFxuICBtZW1vaXplZCxcbiAgbnVtYmVyVG9IZXhVbnBhZGRlZCxcbiAgdmFsaWRhdGVPYmplY3QsXG4gIHJhbmRvbUJ5dGVzIGFzIHdjUmFuZG9tQnl0ZXMsXG4gIHR5cGUgQ0hhc2gsXG4gIHR5cGUgU2lnbmVyLFxufSBmcm9tICcuLi91dGlscy50cyc7XG5pbXBvcnQge1xuICBjcmVhdGVDdXJ2ZUZpZWxkcyxcbiAgY3JlYXRlS2V5Z2VuLFxuICBtdWxFbmRvVW5zYWZlLFxuICBuZWdhdGVDdCxcbiAgbm9ybWFsaXplWixcbiAgd05BRixcbiAgdHlwZSBBZmZpbmVQb2ludCxcbiAgdHlwZSBDdXJ2ZUxlbmd0aHMsXG4gIHR5cGUgQ3VydmVQb2ludCxcbiAgdHlwZSBDdXJ2ZVBvaW50Q29ucyxcbn0gZnJvbSAnLi9jdXJ2ZS50cyc7XG5pbXBvcnQge1xuICBGcEludmVydEJhdGNoLFxuICBnZXRNaW5IYXNoTGVuZ3RoLFxuICBtYXBIYXNoVG9GaWVsZCxcbiAgdmFsaWRhdGVGaWVsZCxcbiAgdHlwZSBJRmllbGQsXG59IGZyb20gJy4vbW9kdWxhci50cyc7XG5cbmV4cG9ydCB0eXBlIHsgQWZmaW5lUG9pbnQgfTtcblxudHlwZSBFbmRvQmFzaXMgPSBbW2JpZ2ludCwgYmlnaW50XSwgW2JpZ2ludCwgYmlnaW50XV07XG4vKipcbiAqIFdoZW4gV2VpZXJzdHJhc3MgY3VydmUgaGFzIGBhPTBgLCBpdCBiZWNvbWVzIEtvYmxpdHogY3VydmUuXG4gKiBLb2JsaXR6IGN1cnZlcyBhbGxvdyB1c2luZyAqKmVmZmljaWVudGx5LWNvbXB1dGFibGUgR0xWIGVuZG9tb3JwaGlzbSBcdTAzQzgqKi5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICpcbiAqIEVuZG9tb3JwaGlzbSBjb25zaXN0cyBvZiBiZXRhLCBsYW1iZGEgYW5kIHNwbGl0U2NhbGFyOlxuICpcbiAqIDEuIEdMViBlbmRvbW9ycGhpc20gXHUwM0M4IHRyYW5zZm9ybXMgYSBwb2ludDogYFAgPSAoeCwgeSkgXHUyMUE2IFx1MDNDOChQKSA9IChcdTAzQjJcdTAwQjd4IG1vZCBwLCB5KWBcbiAqIDIuIEdMViBzY2FsYXIgZGVjb21wb3NpdGlvbiB0cmFuc2Zvcm1zIGEgc2NhbGFyOiBgayBcdTIyNjEga1x1MjA4MSArIGtcdTIwODJcdTAwQjdcdTAzQkIgKG1vZCBuKWBcbiAqIDMuIFRoZW4gdGhlc2UgYXJlIGNvbWJpbmVkOiBga1x1MDBCN1AgPSBrXHUyMDgxXHUwMEI3UCArIGtcdTIwODJcdTAwQjdcdTAzQzgoUClgXG4gKiA0LiBUd28gMTI4LWJpdCBwb2ludC1ieS1zY2FsYXIgbXVsdGlwbGljYXRpb25zICsgb25lIHBvaW50IGFkZGl0aW9uIGlzIGZhc3RlciB0aGFuXG4gKiAgICBvbmUgMjU2LWJpdCBtdWx0aXBsaWNhdGlvbi5cbiAqXG4gKiB3aGVyZVxuICogKiBiZXRhOiBcdTAzQjIgXHUyMjA4IEZcdTIwOUEgd2l0aCBcdTAzQjJcdTAwQjMgPSAxLCBcdTAzQjIgXHUyMjYwIDFcbiAqICogbGFtYmRhOiBcdTAzQkIgXHUyMjA4IEZcdTIwOTkgd2l0aCBcdTAzQkJcdTAwQjMgPSAxLCBcdTAzQkIgXHUyMjYwIDFcbiAqICogc3BsaXRTY2FsYXIgZGVjb21wb3NlcyBrIFx1MjFBNiBrXHUyMDgxLCBrXHUyMDgyLCBieSB1c2luZyByZWR1Y2VkIGJhc2lzIHZlY3RvcnMuXG4gKiAgIEdhdXNzIGxhdHRpY2UgcmVkdWN0aW9uIGNhbGN1bGF0ZXMgdGhlbSBmcm9tIGluaXRpYWwgYmFzaXMgdmVjdG9ycyBgKG4sIDApLCAoLVx1MDNCQiwgMClgXG4gKlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2MvZW5kb21vcnBoaXNtLmpzYCBhbmRcbiAqIFtnaXN0XShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjYpLlxuICovXG5leHBvcnQgdHlwZSBFbmRvbW9ycGhpc21PcHRzID0ge1xuICBiZXRhOiBiaWdpbnQ7XG4gIGJhc2lzZXM/OiBFbmRvQmFzaXM7XG4gIHNwbGl0U2NhbGFyPzogKGs6IGJpZ2ludCkgPT4geyBrMW5lZzogYm9vbGVhbjsgazE6IGJpZ2ludDsgazJuZWc6IGJvb2xlYW47IGsyOiBiaWdpbnQgfTtcbn07XG4vLyBXZSBjb25zdHJ1Y3QgYmFzaXMgaW4gc3VjaCB3YXkgdGhhdCBkZW4gaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBlcXVhbHMgbiwgYnV0IG51bSBzaWduIGRlcGVuZHMgb24gYmFzaXMgKG5vdCBvbiBzZWNyZXQgdmFsdWUpXG5jb25zdCBkaXZOZWFyZXN0ID0gKG51bTogYmlnaW50LCBkZW46IGJpZ2ludCkgPT4gKG51bSArIChudW0gPj0gMCA/IGRlbiA6IC1kZW4pIC8gXzJuKSAvIGRlbjtcblxuZXhwb3J0IHR5cGUgU2NhbGFyRW5kb1BhcnRzID0geyBrMW5lZzogYm9vbGVhbjsgazE6IGJpZ2ludDsgazJuZWc6IGJvb2xlYW47IGsyOiBiaWdpbnQgfTtcblxuLyoqXG4gKiBTcGxpdHMgc2NhbGFyIGZvciBHTFYgZW5kb21vcnBoaXNtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NwbGl0RW5kb1NjYWxhcihrOiBiaWdpbnQsIGJhc2lzOiBFbmRvQmFzaXMsIG46IGJpZ2ludCk6IFNjYWxhckVuZG9QYXJ0cyB7XG4gIC8vIFNwbGl0IHNjYWxhciBpbnRvIHR3byBzdWNoIHRoYXQgcGFydCBpcyB+aGFsZiBiaXRzOiBgYWJzKHBhcnQpIDwgc3FydChOKWBcbiAgLy8gU2luY2UgcGFydCBjYW4gYmUgbmVnYXRpdmUsIHdlIG5lZWQgdG8gZG8gdGhpcyBvbiBwb2ludC5cbiAgLy8gVE9ETzogdmVyaWZ5U2NhbGFyIGZ1bmN0aW9uIHdoaWNoIGNvbnN1bWVzIGxhbWJkYVxuICBjb25zdCBbW2ExLCBiMV0sIFthMiwgYjJdXSA9IGJhc2lzO1xuICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAvLyB8azF8L3xrMnwgaXMgPCBzcXJ0KE4pLCBidXQgY2FuIGJlIG5lZ2F0aXZlLlxuICAvLyBJZiB3ZSBkbyBgazEgbW9kIE5gLCB3ZSdsbCBnZXQgYmlnIHNjYWxhciAoYD4gc3FydChOKWApOiBzbywgd2UgZG8gY2hlYXBlciBuZWdhdGlvbiBpbnN0ZWFkLlxuICBsZXQgazEgPSBrIC0gYzEgKiBhMSAtIGMyICogYTI7XG4gIGxldCBrMiA9IC1jMSAqIGIxIC0gYzIgKiBiMjtcbiAgY29uc3QgazFuZWcgPSBrMSA8IF8wbjtcbiAgY29uc3QgazJuZWcgPSBrMiA8IF8wbjtcbiAgaWYgKGsxbmVnKSBrMSA9IC1rMTtcbiAgaWYgKGsybmVnKSBrMiA9IC1rMjtcbiAgLy8gRG91YmxlIGNoZWNrIHRoYXQgcmVzdWx0aW5nIHNjYWxhciBsZXNzIHRoYW4gaGFsZiBiaXRzIG9mIE46IG90aGVyd2lzZSB3TkFGIHdpbGwgZmFpbC5cbiAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gb24gd3JvbmcgYmFzaXNlcy4gQWxzbywgbWF0aCBpbnNpZGUgaXMgdG9vIGNvbXBsZXggYW5kIEkgZG9uJ3QgdHJ1c3QgaXQuXG4gIGNvbnN0IE1BWF9OVU0gPSBiaXRNYXNrKE1hdGguY2VpbChiaXRMZW4obikgLyAyKSkgKyBfMW47IC8vIEhhbGYgYml0cyBvZiBOXG4gIGlmIChrMSA8IF8wbiB8fCBrMSA+PSBNQVhfTlVNIHx8IGsyIDwgXzBuIHx8IGsyID49IE1BWF9OVU0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyIChlbmRvbW9ycGhpc20pOiBmYWlsZWQsIGs9JyArIGspO1xuICB9XG4gIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG59XG5cbi8qKlxuICogT3B0aW9uIHRvIGVuYWJsZSBoZWRnZWQgc2lnbmF0dXJlcyB3aXRoIGltcHJvdmVkIHNlY3VyaXR5LlxuICpcbiAqICogUmFuZG9tbHkgZ2VuZXJhdGVkIGsgaXMgYmFkLCBiZWNhdXNlIGJyb2tlbiBDU1BSTkcgd291bGQgbGVhayBwcml2YXRlIGtleXMuXG4gKiAqIERldGVybWluaXN0aWMgayAoUkZDNjk3OSkgaXMgYmV0dGVyOyBidXQgaXMgc3VzcGVjdGlibGUgdG8gZmF1bHQgYXR0YWNrcy5cbiAqXG4gKiBXZSBhbGxvdyB1c2luZyB0ZWNobmlxdWUgZGVzY3JpYmVkIGluIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnLCBhLmsuYS4gYWRkaW5nIHJhbmRvbW5lc3NcbiAqIHRvIGRldGVybWluaXN0aWMgc2lnLiBJZiBDU1BSTkcgaXMgYnJva2VuICYgcmFuZG9tbmVzcyBpcyB3ZWFrLCBpdCB3b3VsZCBTVElMTCBiZSBhcyBzZWN1cmVcbiAqIGFzIG9yZGluYXJ5IHNpZyB3aXRob3V0IEV4dHJhRW50cm9weS5cbiAqXG4gKiAqIGB0cnVlYCBtZWFucyBcImZldGNoIGRhdGEsIGZyb20gQ1NQUk5HLCBpbmNvcnBvcmF0ZSBpdCBpbnRvIGsgZ2VuZXJhdGlvblwiXG4gKiAqIGBmYWxzZWAgbWVhbnMgXCJkaXNhYmxlIGV4dHJhIGVudHJvcHksIHVzZSBwdXJlbHkgZGV0ZXJtaW5pc3RpYyBrXCJcbiAqICogYFVpbnQ4QXJyYXlgIHBhc3NlZCBtZWFucyBcImluY29ycG9yYXRlIGZvbGxvd2luZyBkYXRhIGludG8gayBnZW5lcmF0aW9uXCJcbiAqXG4gKiBodHRwczovL3BhdWxtaWxsci5jb20vcG9zdHMvZGV0ZXJtaW5pc3RpYy1zaWduYXR1cmVzL1xuICovXG5leHBvcnQgdHlwZSBFQ0RTQUV4dHJhRW50cm9weSA9IGJvb2xlYW4gfCBVaW50OEFycmF5O1xuLyoqXG4gKiAtIGBjb21wYWN0YCBpcyB0aGUgZGVmYXVsdCBmb3JtYXRcbiAqIC0gYHJlY292ZXJlZGAgaXMgdGhlIHNhbWUgYXMgY29tcGFjdCwgYnV0IHdpdGggYW4gZXh0cmEgYnl0ZSBpbmRpY2F0aW5nIHJlY292ZXJ5IGJ5dGVcbiAqIC0gYGRlcmAgaXMgQVNOLjEgREVSIGVuY29kaW5nXG4gKi9cbmV4cG9ydCB0eXBlIEVDRFNBU2lnbmF0dXJlRm9ybWF0ID0gJ2NvbXBhY3QnIHwgJ3JlY292ZXJlZCcgfCAnZGVyJztcbi8qKlxuICogLSBgcHJlaGFzaGA6IChkZWZhdWx0OiB0cnVlKSBpbmRpY2F0ZXMgd2hldGhlciB0byBkbyBzaGEyNTYobWVzc2FnZSkuXG4gKiAgIFdoZW4gYSBjdXN0b20gaGFzaCBpcyB1c2VkLCBpdCBtdXN0IGJlIHNldCB0byBgZmFsc2VgLlxuICovXG5leHBvcnQgdHlwZSBFQ0RTQVJlY292ZXJPcHRzID0ge1xuICBwcmVoYXNoPzogYm9vbGVhbjtcbn07XG4vKipcbiAqIC0gYHByZWhhc2hgOiAoZGVmYXVsdDogdHJ1ZSkgaW5kaWNhdGVzIHdoZXRoZXIgdG8gZG8gc2hhMjU2KG1lc3NhZ2UpLlxuICogICBXaGVuIGEgY3VzdG9tIGhhc2ggaXMgdXNlZCwgaXQgbXVzdCBiZSBzZXQgdG8gYGZhbHNlYC5cbiAqIC0gYGxvd1NgOiAoZGVmYXVsdDogdHJ1ZSkgcHJvaGliaXRzIHNpZ25hdHVyZXMgd2hpY2ggaGF2ZSAoc2lnLnMgPj0gQ1VSVkUubi8ybikuXG4gKiAgIENvbXBhdGlibGUgd2l0aCBCVEMvRVRILiBTZXR0aW5nIGBsb3dTOiBmYWxzZWAgYWxsb3dzIHRvIGNyZWF0ZSBtYWxsZWFibGUgc2lnbmF0dXJlcyxcbiAqICAgd2hpY2ggaXMgZGVmYXVsdCBvcGVuc3NsIGJlaGF2aW9yLlxuICogICBOb24tbWFsbGVhYmxlIHNpZ25hdHVyZXMgY2FuIHN0aWxsIGJlIHN1Y2Nlc3NmdWxseSB2ZXJpZmllZCBpbiBvcGVuc3NsLlxuICogLSBgZm9ybWF0YDogKGRlZmF1bHQ6ICdjb21wYWN0JykgJ2NvbXBhY3QnIG9yICdyZWNvdmVyZWQnIHdpdGggcmVjb3ZlcnkgYnl0ZVxuICovXG5leHBvcnQgdHlwZSBFQ0RTQVZlcmlmeU9wdHMgPSB7XG4gIHByZWhhc2g/OiBib29sZWFuO1xuICBsb3dTPzogYm9vbGVhbjtcbiAgZm9ybWF0PzogRUNEU0FTaWduYXR1cmVGb3JtYXQ7XG59O1xuLyoqXG4gKiAtIGBwcmVoYXNoYDogKGRlZmF1bHQ6IHRydWUpIGluZGljYXRlcyB3aGV0aGVyIHRvIGRvIHNoYTI1NihtZXNzYWdlKS5cbiAqICAgV2hlbiBhIGN1c3RvbSBoYXNoIGlzIHVzZWQsIGl0IG11c3QgYmUgc2V0IHRvIGBmYWxzZWAuXG4gKiAtIGBsb3dTYDogKGRlZmF1bHQ6IHRydWUpIHByb2hpYml0cyBzaWduYXR1cmVzIHdoaWNoIGhhdmUgKHNpZy5zID49IENVUlZFLm4vMm4pLlxuICogICBDb21wYXRpYmxlIHdpdGggQlRDL0VUSC4gU2V0dGluZyBgbG93UzogZmFsc2VgIGFsbG93cyB0byBjcmVhdGUgbWFsbGVhYmxlIHNpZ25hdHVyZXMsXG4gKiAgIHdoaWNoIGlzIGRlZmF1bHQgb3BlbnNzbCBiZWhhdmlvci5cbiAqICAgTm9uLW1hbGxlYWJsZSBzaWduYXR1cmVzIGNhbiBzdGlsbCBiZSBzdWNjZXNzZnVsbHkgdmVyaWZpZWQgaW4gb3BlbnNzbC5cbiAqIC0gYGZvcm1hdGA6IChkZWZhdWx0OiAnY29tcGFjdCcpICdjb21wYWN0JyBvciAncmVjb3ZlcmVkJyB3aXRoIHJlY292ZXJ5IGJ5dGVcbiAqIC0gYGV4dHJhRW50cm9weWA6IChkZWZhdWx0OiBmYWxzZSkgY3JlYXRlcyBzaWdzIHdpdGggaW5jcmVhc2VkIHNlY3VyaXR5LCBzZWUge0BsaW5rIEVDRFNBRXh0cmFFbnRyb3B5fVxuICovXG5leHBvcnQgdHlwZSBFQ0RTQVNpZ25PcHRzID0ge1xuICBwcmVoYXNoPzogYm9vbGVhbjtcbiAgbG93Uz86IGJvb2xlYW47XG4gIGZvcm1hdD86IEVDRFNBU2lnbmF0dXJlRm9ybWF0O1xuICBleHRyYUVudHJvcHk/OiBFQ0RTQUV4dHJhRW50cm9weTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdDogc3RyaW5nKTogRUNEU0FTaWduYXR1cmVGb3JtYXQge1xuICBpZiAoIVsnY29tcGFjdCcsICdyZWNvdmVyZWQnLCAnZGVyJ10uaW5jbHVkZXMoZm9ybWF0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBmb3JtYXQgbXVzdCBiZSBcImNvbXBhY3RcIiwgXCJyZWNvdmVyZWRcIiwgb3IgXCJkZXJcIicpO1xuICByZXR1cm4gZm9ybWF0IGFzIEVDRFNBU2lnbmF0dXJlRm9ybWF0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ09wdHM8VCBleHRlbmRzIEVDRFNBU2lnbk9wdHMsIEQgZXh0ZW5kcyBSZXF1aXJlZDxFQ0RTQVNpZ25PcHRzPj4oXG4gIG9wdHM6IFQsXG4gIGRlZjogRFxuKTogUmVxdWlyZWQ8RUNEU0FTaWduT3B0cz4ge1xuICBjb25zdCBvcHRzbjogRUNEU0FTaWduT3B0cyA9IHt9O1xuICBmb3IgKGxldCBvcHROYW1lIG9mIE9iamVjdC5rZXlzKGRlZikpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb3B0c25bb3B0TmFtZV0gPSBvcHRzW29wdE5hbWVdID09PSB1bmRlZmluZWQgPyBkZWZbb3B0TmFtZV0gOiBvcHRzW29wdE5hbWVdO1xuICB9XG4gIGFib29sKG9wdHNuLmxvd1MhLCAnbG93UycpO1xuICBhYm9vbChvcHRzbi5wcmVoYXNoISwgJ3ByZWhhc2gnKTtcbiAgaWYgKG9wdHNuLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB2YWxpZGF0ZVNpZ0Zvcm1hdChvcHRzbi5mb3JtYXQpO1xuICByZXR1cm4gb3B0c24gYXMgUmVxdWlyZWQ8RUNEU0FTaWduT3B0cz47XG59XG5cbi8qKiBJbnN0YW5jZSBtZXRob2RzIGZvciAzRCBYWVogcHJvamVjdGl2ZSBwb2ludHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlaWVyc3RyYXNzUG9pbnQ8VD4gZXh0ZW5kcyBDdXJ2ZVBvaW50PFQsIFdlaWVyc3RyYXNzUG9pbnQ8VD4+IHtcbiAgLyoqIHByb2plY3RpdmUgWCBjb29yZGluYXRlLiBEaWZmZXJlbnQgZnJvbSBhZmZpbmUgeC4gKi9cbiAgcmVhZG9ubHkgWDogVDtcbiAgLyoqIHByb2plY3RpdmUgWSBjb29yZGluYXRlLiBEaWZmZXJlbnQgZnJvbSBhZmZpbmUgeS4gKi9cbiAgcmVhZG9ubHkgWTogVDtcbiAgLyoqIHByb2plY3RpdmUgeiBjb29yZGluYXRlICovXG4gIHJlYWRvbmx5IFo6IFQ7XG4gIC8qKiBhZmZpbmUgeCBjb29yZGluYXRlLiBEaWZmZXJlbnQgZnJvbSBwcm9qZWN0aXZlIFguICovXG4gIGdldCB4KCk6IFQ7XG4gIC8qKiBhZmZpbmUgeSBjb29yZGluYXRlLiBEaWZmZXJlbnQgZnJvbSBwcm9qZWN0aXZlIFkuICovXG4gIGdldCB5KCk6IFQ7XG4gIC8qKiBFbmNvZGVzIHBvaW50IHVzaW5nIElFRUUgUDEzNjMgKERFUikgZW5jb2RpbmcuIEZpcnN0IGJ5dGUgaXMgMi8zLzQuIERlZmF1bHQgPSBpc0NvbXByZXNzZWQuICovXG4gIHRvQnl0ZXMoaXNDb21wcmVzc2VkPzogYm9vbGVhbik6IFVpbnQ4QXJyYXk7XG4gIHRvSGV4KGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pOiBzdHJpbmc7XG59XG5cbi8qKiBTdGF0aWMgbWV0aG9kcyBmb3IgM0QgWFlaIHByb2plY3RpdmUgcG9pbnRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBXZWllcnN0cmFzc1BvaW50Q29uczxUPiBleHRlbmRzIEN1cnZlUG9pbnRDb25zPFdlaWVyc3RyYXNzUG9pbnQ8VD4+IHtcbiAgLyoqIERvZXMgTk9UIHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyB2YWxpZC4gVXNlIGAuYXNzZXJ0VmFsaWRpdHkoKWAuICovXG4gIG5ldyAoWDogVCwgWTogVCwgWjogVCk6IFdlaWVyc3RyYXNzUG9pbnQ8VD47XG4gIENVUlZFKCk6IFdlaWVyc3RyYXNzT3B0czxUPjtcbn1cblxuLyoqXG4gKiBXZWllcnN0cmFzcyBjdXJ2ZSBvcHRpb25zLlxuICpcbiAqICogcDogcHJpbWUgY2hhcmFjdGVyaXN0aWMgKG9yZGVyKSBvZiBmaW5pdGUgZmllbGQsIGluIHdoaWNoIGFyaXRobWV0aWNzIGlzIGRvbmVcbiAqICogbjogb3JkZXIgb2YgcHJpbWUgc3ViZ3JvdXAgYS5rLmEgdG90YWwgYW1vdW50IG9mIHZhbGlkIGN1cnZlIHBvaW50c1xuICogKiBoOiBjb2ZhY3RvciwgdXN1YWxseSAxLiBoKm4gaXMgZ3JvdXAgb3JkZXI7IG4gaXMgc3ViZ3JvdXAgb3JkZXJcbiAqICogYTogZm9ybXVsYSBwYXJhbSwgbXVzdCBiZSBpbiBmaWVsZCBvZiBwXG4gKiAqIGI6IGZvcm11bGEgcGFyYW0sIG11c3QgYmUgaW4gZmllbGQgb2YgcFxuICogKiBHeDogeCBjb29yZGluYXRlIG9mIGdlbmVyYXRvciBwb2ludCBhLmsuYS4gYmFzZSBwb2ludFxuICogKiBHeTogeSBjb29yZGluYXRlIG9mIGdlbmVyYXRvciBwb2ludFxuICovXG5leHBvcnQgdHlwZSBXZWllcnN0cmFzc09wdHM8VD4gPSBSZWFkb25seTx7XG4gIHA6IGJpZ2ludDtcbiAgbjogYmlnaW50O1xuICBoOiBiaWdpbnQ7XG4gIGE6IFQ7XG4gIGI6IFQ7XG4gIEd4OiBUO1xuICBHeTogVDtcbn0+O1xuXG4vLyBXaGVuIGEgY29mYWN0b3IgIT0gMSwgdGhlcmUgY2FuIGJlIGFuIGVmZmVjdGl2ZSBtZXRob2RzIHRvOlxuLy8gMS4gRGV0ZXJtaW5lIHdoZXRoZXIgYSBwb2ludCBpcyB0b3JzaW9uLWZyZWVcbi8vIDIuIENsZWFyIHRvcnNpb24gY29tcG9uZW50XG5leHBvcnQgdHlwZSBXZWllcnN0cmFzc0V4dHJhT3B0czxUPiA9IFBhcnRpYWw8e1xuICBGcDogSUZpZWxkPFQ+O1xuICBGbjogSUZpZWxkPGJpZ2ludD47XG4gIGFsbG93SW5maW5pdHlQb2ludDogYm9vbGVhbjtcbiAgZW5kbzogRW5kb21vcnBoaXNtT3B0cztcbiAgaXNUb3JzaW9uRnJlZTogKGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LCBwb2ludDogV2VpZXJzdHJhc3NQb2ludDxUPikgPT4gYm9vbGVhbjtcbiAgY2xlYXJDb2ZhY3RvcjogKGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LCBwb2ludDogV2VpZXJzdHJhc3NQb2ludDxUPikgPT4gV2VpZXJzdHJhc3NQb2ludDxUPjtcbiAgZnJvbUJ5dGVzOiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IEFmZmluZVBvaW50PFQ+O1xuICB0b0J5dGVzOiAoXG4gICAgYzogV2VpZXJzdHJhc3NQb2ludENvbnM8VD4sXG4gICAgcG9pbnQ6IFdlaWVyc3RyYXNzUG9pbnQ8VD4sXG4gICAgaXNDb21wcmVzc2VkOiBib29sZWFuXG4gICkgPT4gVWludDhBcnJheTtcbn0+O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBhIFdlaWVyc3RyYXNzIGN1cnZlLlxuICpcbiAqICogbG93UzogKGRlZmF1bHQ6IHRydWUpIHdoZXRoZXIgcHJvZHVjZWQgLyB2ZXJpZmllZCBzaWduYXR1cmVzIG9jY3VweSBsb3cgaGFsZiBvZiBlY2RzYU9wdHMucC4gUHJldmVudHMgbWFsbGVhYmlsaXR5LlxuICogKiBobWFjOiAoZGVmYXVsdDogbm9ibGUtaGFzaGVzIGhtYWMpIGZ1bmN0aW9uLCB3b3VsZCBiZSB1c2VkIHRvIGluaXQgaG1hYy1kcmJnIGZvciBrIGdlbmVyYXRpb24uXG4gKiAqIHJhbmRvbUJ5dGVzOiAoZGVmYXVsdDogd2ViY3J5cHRvIG9zLWxldmVsIENTUFJORykgY3VzdG9tIG1ldGhvZCBmb3IgZmV0Y2hpbmcgc2VjdXJlIHJhbmRvbW5lc3MuXG4gKiAqIGJpdHMyaW50LCBiaXRzMmludF9tb2ROOiB1c2VkIGluIHNpZ3MsIHNvbWV0aW1lcyBvdmVycmlkZGVuIGJ5IGN1cnZlc1xuICovXG5leHBvcnQgdHlwZSBFQ0RTQU9wdHMgPSBQYXJ0aWFsPHtcbiAgbG93UzogYm9vbGVhbjtcbiAgaG1hYzogKGtleTogVWludDhBcnJheSwgbWVzc2FnZTogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aD86IG51bWJlcikgPT4gVWludDhBcnJheTtcbiAgYml0czJpbnQ6IChieXRlczogVWludDhBcnJheSkgPT4gYmlnaW50O1xuICBiaXRzMmludF9tb2ROOiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IGJpZ2ludDtcbn0+O1xuXG4vKipcbiAqIEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuIGludGVyZmFjZS5cbiAqIFByb3ZpZGVzIGtleWdlbiwgc2VjcmV0LXRvLXB1YmxpYyBjb252ZXJzaW9uLCBjYWxjdWxhdGluZyBzaGFyZWQgc2VjcmV0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFQ0RIIHtcbiAga2V5Z2VuOiAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IHsgc2VjcmV0S2V5OiBVaW50OEFycmF5OyBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkgfTtcbiAgZ2V0UHVibGljS2V5OiAoc2VjcmV0S2V5OiBVaW50OEFycmF5LCBpc0NvbXByZXNzZWQ/OiBib29sZWFuKSA9PiBVaW50OEFycmF5O1xuICBnZXRTaGFyZWRTZWNyZXQ6IChcbiAgICBzZWNyZXRLZXlBOiBVaW50OEFycmF5LFxuICAgIHB1YmxpY0tleUI6IFVpbnQ4QXJyYXksXG4gICAgaXNDb21wcmVzc2VkPzogYm9vbGVhblxuICApID0+IFVpbnQ4QXJyYXk7XG4gIFBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxiaWdpbnQ+O1xuICB1dGlsczoge1xuICAgIGlzVmFsaWRTZWNyZXRLZXk6IChzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpID0+IGJvb2xlYW47XG4gICAgaXNWYWxpZFB1YmxpY0tleTogKHB1YmxpY0tleTogVWludDhBcnJheSwgaXNDb21wcmVzc2VkPzogYm9vbGVhbikgPT4gYm9vbGVhbjtcbiAgICByYW5kb21TZWNyZXRLZXk6IChzZWVkPzogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgfTtcbiAgbGVuZ3RoczogQ3VydmVMZW5ndGhzO1xufVxuXG4vKipcbiAqIEVDRFNBIGludGVyZmFjZS5cbiAqIE9ubHkgc3VwcG9ydGVkIGZvciBwcmltZSBmaWVsZHMsIG5vdCBGcDIgKGV4dGVuc2lvbiBmaWVsZHMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVDRFNBIGV4dGVuZHMgRUNESCB7XG4gIHNpZ246IChtZXNzYWdlOiBVaW50OEFycmF5LCBzZWNyZXRLZXk6IFVpbnQ4QXJyYXksIG9wdHM/OiBFQ0RTQVNpZ25PcHRzKSA9PiBVaW50OEFycmF5O1xuICB2ZXJpZnk6IChcbiAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXksXG4gICAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXksXG4gICAgb3B0cz86IEVDRFNBVmVyaWZ5T3B0c1xuICApID0+IGJvb2xlYW47XG4gIHJlY292ZXJQdWJsaWNLZXkoc2lnbmF0dXJlOiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5LCBvcHRzPzogRUNEU0FSZWNvdmVyT3B0cyk6IFVpbnQ4QXJyYXk7XG4gIFNpZ25hdHVyZTogRUNEU0FTaWduYXR1cmVDb25zO1xufVxuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgc3VwZXIobSk7XG4gIH1cbn1cbmV4cG9ydCB0eXBlIElERVIgPSB7XG4gIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICBFcnI6IHR5cGVvZiBERVJFcnI7XG4gIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgX3Rsdjoge1xuICAgIGVuY29kZTogKHRhZzogbnVtYmVyLCBkYXRhOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICBkZWNvZGUodGFnOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB7IHY6IFVpbnQ4QXJyYXk7IGw6IFVpbnQ4QXJyYXkgfTtcbiAgfTtcbiAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICBfaW50OiB7XG4gICAgZW5jb2RlKG51bTogYmlnaW50KTogc3RyaW5nO1xuICAgIGRlY29kZShkYXRhOiBVaW50OEFycmF5KTogYmlnaW50O1xuICB9O1xuICB0b1NpZyhoZXg6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiB7IHI6IGJpZ2ludDsgczogYmlnaW50IH07XG4gIGhleEZyb21TaWcoc2lnOiB7IHI6IGJpZ2ludDsgczogYmlnaW50IH0pOiBzdHJpbmc7XG59O1xuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVI6IElERVIgPSB7XG4gIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICBFcnI6IERFUkVycixcbiAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICBfdGx2OiB7XG4gICAgZW5jb2RlOiAodGFnOiBudW1iZXIsIGRhdGE6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgIGNvbnN0IGxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDBiMTAwMF8wMDAwKSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyBudW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAwYjEwMDBfMDAwMCkgOiAnJztcbiAgICAgIGNvbnN0IHQgPSBudW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XG4gICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgfSxcbiAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICBkZWNvZGUodGFnOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB7IHY6IFVpbnQ4QXJyYXk7IGw6IFVpbnQ4QXJyYXkgfSB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZykgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMGIxMDAwXzAwMDApOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgIGlmICghaXNMb25nKSBsZW5ndGggPSBmaXJzdDtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAwYjAxMTFfMTExMTtcbiAgICAgICAgaWYgKCFsZW5MZW4pIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGlmIChsZW5MZW4gPiA0KSB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbikgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKSB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcykgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgIGlmIChsZW5ndGggPCAxMjgpIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgIH0sXG4gIH0sXG4gIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgX2ludDoge1xuICAgIGVuY29kZShudW06IGJpZ2ludCk6IHN0cmluZyB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgaWYgKG51bSA8IF8wbikgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgbGV0IGhleCA9IG51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG4gICAgZGVjb2RlKGRhdGE6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgIGlmIChkYXRhWzBdICYgMGIxMDAwXzAwMDApIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMGIxMDAwXzAwMDApKVxuICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICByZXR1cm4gYnl0ZXNUb051bWJlckJFKGRhdGEpO1xuICAgIH0sXG4gIH0sXG4gIHRvU2lnKGJ5dGVzOiBVaW50OEFycmF5KTogeyByOiBiaWdpbnQ7IHM6IGJpZ2ludCB9IHtcbiAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgY29uc3QgZGF0YSA9IGFieXRlcyhieXRlcywgdW5kZWZpbmVkLCAnc2lnbmF0dXJlJyk7XG4gICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgIGlmIChzZXFMZWZ0Qnl0ZXMubGVuZ3RoKSB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICBjb25zdCB7IHY6IHNCeXRlcywgbDogc0xlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCByTGVmdEJ5dGVzKTtcbiAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgcmV0dXJuIHsgcjogaW50LmRlY29kZShyQnl0ZXMpLCBzOiBpbnQuZGVjb2RlKHNCeXRlcykgfTtcbiAgfSxcbiAgaGV4RnJvbVNpZyhzaWc6IHsgcjogYmlnaW50OyBzOiBiaWdpbnQgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gREVSO1xuICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcbiAgICBjb25zdCBzZXEgPSBycyArIHNzO1xuICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gIH0sXG59O1xuXG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5cbi8qKlxuICogQ3JlYXRlcyB3ZWllcnN0cmFzcyBQb2ludCBjb25zdHJ1Y3RvciwgYmFzZWQgb24gc3BlY2lmaWVkIGN1cnZlIG9wdGlvbnMuXG4gKlxuICogU2VlIHtAbGluayBXZWllcnN0cmFzc09wdHN9LlxuICpcbiAqIEBleGFtcGxlXG5gYGBqc1xuY29uc3Qgb3B0cyA9IHtcbiAgcDogMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZhYzczbixcbiAgbjogMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDFiOGZhMTZkZmFiOWFjYTE2YjZiM24sXG4gIGg6IDFuLFxuICBhOiAwbixcbiAgYjogN24sXG4gIEd4OiAweDNiNGMzODJjZTM3YWExOTJhNDAxOWU3NjMwMzZmNGY1ZGQ0ZDdlYmJuLFxuICBHeTogMHg5MzhjZjkzNTMxOGZkY2VkNmJjMjgyODY1MzE3MzNjM2YwM2M0ZmVlbixcbn07XG5jb25zdCBzZWNwMTYwazFfUG9pbnQgPSB3ZWllcnN0cmFzcyhvcHRzKTtcbmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3M8VD4oXG4gIHBhcmFtczogV2VpZXJzdHJhc3NPcHRzPFQ+LFxuICBleHRyYU9wdHM6IFdlaWVyc3RyYXNzRXh0cmFPcHRzPFQ+ID0ge31cbik6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+IHtcbiAgY29uc3QgdmFsaWRhdGVkID0gY3JlYXRlQ3VydmVGaWVsZHMoJ3dlaWVyc3RyYXNzJywgcGFyYW1zLCBleHRyYU9wdHMpO1xuICBjb25zdCB7IEZwLCBGbiB9ID0gdmFsaWRhdGVkO1xuICBsZXQgQ1VSVkUgPSB2YWxpZGF0ZWQuQ1VSVkUgYXMgV2VpZXJzdHJhc3NPcHRzPFQ+O1xuICBjb25zdCB7IGg6IGNvZmFjdG9yLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gIHZhbGlkYXRlT2JqZWN0KFxuICAgIGV4dHJhT3B0cyxcbiAgICB7fSxcbiAgICB7XG4gICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgIGVuZG86ICdvYmplY3QnLFxuICAgIH1cbiAgKTtcblxuICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgaWYgKGVuZG8pIHtcbiAgICAvLyB2YWxpZGF0ZU9iamVjdChlbmRvLCB7IGJldGE6ICdiaWdpbnQnLCBzcGxpdFNjYWxhcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICBpZiAoIUZwLmlzMChDVVJWRS5hKSB8fCB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fCAhQXJyYXkuaXNBcnJheShlbmRvLmJhc2lzZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJiYXNpc2VzXCI6IGFycmF5Jyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGVuZ3RocyA9IGdldFdMZW5ndGhzKEZwLCBGbik7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IEZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgSUVFRSBQMTM2MyBwb2ludCBlbmNvZGluZ1xuICBmdW5jdGlvbiBwb2ludFRvQnl0ZXMoXG4gICAgX2M6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LFxuICAgIHBvaW50OiBXZWllcnN0cmFzc1BvaW50PFQ+LFxuICAgIGlzQ29tcHJlc3NlZDogYm9vbGVhblxuICApOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgY29uc3QgYnggPSBGcC50b0J5dGVzKHgpO1xuICAgIGFib29sKGlzQ29tcHJlc3NlZCwgJ2lzQ29tcHJlc3NlZCcpO1xuICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKTtcbiAgICAgIGNvbnN0IGhhc0V2ZW5ZID0gIUZwLmlzT2RkISh5KTtcbiAgICAgIHJldHVybiBjb25jYXRCeXRlcyhwcHJlZml4KGhhc0V2ZW5ZKSwgYngpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoVWludDhBcnJheS5vZigweDA0KSwgYngsIEZwLnRvQnl0ZXMoeSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludEZyb21CeXRlcyhieXRlczogVWludDhBcnJheSkge1xuICAgIGFieXRlcyhieXRlcywgdW5kZWZpbmVkLCAnUG9pbnQnKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogY29tcCwgcHVibGljS2V5VW5jb21wcmVzc2VkOiB1bmNvbXAgfSA9IGxlbmd0aHM7IC8vIGUuZy4gZm9yIDMyLWJ5dGU6IDMzLCA2NVxuICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgIC8vIE5vIGFjdHVhbCB2YWxpZGF0aW9uIGlzIGRvbmUgaGVyZTogdXNlIC5hc3NlcnRWYWxpZGl0eSgpXG4gICAgaWYgKGxlbmd0aCA9PT0gY29tcCAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsKTtcbiAgICAgIGlmICghRnAuaXNWYWxpZCh4KSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgd3JvbmcgeCcpO1xuICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5XHUwMEIyID0geFx1MDBCMyArIGF4ICsgYlxuICAgICAgbGV0IHk6IFQ7XG4gICAgICB0cnkge1xuICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5XHUwMEIyIF4gKHArMSkvNFxuICAgICAgfSBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUsIHNxcnQgZXJyb3InICsgZXJyKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKTtcbiAgICAgIGNvbnN0IGV2ZW5ZID0gRnAuaXNPZGQhKHkpO1xuICAgICAgY29uc3QgZXZlbkggPSAoaGVhZCAmIDEpID09PSAxOyAvLyBFQ0RTQS1zcGVjaWZpY1xuICAgICAgaWYgKGV2ZW5IICE9PSBldmVuWSkgeSA9IEZwLm5lZyh5KTtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5jb21wICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgIC8vIFRPRE86IG1vcmUgY2hlY2tzXG4gICAgICBjb25zdCBMID0gRnAuQllURVM7XG4gICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgTCkpO1xuICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEwsIEwgKiAyKSk7XG4gICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBiYWQgcG9pbnQ6IGdvdCBsZW5ndGggJHtsZW5ndGh9LCBleHBlY3RlZCBjb21wcmVzc2VkPSR7Y29tcH0gb3IgdW5jb21wcmVzc2VkPSR7dW5jb21wfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZW5jb2RlUG9pbnQgPSBleHRyYU9wdHMudG9CeXRlcyB8fCBwb2ludFRvQnl0ZXM7XG4gIGNvbnN0IGRlY29kZVBvaW50ID0gZXh0cmFPcHRzLmZyb21CeXRlcyB8fCBwb2ludEZyb21CeXRlcztcbiAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4OiBUKTogVCB7XG4gICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4XHUwMEIyICogeFxuICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgQ1VSVkUuYSkpLCBDVVJWRS5iKTsgLy8geFx1MDBCMyArIGEgKiB4ICsgYlxuICB9XG5cbiAgLy8gVE9ETzogbW92ZSB0b3AtbGV2ZWxcbiAgLyoqIENoZWNrcyB3aGV0aGVyIGVxdWF0aW9uIGhvbGRzIGZvciBnaXZlbiB4LCB5OiB5XHUwMEIyID09IHhcdTAwQjMgKyBheCArIGIgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZFhZKHg6IFQsIHk6IFQpOiBib29sZWFuIHtcbiAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5XHUwMEIyXG4gICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4XHUwMEIzICsgYXggKyBiXG4gICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgLy8gVGVzdCAxOiBlcXVhdGlvbiB5XHUwMEIyID0geFx1MDBCMyArIGF4ICsgYiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICBpZiAoIWlzVmFsaWRYWShDVVJWRS5HeCwgQ1VSVkUuR3kpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuXG4gIC8vIFRlc3QgMjogZGlzY3JpbWluYW50IFx1MDM5NCBwYXJ0IHNob3VsZCBiZSBub24temVybzogNGFcdTAwQjMgKyAyN2JcdTAwQjIgIT0gMC5cbiAgLy8gR3VhcmFudGVlcyBjdXJ2ZSBpcyBnZW51cy0xLCBzbW9vdGggKG5vbi1zaW5ndWxhcikuXG4gIGNvbnN0IF80YTMgPSBGcC5tdWwoRnAucG93KENVUlZFLmEsIF8zbiksIF80bik7XG4gIGNvbnN0IF8yN2IyID0gRnAubXVsKEZwLnNxcihDVVJWRS5iKSwgQmlnSW50KDI3KSk7XG4gIGlmIChGcC5pczAoRnAuYWRkKF80YTMsIF8yN2IyKSkpIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogYSBvciBiJyk7XG5cbiAgLyoqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgRnAuT1JERVIuICovXG4gIGZ1bmN0aW9uIGFjb29yZCh0aXRsZTogc3RyaW5nLCBuOiBULCBiYW5aZXJvID0gZmFsc2UpIHtcbiAgICBpZiAoIUZwLmlzVmFsaWQobikgfHwgKGJhblplcm8gJiYgRnAuaXMwKG4pKSkgdGhyb3cgbmV3IEVycm9yKGBiYWQgcG9pbnQgY29vcmRpbmF0ZSAke3RpdGxlfWApO1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyOiB1bmtub3duKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpIHRocm93IG5ldyBFcnJvcignV2VpZXJzdHJhc3MgUG9pbnQgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0RW5kb1NjYWxhck4oazogYmlnaW50KSB7XG4gICAgaWYgKCFlbmRvIHx8ICFlbmRvLmJhc2lzZXMpIHRocm93IG5ldyBFcnJvcignbm8gZW5kbycpO1xuICAgIHJldHVybiBfc3BsaXRFbmRvU2NhbGFyKGssIGVuZG8uYmFzaXNlcywgRm4uT1JERVIpO1xuICB9XG5cbiAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuXG4gIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gIC8vIChYLCBZLCBaKSBcdTIyMEIgKHg9WC9aLCB5PVkvWilcbiAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHA6IFBvaW50LCBpej86IFQpOiBBZmZpbmVQb2ludDxUPiA9PiB7XG4gICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICBpZiAoRnAuZXFsKFosIEZwLk9ORSkpIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgaWYgKGl6ID09IG51bGwpIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KFopO1xuICAgIGNvbnN0IHggPSBGcC5tdWwoWCwgaXopO1xuICAgIGNvbnN0IHkgPSBGcC5tdWwoWSwgaXopO1xuICAgIGNvbnN0IHp6ID0gRnAubXVsKFosIGl6KTtcbiAgICBpZiAoaXMwKSByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfSk7XG4gIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocDogUG9pbnQpID0+IHtcbiAgICBpZiAocC5pczAoKSkge1xuICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgaWYgKGV4dHJhT3B0cy5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLlkpKSByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgIH1cbiAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBmaWVsZCBlbGVtZW50cycpO1xuICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZmluaXNoRW5kbyhcbiAgICBlbmRvQmV0YTogRW5kb21vcnBoaXNtT3B0c1snYmV0YSddLFxuICAgIGsxcDogUG9pbnQsXG4gICAgazJwOiBQb2ludCxcbiAgICBrMW5lZzogYm9vbGVhbixcbiAgICBrMm5lZzogYm9vbGVhblxuICApIHtcbiAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5YLCBlbmRvQmV0YSksIGsycC5ZLCBrMnAuWik7XG4gICAgazFwID0gbmVnYXRlQ3QoazFuZWcsIGsxcCk7XG4gICAgazJwID0gbmVnYXRlQ3QoazJuZWcsIGsycCk7XG4gICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOihYLCBZLCBaKSBcdTIyMEIgKHg9WC9aLCB5PVkvWikuXG4gICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KS5cbiAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgKi9cbiAgY2xhc3MgUG9pbnQgaW1wbGVtZW50cyBXZWllcnN0cmFzc1BvaW50PFQ+IHtcbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IEJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IFpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIC8vIG1hdGggZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRm4gPSBGbjtcblxuICAgIHJlYWRvbmx5IFg6IFQ7XG4gICAgcmVhZG9ubHkgWTogVDtcbiAgICByZWFkb25seSBaOiBUO1xuXG4gICAgLyoqIERvZXMgTk9UIHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyB2YWxpZC4gVXNlIGAuYXNzZXJ0VmFsaWRpdHkoKWAuICovXG4gICAgY29uc3RydWN0b3IoWDogVCwgWTogVCwgWjogVCkge1xuICAgICAgdGhpcy5YID0gYWNvb3JkKCd4JywgWCk7XG4gICAgICB0aGlzLlkgPSBhY29vcmQoJ3knLCBZLCB0cnVlKTtcbiAgICAgIHRoaXMuWiA9IGFjb29yZCgneicsIFopO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgQ1VSVkUoKTogV2VpZXJzdHJhc3NPcHRzPFQ+IHtcbiAgICAgIHJldHVybiBDVVJWRTtcbiAgICB9XG5cbiAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwOiBBZmZpbmVQb2ludDxUPik6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludCkgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKSByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5KTogUG9pbnQge1xuICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZGVjb2RlUG9pbnQoYWJ5dGVzKGJ5dGVzLCB1bmRlZmluZWQsICdwb2ludCcpKSk7XG4gICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICByZXR1cm4gUDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUhleChoZXg6IHN0cmluZyk6IFBvaW50IHtcbiAgICAgIHJldHVybiBQb2ludC5mcm9tQnl0ZXMoaGV4VG9CeXRlcyhoZXgpKTtcbiAgICB9XG5cbiAgICBnZXQgeCgpOiBUIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICB9XG4gICAgZ2V0IHkoKTogVCB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2luZG93U2l6ZVxuICAgICAqIEBwYXJhbSBpc0xhenkgdHJ1ZSB3aWxsIGRlZmVyIHRhYmxlIGNvbXB1dGF0aW9uIHVudGlsIHRoZSBmaXJzdCBtdWx0aXBsaWNhdGlvblxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplOiBudW1iZXIgPSA4LCBpc0xhenkgPSB0cnVlKTogUG9pbnQge1xuICAgICAgd25hZi5jcmVhdGVDYWNoZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgIGlmICghaXNMYXp5KSB0aGlzLm11bHRpcGx5KF8zbik7IC8vIHJhbmRvbSBudW1iZXJcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJldHVybiBgdGhpc2BcbiAgICAvKiogQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi4gKi9cbiAgICBhc3NlcnRWYWxpZGl0eSgpOiB2b2lkIHtcbiAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICB9XG5cbiAgICBoYXNFdmVuWSgpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKCFGcC5pc09kZCkgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICB9XG5cbiAgICAvKiogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci4gKi9cbiAgICBlcXVhbHMob3RoZXI6IFBvaW50KTogYm9vbGVhbiB7XG4gICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyIH0gPSBvdGhlcjtcbiAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgIH1cblxuICAgIC8qKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy4gKi9cbiAgICBuZWdhdGUoKTogUG9pbnQge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLlgsIEZwLm5lZyh0aGlzLlkpLCB0aGlzLlopO1xuICAgIH1cblxuICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICBkb3VibGUoKSB7XG4gICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICB9XG5cbiAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgIGFkZChvdGhlcjogUG9pbnQpOiBQb2ludCB7XG4gICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyIH0gPSBvdGhlcjtcbiAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICB9XG5cbiAgICBzdWJ0cmFjdChvdGhlcjogUG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuXG4gICAgaXMwKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICovXG4gICAgbXVsdGlwbHkoc2NhbGFyOiBiaWdpbnQpOiBQb2ludCB7XG4gICAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlJyk7IC8vIDAgaXMgaW52YWxpZFxuICAgICAgbGV0IHBvaW50OiBQb2ludCwgZmFrZTogUG9pbnQ7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgIGNvbnN0IG11bCA9IChuOiBiaWdpbnQpID0+IHduYWYuY2FjaGVkKHRoaXMsIG4sIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSk7XG4gICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRFbmRvU2NhbGFyTihzY2FsYXIpO1xuICAgICAgICBjb25zdCB7IHA6IGsxcCwgZjogazFmIH0gPSBtdWwoazEpO1xuICAgICAgICBjb25zdCB7IHA6IGsycCwgZjogazJmIH0gPSBtdWwoazIpO1xuICAgICAgICBmYWtlID0gazFmLmFkZChrMmYpO1xuICAgICAgICBwb2ludCA9IGZpbmlzaEVuZG8oZW5kby5iZXRhLCBrMXAsIGsycCwgazFuZWcsIGsybmVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gbXVsKHNjYWxhcik7XG4gICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgZmFrZSA9IGY7XG4gICAgICB9XG4gICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3BvaW50LCBmYWtlXSlbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICogYW4gZXhwb3NlZCBzZWNyZXQga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAqL1xuICAgIG11bHRpcGx5VW5zYWZlKHNjOiBiaWdpbnQpOiBQb2ludCB7XG4gICAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICAgIGNvbnN0IHAgPSB0aGlzIGFzIFBvaW50O1xuICAgICAgaWYgKCFGbi5pc1ZhbGlkKHNjKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlJyk7IC8vIDAgaXMgdmFsaWRcbiAgICAgIGlmIChzYyA9PT0gXzBuIHx8IHAuaXMwKCkpIHJldHVybiBQb2ludC5aRVJPOyAvLyAwXG4gICAgICBpZiAoc2MgPT09IF8xbikgcmV0dXJuIHA7IC8vIDFcbiAgICAgIGlmICh3bmFmLmhhc0NhY2hlKHRoaXMpKSByZXR1cm4gdGhpcy5tdWx0aXBseShzYyk7IC8vIHByZWNvbXB1dGVzXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIG1ldGhvZCBmb3IgZG91YmxlIHNjYWxhciBtdWx0aXBsaWNhdGlvbiAoYVAgKyBiUSk6XG4gICAgICAvLyBFdmVuIHdpdGggdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2ssIGl0J3MgMzUlIHNsb3dlciB0aGFuIG5hXHUwMEVGdmUgbXVsK2FkZC5cbiAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IHNwbGl0RW5kb1NjYWxhck4oc2MpO1xuICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gbXVsRW5kb1Vuc2FmZShQb2ludCwgcCwgazEsIGsyKTsgLy8gMzAlIGZhc3RlciB2cyB3bmFmLnVuc2FmZVxuICAgICAgICByZXR1cm4gZmluaXNoRW5kbyhlbmRvLmJldGEsIHAxLCBwMiwgazFuZWcsIGsybmVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3bmFmLnVuc2FmZShwLCBzYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBpbnZlcnRlZFogWl4tMSAoaW52ZXJ0ZWQgemVybykgLSBvcHRpb25hbCwgcHJlY29tcHV0YXRpb24gaXMgdXNlZnVsIGZvciBpbnZlcnRCYXRjaFxuICAgICAqL1xuICAgIHRvQWZmaW5lKGludmVydGVkWj86IFQpOiBBZmZpbmVQb2ludDxUPiB7XG4gICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGludmVydGVkWik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgUG9pbnQgaXMgZnJlZSBvZiB0b3JzaW9uIGVsZW1lbnRzIChpcyBpbiBwcmltZSBzdWJncm91cCkuXG4gICAgICogQWx3YXlzIHRvcnNpb24tZnJlZSBmb3IgY29mYWN0b3I9MSBjdXJ2ZXMuXG4gICAgICovXG4gICAgaXNUb3JzaW9uRnJlZSgpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHsgaXNUb3JzaW9uRnJlZSB9ID0gZXh0cmFPcHRzO1xuICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBDVVJWRV9PUkRFUikuaXMwKCk7XG4gICAgfVxuXG4gICAgY2xlYXJDb2ZhY3RvcigpOiBQb2ludCB7XG4gICAgICBjb25zdCB7IGNsZWFyQ29mYWN0b3IgfSA9IGV4dHJhT3B0cztcbiAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKSByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICBpZiAoY2xlYXJDb2ZhY3RvcikgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpIGFzIFBvaW50O1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuICAgIH1cblxuICAgIGlzU21hbGxPcmRlcigpOiBib29sZWFuIHtcbiAgICAgIC8vIGNhbiB3ZSB1c2UgdGhpcy5jbGVhckNvZmFjdG9yKCk/XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgfVxuXG4gICAgdG9CeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKTogVWludDhBcnJheSB7XG4gICAgICBhYm9vbChpc0NvbXByZXNzZWQsICdpc0NvbXByZXNzZWQnKTtcbiAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgIHJldHVybiBlbmNvZGVQb2ludChQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICB9XG5cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgPFBvaW50ICR7dGhpcy5pczAoKSA/ICdaRVJPJyA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYml0cyA9IEZuLkJJVFM7XG4gIGNvbnN0IHduYWYgPSBuZXcgd05BRihQb2ludCwgZXh0cmFPcHRzLmVuZG8gPyBNYXRoLmNlaWwoYml0cyAvIDIpIDogYml0cyk7XG4gIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICByZXR1cm4gUG9pbnQ7XG59XG5cbi8qKiBNZXRob2RzIG9mIEVDRFNBIHNpZ25hdHVyZSBpbnN0YW5jZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRUNEU0FTaWduYXR1cmUge1xuICByZWFkb25seSByOiBiaWdpbnQ7XG4gIHJlYWRvbmx5IHM6IGJpZ2ludDtcbiAgcmVhZG9ubHkgcmVjb3Zlcnk/OiBudW1iZXI7XG4gIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5OiBudW1iZXIpOiBFQ0RTQVNpZ25hdHVyZSAmIHsgcmVhZG9ubHkgcmVjb3Zlcnk6IG51bWJlciB9O1xuICBoYXNIaWdoUygpOiBib29sZWFuO1xuICByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoOiBVaW50OEFycmF5KTogV2VpZXJzdHJhc3NQb2ludDxiaWdpbnQ+O1xuICB0b0J5dGVzKGZvcm1hdD86IHN0cmluZyk6IFVpbnQ4QXJyYXk7XG4gIHRvSGV4KGZvcm1hdD86IHN0cmluZyk6IHN0cmluZztcbn1cbi8qKiBNZXRob2RzIG9mIEVDRFNBIHNpZ25hdHVyZSBjb25zdHJ1Y3Rvci4gKi9cbmV4cG9ydCB0eXBlIEVDRFNBU2lnbmF0dXJlQ29ucyA9IHtcbiAgbmV3IChyOiBiaWdpbnQsIHM6IGJpZ2ludCwgcmVjb3Zlcnk/OiBudW1iZXIpOiBFQ0RTQVNpZ25hdHVyZTtcbiAgZnJvbUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5LCBmb3JtYXQ/OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCk6IEVDRFNBU2lnbmF0dXJlO1xuICBmcm9tSGV4KGhleDogc3RyaW5nLCBmb3JtYXQ/OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCk6IEVDRFNBU2lnbmF0dXJlO1xufTtcblxuLy8gUG9pbnRzIHN0YXJ0IHdpdGggYnl0ZSAweDAyIHdoZW4geSBpcyBldmVuOyBvdGhlcndpc2UgMHgwM1xuZnVuY3Rpb24gcHByZWZpeChoYXNFdmVuWTogYm9vbGVhbik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVWludDhBcnJheS5vZihoYXNFdmVuWSA/IDB4MDIgOiAweDAzKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW88VD4oXG4gIEZwOiBJRmllbGQ8VD4sXG4gIFo6IFRcbik6ICh1OiBULCB2OiBUKSA9PiB7IGlzVmFsaWQ6IGJvb2xlYW47IHZhbHVlOiBUIH0ge1xuICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgbGV0IGwgPSBfMG47XG4gIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKSBsICs9IF8xbjtcbiAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgbGV0IHNxcnRSYXRpbyA9ICh1OiBULCB2OiBUKTogeyBpc1ZhbGlkOiBib29sZWFuOyB2YWx1ZTogVCB9ID0+IHtcbiAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICB9O1xuICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICBzcXJ0UmF0aW8gPSAodTogVCwgdjogVCkgPT4ge1xuICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgfTtcbiAgfVxuICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVPFQ+KFxuICBGcDogSUZpZWxkPFQ+LFxuICBvcHRzOiB7XG4gICAgQTogVDtcbiAgICBCOiBUO1xuICAgIFo6IFQ7XG4gIH1cbik6ICh1OiBUKSA9PiB7IHg6IFQ7IHk6IFQgfSB7XG4gIHZhbGlkYXRlRmllbGQoRnApO1xuICBjb25zdCB7IEEsIEIsIFogfSA9IG9wdHM7XG4gIGlmICghRnAuaXNWYWxpZChBKSB8fCAhRnAuaXNWYWxpZChCKSB8fCAhRnAuaXNWYWxpZChaKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgWik7XG4gIGlmICghRnAuaXNPZGQpIHRocm93IG5ldyBFcnJvcignRmllbGQgZG9lcyBub3QgaGF2ZSAuaXNPZGQoKScpO1xuICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICByZXR1cm4gKHU6IFQpOiB7IHg6IFQ7IHk6IFQgfSA9PiB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgIHR2MyA9IEZwLm11bCh0djMsIEIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgIHR2NCA9IEZwLmNtb3YoWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgIHR2NCA9IEZwLm11bCh0djQsIEEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgdHY1ID0gRnAubXVsKHR2NiwgQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgdHY1ID0gRnAubXVsKHR2NiwgQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgY29uc3QgZTEgPSBGcC5pc09kZCEodSkgPT09IEZwLmlzT2RkISh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgY29uc3QgdHY0X2ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICB4ID0gRnAubXVsKHgsIHR2NF9pbnYpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0V0xlbmd0aHM8VD4oRnA6IElGaWVsZDxUPiwgRm46IElGaWVsZDxiaWdpbnQ+KSB7XG4gIHJldHVybiB7XG4gICAgc2VjcmV0S2V5OiBGbi5CWVRFUyxcbiAgICBwdWJsaWNLZXk6IDEgKyBGcC5CWVRFUyxcbiAgICBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IDEgKyAyICogRnAuQllURVMsXG4gICAgcHVibGljS2V5SGFzUHJlZml4OiB0cnVlLFxuICAgIHNpZ25hdHVyZTogMiAqIEZuLkJZVEVTLFxuICB9O1xufVxuXG4vKipcbiAqIFNvbWV0aW1lcyB1c2VycyBvbmx5IG5lZWQgZ2V0UHVibGljS2V5LCBnZXRTaGFyZWRTZWNyZXQsIGFuZCBzZWNyZXQga2V5IGhhbmRsaW5nLlxuICogVGhpcyBoZWxwZXIgZW5zdXJlcyBubyBzaWduYXR1cmUgZnVuY3Rpb25hbGl0eSBpcyBwcmVzZW50LiBMZXNzIGNvZGUsIHNtYWxsZXIgYnVuZGxlIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlY2RoKFxuICBQb2ludDogV2VpZXJzdHJhc3NQb2ludENvbnM8YmlnaW50PixcbiAgZWNkaE9wdHM6IHsgcmFuZG9tQnl0ZXM/OiAoYnl0ZXNMZW5ndGg/OiBudW1iZXIpID0+IFVpbnQ4QXJyYXkgfSA9IHt9XG4pOiBFQ0RIIHtcbiAgY29uc3QgeyBGbiB9ID0gUG9pbnQ7XG4gIGNvbnN0IHJhbmRvbUJ5dGVzXyA9IGVjZGhPcHRzLnJhbmRvbUJ5dGVzIHx8IHdjUmFuZG9tQnl0ZXM7XG4gIGNvbnN0IGxlbmd0aHMgPSBPYmplY3QuYXNzaWduKGdldFdMZW5ndGhzKFBvaW50LkZwLCBGbiksIHsgc2VlZDogZ2V0TWluSGFzaExlbmd0aChGbi5PUkRFUikgfSk7XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFNlY3JldEtleShzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbnVtID0gRm4uZnJvbUJ5dGVzKHNlY3JldEtleSk7XG4gICAgICByZXR1cm4gRm4uaXNWYWxpZE5vdDAobnVtKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5OiBVaW50OEFycmF5LCBpc0NvbXByZXNzZWQ/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBwdWJsaWNLZXk6IGNvbXAsIHB1YmxpY0tleVVuY29tcHJlc3NlZCB9ID0gbGVuZ3RocztcbiAgICB0cnkge1xuICAgICAgY29uc3QgbCA9IHB1YmxpY0tleS5sZW5ndGg7XG4gICAgICBpZiAoaXNDb21wcmVzc2VkID09PSB0cnVlICYmIGwgIT09IGNvbXApIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IGZhbHNlICYmIGwgIT09IHB1YmxpY0tleVVuY29tcHJlc3NlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuICEhUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHNlY3JldCBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJhbmRvbVNlY3JldEtleShzZWVkID0gcmFuZG9tQnl0ZXNfKGxlbmd0aHMuc2VlZCkpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoYWJ5dGVzKHNlZWQsIGxlbmd0aHMuc2VlZCwgJ3NlZWQnKSwgRm4uT1JERVIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgc2VjcmV0IGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgc2VjcmV0IGtleS5cbiAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleTogVWludDhBcnJheSwgaXNDb21wcmVzc2VkID0gdHJ1ZSk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KEZuLmZyb21CeXRlcyhzZWNyZXRLZXkpKS50b0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gIH1cblxuICAvKipcbiAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAqL1xuICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbTogVWludDhBcnJheSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXksIHB1YmxpY0tleVVuY29tcHJlc3NlZCB9ID0gbGVuZ3RocztcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCgnX2xlbmd0aHMnIGluIEZuICYmIEZuLl9sZW5ndGhzKSB8fCBzZWNyZXRLZXkgPT09IHB1YmxpY0tleSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBsID0gYWJ5dGVzKGl0ZW0sIHVuZGVmaW5lZCwgJ2tleScpLmxlbmd0aDtcbiAgICByZXR1cm4gbCA9PT0gcHVibGljS2V5IHx8IGwgPT09IHB1YmxpY0tleVVuY29tcHJlc3NlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gc2VjcmV0IGtleSBBIGFuZCBwdWJsaWMga2V5IEIuXG4gICAqIENoZWNrczogMSkgc2VjcmV0IGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQoXG4gICAgc2VjcmV0S2V5QTogVWludDhBcnJheSxcbiAgICBwdWJsaWNLZXlCOiBVaW50OEFycmF5LFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgKTogVWludDhBcnJheSB7XG4gICAgaWYgKGlzUHJvYlB1YihzZWNyZXRLZXlBKSA9PT0gdHJ1ZSkgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgIGlmIChpc1Byb2JQdWIocHVibGljS2V5QikgPT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgcyA9IEZuLmZyb21CeXRlcyhzZWNyZXRLZXlBKTtcbiAgICBjb25zdCBiID0gUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleUIpOyAvLyBjaGVja3MgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgcmV0dXJuIGIubXVsdGlwbHkocykudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICB9XG5cbiAgY29uc3QgdXRpbHMgPSB7XG4gICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICBpc1ZhbGlkUHVibGljS2V5LFxuICAgIHJhbmRvbVNlY3JldEtleSxcbiAgfTtcbiAgY29uc3Qga2V5Z2VuID0gY3JlYXRlS2V5Z2VuKHJhbmRvbVNlY3JldEtleSwgZ2V0UHVibGljS2V5KTtcblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCBrZXlnZW4sIFBvaW50LCB1dGlscywgbGVuZ3RocyB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIEVDRFNBIHNpZ25pbmcgaW50ZXJmYWNlIGZvciBnaXZlbiBlbGxpcHRpYyBjdXJ2ZSBgUG9pbnRgIGFuZCBgaGFzaGAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIFBvaW50IGNyZWF0ZWQgdXNpbmcge0BsaW5rIHdlaWVyc3RyYXNzfSBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggdXNlZCBmb3IgMSkgbWVzc2FnZSBwcmVoYXNoLWluZyAyKSBrIGdlbmVyYXRpb24gaW4gYHNpZ25gLCB1c2luZyBobWFjX2RyYmcoaGFzaClcbiAqIEBwYXJhbSBlY2RzYU9wdHMgcmFyZWx5IG5lZWRlZCwgc2VlIHtAbGluayBFQ0RTQU9wdHN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBwMjU2X1BvaW50ID0gd2VpZXJzdHJhc3MoLi4uKTtcbiAqIGNvbnN0IHAyNTZfc2hhMjU2ID0gZWNkc2EocDI1Nl9Qb2ludCwgc2hhMjU2KTtcbiAqIGNvbnN0IHAyNTZfc2hhMjI0ID0gZWNkc2EocDI1Nl9Qb2ludCwgc2hhMjI0KTtcbiAqIGNvbnN0IHAyNTZfc2hhMjI0X3IgPSBlY2RzYShwMjU2X1BvaW50LCBzaGEyMjQsIHsgcmFuZG9tQnl0ZXM6IChsZW5ndGgpID0+IHsgLi4uIH0gfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVjZHNhKFxuICBQb2ludDogV2VpZXJzdHJhc3NQb2ludENvbnM8YmlnaW50PixcbiAgaGFzaDogQ0hhc2gsXG4gIGVjZHNhT3B0czogRUNEU0FPcHRzID0ge31cbik6IEVDRFNBIHtcbiAgYWhhc2goaGFzaCk7XG4gIHZhbGlkYXRlT2JqZWN0KFxuICAgIGVjZHNhT3B0cyxcbiAgICB7fSxcbiAgICB7XG4gICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgfVxuICApO1xuICBlY2RzYU9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBlY2RzYU9wdHMpO1xuICBjb25zdCByYW5kb21CeXRlcyA9IGVjZHNhT3B0cy5yYW5kb21CeXRlcyB8fCB3Y1JhbmRvbUJ5dGVzO1xuICBjb25zdCBobWFjID0gZWNkc2FPcHRzLmhtYWMgfHwgKChrZXksIG1zZykgPT4gbm9ibGVIbWFjKGhhc2gsIGtleSwgbXNnKSk7XG5cbiAgY29uc3QgeyBGcCwgRm4gfSA9IFBvaW50O1xuICBjb25zdCB7IE9SREVSOiBDVVJWRV9PUkRFUiwgQklUUzogZm5CaXRzIH0gPSBGbjtcbiAgY29uc3QgeyBrZXlnZW4sIGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCB1dGlscywgbGVuZ3RocyB9ID0gZWNkaChQb2ludCwgZWNkc2FPcHRzKTtcbiAgY29uc3QgZGVmYXVsdFNpZ09wdHM6IFJlcXVpcmVkPEVDRFNBU2lnbk9wdHM+ID0ge1xuICAgIHByZWhhc2g6IHRydWUsXG4gICAgbG93UzogdHlwZW9mIGVjZHNhT3B0cy5sb3dTID09PSAnYm9vbGVhbicgPyBlY2RzYU9wdHMubG93UyA6IHRydWUsXG4gICAgZm9ybWF0OiAnY29tcGFjdCcgYXMgRUNEU0FTaWduYXR1cmVGb3JtYXQsXG4gICAgZXh0cmFFbnRyb3B5OiBmYWxzZSxcbiAgfTtcbiAgY29uc3QgaGFzTGFyZ2VDb2ZhY3RvciA9IENVUlZFX09SREVSICogXzJuIDwgRnAuT1JERVI7IC8vIFdvbid0IENVUlZFKCkuaCA+IDJuIGJlIG1vcmUgZWZmZWN0aXZlP1xuXG4gIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXI6IGJpZ2ludCkge1xuICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVSUyh0aXRsZTogc3RyaW5nLCBudW06IGJpZ2ludCk6IGJpZ2ludCB7XG4gICAgaWYgKCFGbi5pc1ZhbGlkTm90MChudW0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke3RpdGxlfTogb3V0IG9mIHJhbmdlIDEuLlBvaW50LkZuLk9SREVSYCk7XG4gICAgcmV0dXJuIG51bTtcbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRTbWFsbENvZmFjdG9yKCk6IHZvaWQge1xuICAgIC8vIEVDRFNBIHJlY292ZXJ5IGlzIGhhcmQgZm9yIGNvZmFjdG9yID4gMSBjdXJ2ZXMuXG4gICAgLy8gSW4gc2lnbiwgYHIgPSBxLnggbW9kIG5gLCBhbmQgaGVyZSB3ZSByZWNvdmVyIHEueCBmcm9tIHIuXG4gICAgLy8gV2hpbGUgcmVjb3ZlcmluZyBxLnggPj0gbiwgd2UgbmVlZCB0byBhZGQgcituIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAvLyBIb3dldmVyLCBmb3IgY29mYWN0b3I+MSwgcituIG1heSBub3QgZ2V0IHEueDpcbiAgICAvLyByK24qaSB3b3VsZCBuZWVkIHRvIGJlIGRvbmUgaW5zdGVhZCB3aGVyZSBpIGlzIHVua25vd24uXG4gICAgLy8gVG8gZWFzaWx5IGdldCBpLCB3ZSBlaXRoZXIgbmVlZCB0bzpcbiAgICAvLyBhLiBpbmNyZWFzZSBhbW91bnQgb2YgdmFsaWQgcmVjaWQgdmFsdWVzICg0LCA1Li4uKTsgT1JcbiAgICAvLyBiLiBwcm9oaWJpdCBub24tcHJpbWUtb3JkZXIgc2lnbmF0dXJlcyAocmVjaWQgPiAxKS5cbiAgICBpZiAoaGFzTGFyZ2VDb2ZhY3RvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJyZWNvdmVyZWRcIiBzaWcgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBjb2ZhY3RvciA+MiBjdXJ2ZXMnKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZVNpZ0xlbmd0aChieXRlczogVWludDhBcnJheSwgZm9ybWF0OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCkge1xuICAgIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2lnbmF0dXJlITtcbiAgICBjb25zdCBzaXplciA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gc2l6ZSA6IGZvcm1hdCA9PT0gJ3JlY292ZXJlZCcgPyBzaXplICsgMSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gYWJ5dGVzKGJ5dGVzLCBzaXplcik7XG4gIH1cblxuICAvKipcbiAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBjb21wYWN0LCByZWNvdmVyZWQgJiBERVIgcmVwcmVzZW50YXRpb25zLlxuICAgKi9cbiAgY2xhc3MgU2lnbmF0dXJlIGltcGxlbWVudHMgRUNEU0FTaWduYXR1cmUge1xuICAgIHJlYWRvbmx5IHI6IGJpZ2ludDtcbiAgICByZWFkb25seSBzOiBiaWdpbnQ7XG4gICAgcmVhZG9ubHkgcmVjb3Zlcnk/OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihyOiBiaWdpbnQsIHM6IGJpZ2ludCwgcmVjb3Zlcnk/OiBudW1iZXIpIHtcbiAgICAgIHRoaXMuciA9IHZhbGlkYXRlUlMoJ3InLCByKTsgLy8gciBpbiBbMS4uTi0xXTtcbiAgICAgIHRoaXMucyA9IHZhbGlkYXRlUlMoJ3MnLCBzKTsgLy8gcyBpbiBbMS4uTi0xXTtcbiAgICAgIGlmIChyZWNvdmVyeSAhPSBudWxsKSB7XG4gICAgICAgIGFzc2VydFNtYWxsQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKFxuICAgICAgYnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgICBmb3JtYXQ6IEVDRFNBU2lnbmF0dXJlRm9ybWF0ID0gZGVmYXVsdFNpZ09wdHMuZm9ybWF0XG4gICAgKTogU2lnbmF0dXJlIHtcbiAgICAgIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpO1xuICAgICAgbGV0IHJlY2lkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhhYnl0ZXMoYnl0ZXMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0ID09PSAncmVjb3ZlcmVkJykge1xuICAgICAgICByZWNpZCA9IGJ5dGVzWzBdO1xuICAgICAgICBmb3JtYXQgPSAnY29tcGFjdCc7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBMID0gbGVuZ3Rocy5zaWduYXR1cmUhIC8gMjtcbiAgICAgIGNvbnN0IHIgPSBieXRlcy5zdWJhcnJheSgwLCBMKTtcbiAgICAgIGNvbnN0IHMgPSBieXRlcy5zdWJhcnJheShMLCBMICogMik7XG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShGbi5mcm9tQnl0ZXMociksIEZuLmZyb21CeXRlcyhzKSwgcmVjaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tSGV4KGhleDogc3RyaW5nLCBmb3JtYXQ/OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ5dGVzKGhleFRvQnl0ZXMoaGV4KSwgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzc2VydFJlY292ZXJ5KCk6IG51bWJlciB7XG4gICAgICBjb25zdCB7IHJlY292ZXJ5IH0gPSB0aGlzO1xuICAgICAgaWYgKHJlY292ZXJ5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeSBpZDogbXVzdCBiZSBwcmVzZW50Jyk7XG4gICAgICByZXR1cm4gcmVjb3Zlcnk7XG4gICAgfVxuXG4gICAgYWRkUmVjb3ZlcnlCaXQocmVjb3Zlcnk6IG51bWJlcik6IFJlY292ZXJlZFNpZ25hdHVyZSB7XG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpIGFzIFJlY292ZXJlZFNpZ25hdHVyZTtcbiAgICB9XG5cbiAgICByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoOiBVaW50OEFycmF5KTogV2VpZXJzdHJhc3NQb2ludDxiaWdpbnQ+IHtcbiAgICAgIGNvbnN0IHsgciwgcyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHJlY292ZXJ5ID0gdGhpcy5hc3NlcnRSZWNvdmVyeSgpO1xuICAgICAgY29uc3QgcmFkaiA9IHJlY292ZXJ5ID09PSAyIHx8IHJlY292ZXJ5ID09PSAzID8gciArIENVUlZFX09SREVSIDogcjtcbiAgICAgIGlmICghRnAuaXNWYWxpZChyYWRqKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5IGlkOiBzaWcucitjdXJ2ZS5uICE9IFIueCcpO1xuICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMocmFkaik7XG4gICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUJ5dGVzKGNvbmNhdEJ5dGVzKHBwcmVmaXgoKHJlY292ZXJ5ICYgMSkgPT09IDApLCB4KSk7XG4gICAgICBjb25zdCBpciA9IEZuLmludihyYWRqKTsgLy8gcl4tMVxuICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oYWJ5dGVzKG1lc3NhZ2VIYXNoLCB1bmRlZmluZWQsICdtc2dIYXNoJykpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICBjb25zdCB1MSA9IEZuLmNyZWF0ZSgtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICBjb25zdCB1MiA9IEZuLmNyZWF0ZShzICogaXIpOyAvLyBzcl4tMVxuICAgICAgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpLiB1bnNhZmUgaXMgZmluZTogdGhlcmUgaXMgbm8gcHJpdmF0ZSBkYXRhLlxuICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlVbnNhZmUodTEpLmFkZChSLm11bHRpcGx5VW5zYWZlKHUyKSk7XG4gICAgICBpZiAoUS5pczAoKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5OiBwb2ludCBhdCBpbmZpbmlmeScpO1xuICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgcmV0dXJuIFE7XG4gICAgfVxuXG4gICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgIGhhc0hpZ2hTKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgIH1cblxuICAgIHRvQnl0ZXMoZm9ybWF0OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCA9IGRlZmF1bHRTaWdPcHRzLmZvcm1hdCkge1xuICAgICAgdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0KTtcbiAgICAgIGlmIChmb3JtYXQgPT09ICdkZXInKSByZXR1cm4gaGV4VG9CeXRlcyhERVIuaGV4RnJvbVNpZyh0aGlzKSk7XG4gICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICBjb25zdCByYiA9IEZuLnRvQnl0ZXMocik7XG4gICAgICBjb25zdCBzYiA9IEZuLnRvQnl0ZXMocyk7XG4gICAgICBpZiAoZm9ybWF0ID09PSAncmVjb3ZlcmVkJykge1xuICAgICAgICBhc3NlcnRTbWFsbENvZmFjdG9yKCk7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5Lm9mKHRoaXMuYXNzZXJ0UmVjb3ZlcnkoKSksIHJiLCBzYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0Qnl0ZXMocmIsIHNiKTtcbiAgICB9XG5cbiAgICB0b0hleChmb3JtYXQ/OiBFQ0RTQVNpZ25hdHVyZUZvcm1hdCkge1xuICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKGZvcm1hdCkpO1xuICAgIH1cbiAgfVxuICB0eXBlIFJlY292ZXJlZFNpZ25hdHVyZSA9IFNpZ25hdHVyZSAmIHsgcmVjb3Zlcnk6IG51bWJlciB9O1xuXG4gIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gIGNvbnN0IGJpdHMyaW50ID1cbiAgICBlY2RzYU9wdHMuYml0czJpbnQgfHxcbiAgICBmdW5jdGlvbiBiaXRzMmludF9kZWYoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICAgICAgLy8gT3VyIGN1c3RvbSBjaGVjayBcImp1c3QgaW4gY2FzZVwiLCBmb3IgcHJvdGVjdGlvbiBhZ2FpbnN0IERvU1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gZm5CaXRzOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICB9O1xuICBjb25zdCBiaXRzMmludF9tb2ROID1cbiAgICBlY2RzYU9wdHMuYml0czJpbnRfbW9kTiB8fFxuICAgIGZ1bmN0aW9uIGJpdHMyaW50X21vZE5fZGVmKGJ5dGVzOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgICAgIHJldHVybiBGbi5jcmVhdGUoYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgfTtcbiAgLy8gUGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gIGNvbnN0IE9SREVSX01BU0sgPSBiaXRNYXNrKGZuQml0cyk7XG4gIC8qKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLiAqL1xuICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bTogYmlnaW50KTogVWludDhBcnJheSB7XG4gICAgLy8gSU1QT1JUQU5UOiB0aGUgY2hlY2sgZW5zdXJlcyB3b3JraW5nIGZvciBjYXNlIGBGbi5CWVRFUyAhPSBGbi5CSVRTICogOGBcbiAgICBhSW5SYW5nZSgnbnVtIDwgMl4nICsgZm5CaXRzLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgcmV0dXJuIEZuLnRvQnl0ZXMobnVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlTXNnQW5kSGFzaChtZXNzYWdlOiBVaW50OEFycmF5LCBwcmVoYXNoOiBib29sZWFuKSB7XG4gICAgYWJ5dGVzKG1lc3NhZ2UsIHVuZGVmaW5lZCwgJ21lc3NhZ2UnKTtcbiAgICByZXR1cm4gcHJlaGFzaCA/IGFieXRlcyhoYXNoKG1lc3NhZ2UpLCB1bmRlZmluZWQsICdwcmVoYXNoZWQgbWVzc2FnZScpIDogbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgKiBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICogVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAqXG4gICAqIFdhcm5pbmc6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1lc3NhZ2UgaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgKiB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2LlxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcFNpZyhtZXNzYWdlOiBVaW50OEFycmF5LCBzZWNyZXRLZXk6IFVpbnQ4QXJyYXksIG9wdHM6IEVDRFNBU2lnbk9wdHMpIHtcbiAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weSB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICBtZXNzYWdlID0gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpOyAvLyBSRkM2OTc5IDMuMiBBOiBoMSA9IEgobSlcbiAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAvLyB3aXRoIGZuQml0cyAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7XG4gICAgY29uc3QgZCA9IEZuLmZyb21CeXRlcyhzZWNyZXRLZXkpOyAvLyB2YWxpZGF0ZSBzZWNyZXQga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgIGlmICghRm4uaXNWYWxpZE5vdDAoZCkpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgaWYgKGV4dHJhRW50cm9weSAhPSBudWxsICYmIGV4dHJhRW50cm9weSAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgLy8gZ2VuIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICBjb25zdCBlID0gZXh0cmFFbnRyb3B5ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMobGVuZ3Rocy5zZWNyZXRLZXkpIDogZXh0cmFFbnRyb3B5O1xuICAgICAgc2VlZEFyZ3MucHVzaChhYnl0ZXMoZSwgdW5kZWZpbmVkLCAnZXh0cmFFbnRyb3B5JykpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgY29uc3QgbSA9IGgxaW50OyAvLyBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgIC8vIFRvIHRyYW5zZm9ybSBrID0+IFNpZ25hdHVyZTpcbiAgICAvLyBxID0ga1x1MjJDNUdcbiAgICAvLyByID0gcS54IG1vZCBuXG4gICAgLy8gcyA9IGteLTEobSArIHJkKSBtb2QgblxuICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIgXHUyMjA4IFsxLHFcdTIyMTIxXSBhY2NvcmRpbmcgdG9cbiAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzOiBVaW50OEFycmF5KTogU2lnbmF0dXJlIHwgdW5kZWZpbmVkIHtcbiAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChrKSkgcmV0dXJuOyAvLyBWYWxpZCBzY2FsYXJzIChpbmNsdWRpbmcgaykgbXVzdCBiZSBpbiAxLi5OLTFcbiAgICAgIGNvbnN0IGlrID0gRm4uaW52KGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0ga1x1MjJDNUdcbiAgICAgIGNvbnN0IHIgPSBGbi5jcmVhdGUocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgaWYgKHIgPT09IF8wbikgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IEZuLmNyZWF0ZShpayAqIEZuLmNyZWF0ZShtICsgciAqIGQpKTsgLy8gcyA9IGteLTEobSArIHJkKSBtb2QgblxuICAgICAgaWYgKHMgPT09IF8wbikgcmV0dXJuO1xuICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMyB3aGVuIHEueD5uKVxuICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICBub3JtUyA9IEZuLm5lZyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXMgaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgcmVjb3ZlcnkgXj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCBoYXNMYXJnZUNvZmFjdG9yID8gdW5kZWZpbmVkIDogcmVjb3ZlcnkpO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgc2VjcmV0IGtleS5cbiAgICpcbiAgICogYGBgXG4gICAqIHNpZ24obSwgZCkgd2hlcmVcbiAgICogICBrID0gcmZjNjk3OV9obWFjX2RyYmcobSwgZClcbiAgICogICAoeCwgeSkgPSBHIFx1MDBENyBrXG4gICAqICAgciA9IHggbW9kIG5cbiAgICogICBzID0gKG0gKyBkcikgLyBrIG1vZCBuXG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb24gc2lnbihtZXNzYWdlOiBVaW50OEFycmF5LCBzZWNyZXRLZXk6IFVpbnQ4QXJyYXksIG9wdHM6IEVDRFNBU2lnbk9wdHMgPSB7fSk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobWVzc2FnZSwgc2VjcmV0S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RyYmc8U2lnbmF0dXJlPihoYXNoLm91dHB1dExlbiwgRm4uQllURVMsIGhtYWMpO1xuICAgIGNvbnN0IHNpZyA9IGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgcmV0dXJuIHNpZy50b0J5dGVzKG9wdHMuZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuXG4gICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHNlZSB7QGxpbmsgRUNEU0FWZXJpZnlPcHRzfS5cbiAgICogSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAqXG4gICAqIGBgYFxuICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICogICB1MSA9IGhzXi0xIG1vZCBuXG4gICAqICAgdTIgPSByc14tMSBtb2QgblxuICAgKiAgIFIgPSB1MVx1MjJDNUcgKyB1Mlx1MjJDNVBcbiAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb24gdmVyaWZ5KFxuICAgIHNpZ25hdHVyZTogVWludDhBcnJheSxcbiAgICBtZXNzYWdlOiBVaW50OEFycmF5LFxuICAgIHB1YmxpY0tleTogVWludDhBcnJheSxcbiAgICBvcHRzOiBFQ0RTQVZlcmlmeU9wdHMgPSB7fVxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICBwdWJsaWNLZXkgPSBhYnl0ZXMocHVibGljS2V5LCB1bmRlZmluZWQsICdwdWJsaWNLZXknKTtcbiAgICBtZXNzYWdlID0gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpO1xuICAgIGlmICghaXNCeXRlcyhzaWduYXR1cmUgYXMgYW55KSkge1xuICAgICAgY29uc3QgZW5kID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlID8gJywgdXNlIHNpZy50b0J5dGVzKCknIDogJyc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcmlmeSBleHBlY3RzIFVpbnQ4QXJyYXkgc2lnbmF0dXJlJyArIGVuZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlU2lnTGVuZ3RoKHNpZ25hdHVyZSwgZm9ybWF0KTsgLy8gZXhlY3V0ZSB0aGlzIHR3aWNlIGJlY2F1c2Ugd2Ugd2FudCBsb3VkIGVycm9yXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZyA9IFNpZ25hdHVyZS5mcm9tQnl0ZXMoc2lnbmF0dXJlLCBmb3JtYXQpO1xuICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7IC8vIG1vZCBuLCBub3QgbW9kIHBcbiAgICAgIGNvbnN0IGlzID0gRm4uaW52KHMpOyAvLyBzXi0xIG1vZCBuXG4gICAgICBjb25zdCB1MSA9IEZuLmNyZWF0ZShoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICBjb25zdCB1MiA9IEZuLmNyZWF0ZShyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseVVuc2FmZSh1MSkuYWRkKFAubXVsdGlwbHlVbnNhZmUodTIpKTsgLy8gdTFcdTIyQzVHICsgdTJcdTIyQzVQXG4gICAgICBpZiAoUi5pczAoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdiA9IEZuLmNyZWF0ZShSLngpOyAvLyB2ID0gci54IG1vZCBuXG4gICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShcbiAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXksXG4gICAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgICBvcHRzOiBFQ0RTQVJlY292ZXJPcHRzID0ge31cbiAgKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmYXVsdFNpZ09wdHMpO1xuICAgIG1lc3NhZ2UgPSB2YWxpZGF0ZU1zZ0FuZEhhc2gobWVzc2FnZSwgcHJlaGFzaCk7XG4gICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoc2lnbmF0dXJlLCAncmVjb3ZlcmVkJykucmVjb3ZlclB1YmxpY0tleShtZXNzYWdlKS50b0J5dGVzKCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAga2V5Z2VuLFxuICAgIGdldFB1YmxpY0tleSxcbiAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgdXRpbHMsXG4gICAgbGVuZ3RocyxcbiAgICBQb2ludCxcbiAgICBzaWduLFxuICAgIHZlcmlmeSxcbiAgICByZWNvdmVyUHVibGljS2V5LFxuICAgIFNpZ25hdHVyZSxcbiAgICBoYXNoLFxuICB9KSBzYXRpc2ZpZXMgU2lnbmVyO1xufVxuIiwgIi8qKlxuICogU0VDRyBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogQmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5LWNvbXB1dGFibGUgR0xWIGVuZG9tb3JwaGlzbSBcdTAzQzgsXG4gKiBjaGVjayBvdXQge0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9LiBTZWVtcyB0byBiZSByaWdpZCAobm90IGJhY2tkb29yZWQpLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTIuanMnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUtleWdlbiwgdHlwZSBDdXJ2ZUxlbmd0aHMgfSBmcm9tICcuL2Fic3RyYWN0L2N1cnZlLnRzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgdHlwZSBIMkNIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUudHMnO1xuaW1wb3J0IHsgRmllbGQsIG1hcEhhc2hUb0ZpZWxkLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLnRzJztcbmltcG9ydCB7XG4gIHR5cGUgRUNEU0EsXG4gIGVjZHNhLFxuICB0eXBlIEVuZG9tb3JwaGlzbU9wdHMsXG4gIG1hcFRvQ3VydmVTaW1wbGVTV1UsXG4gIHR5cGUgV2VpZXJzdHJhc3NQb2ludCBhcyBQb2ludFR5cGUsXG4gIHdlaWVyc3RyYXNzLFxuICB0eXBlIFdlaWVyc3RyYXNzT3B0cyxcbiAgdHlwZSBXZWllcnN0cmFzc1BvaW50Q29ucyxcbn0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy50cyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGFzY2lpVG9CeXRlcywgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcyB9IGZyb20gJy4vdXRpbHMudHMnO1xuXG4vLyBTZWVtcyBsaWtlIGdlbmVyYXRvciB3YXMgcHJvZHVjZWQgZnJvbSBzb21lIHNlZWQ6XG4vLyBgUG9pbnRrMS5CQVNFLm11bHRpcGx5KFBvaW50azEuRm4uaW52KDJuLCBOKSkudG9BZmZpbmUoKS54YFxuLy8gLy8gZ2l2ZXMgc2hvcnQgeCAweDNiNzhjZTU2M2Y4OWEwZWQ5NDE0ZjVhYTI4YWQwZDk2ZDY3OTVmOWM2M25cbmNvbnN0IHNlY3AyNTZrMV9DVVJWRTogV2VpZXJzdHJhc3NPcHRzPGJpZ2ludD4gPSB7XG4gIHA6IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyksXG4gIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gIGg6IEJpZ0ludCgxKSxcbiAgYTogQmlnSW50KDApLFxuICBiOiBCaWdJbnQoNyksXG4gIEd4OiBCaWdJbnQoJzB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcpLFxuICBHeTogQmlnSW50KCcweDQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnKSxcbn07XG5cbmNvbnN0IHNlY3AyNTZrMV9FTkRPOiBFbmRvbW9ycGhpc21PcHRzID0ge1xuICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICBiYXNpc2VzOiBbXG4gICAgW0JpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpLCAtQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyldLFxuICAgIFtCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyksIEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpXSxcbiAgXSxcbn07XG5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuXG4vKipcbiAqIFx1MjIxQW4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeTogYmlnaW50KTogYmlnaW50IHtcbiAgY29uc3QgUCA9IHNlY3AyNTZrMV9DVVJWRS5wO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gIGlmICghRnBrMS5lcWwoRnBrMS5zcXIocm9vdCksIHkpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gIHJldHVybiByb290O1xufVxuXG5jb25zdCBGcGsxID0gRmllbGQoc2VjcDI1NmsxX0NVUlZFLnAsIHsgc3FydDogc3FydE1vZCB9KTtcbmNvbnN0IFBvaW50azEgPSAvKiBAX19QVVJFX18gKi8gd2VpZXJzdHJhc3Moc2VjcDI1NmsxX0NVUlZFLCB7XG4gIEZwOiBGcGsxLFxuICBlbmRvOiBzZWNwMjU2azFfRU5ETyxcbn0pO1xuXG4vKipcbiAqIHNlY3AyNTZrMSBjdXJ2ZTogRUNEU0EgYW5kIEVDREggbWV0aG9kcy5cbiAqXG4gKiBVc2VzIHNoYTI1NiB0byBoYXNoIG1lc3NhZ2VzLiBUbyB1c2UgYSBkaWZmZXJlbnQgaGFzaCxcbiAqIHBhc3MgYHsgcHJlaGFzaDogZmFsc2UgfWAgdG8gc2lnbiAvIHZlcmlmeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNlY3AyNTZrMS5rZXlnZW4oKTtcbiAqIC8vIGNvbnN0IHB1YmxpY0tleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnaGVsbG8gbm9ibGUnKTtcbiAqIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzZWNwMjU2azEudmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXkpO1xuICogLy8gY29uc3Qgc2lnS2VjY2FrID0gc2VjcDI1NmsxLnNpZ24oa2VjY2FrMjU2KG1zZyksIHNlY3JldEtleSwgeyBwcmVoYXNoOiBmYWxzZSB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxOiBFQ0RTQSA9IC8qIEBfX1BVUkVfXyAqLyBlY2RzYShQb2ludGsxLCBzaGEyNTYpO1xuXG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTOiB7IFt0YWc6IHN0cmluZ106IFVpbnQ4QXJyYXkgfSA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWc6IHN0cmluZywgLi4ubWVzc2FnZXM6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkge1xuICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB0YWdIID0gc2hhMjU2KGFzY2lpVG9CeXRlcyh0YWcpKTtcbiAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gIH1cbiAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuXG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludDogUG9pbnRUeXBlPGJpZ2ludD4pID0+IHBvaW50LnRvQnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBoYXNFdmVuID0gKHk6IGJpZ2ludCkgPT4geSAlIF8ybiA9PT0gXzBuO1xuXG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdjogVWludDhBcnJheSkge1xuICBjb25zdCB7IEZuLCBCQVNFIH0gPSBQb2ludGsxO1xuICBjb25zdCBkXyA9IEZuLmZyb21CeXRlcyhwcml2KTtcbiAgY29uc3QgcCA9IEJBU0UubXVsdGlwbHkoZF8pOyAvLyBQID0gZCdcdTIyQzVHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gIGNvbnN0IHNjYWxhciA9IGhhc0V2ZW4ocC55KSA/IGRfIDogRm4ubmVnKGRfKTtcbiAgcmV0dXJuIHsgc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4OiBiaWdpbnQpOiBQb2ludFR5cGU8YmlnaW50PiB7XG4gIGNvbnN0IEZwID0gRnBrMTtcbiAgaWYgKCFGcC5pc1ZhbGlkTm90MCh4KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHg6IEZhaWwgaWYgeCBcdTIyNjUgcCcpO1xuICBjb25zdCB4eCA9IEZwLmNyZWF0ZSh4ICogeCk7XG4gIGNvbnN0IGMgPSBGcC5jcmVhdGUoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4XHUwMEIzICsgNyBtb2QgcC5cbiAgbGV0IHkgPSBGcC5zcXJ0KGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC4gU2FtZSBhcyBzcXJ0KCkuXG4gIC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgaWYgKCFoYXNFdmVuKHkpKSB5ID0gRnAubmVnKHkpO1xuICBjb25zdCBwID0gUG9pbnRrMS5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJnczogVWludDhBcnJheVtdKTogYmlnaW50IHtcbiAgcmV0dXJuIFBvaW50azEuRm4uY3JlYXRlKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG5cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkoc2VjcmV0S2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQnXHUyMjY1bi4gUmV0IGJ5dGVzKGQnXHUyMkM1Rylcbn1cblxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihcbiAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgc2VjcmV0S2V5OiBVaW50OEFycmF5LFxuICBhdXhSYW5kOiBVaW50OEFycmF5ID0gcmFuZG9tQnl0ZXMoMzIpXG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgeyBGbiB9ID0gUG9pbnRrMTtcbiAgY29uc3QgbSA9IGFieXRlcyhtZXNzYWdlLCB1bmRlZmluZWQsICdtZXNzYWdlJyk7XG4gIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoc2VjcmV0S2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgY29uc3QgYSA9IGFieXRlcyhhdXhSYW5kLCAzMiwgJ2F1eFJhbmQnKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICBjb25zdCB0ID0gRm4udG9CeXRlcyhkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG4uIEZhaWwgaWYgaycgPSAwLiBMZXQgUiA9IGsnXHUyMkM1R1xuICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHJhbmQpO1xuICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICBzaWcuc2V0KHJ4LCAwKTtcbiAgc2lnLnNldChGbi50b0J5dGVzKEZuLmNyZWF0ZShrICsgZSAqIGQpKSwgMzIpO1xuICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlOiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5LCBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgY29uc3QgeyBGcCwgRm4sIEJBU0UgfSA9IFBvaW50azE7XG4gIGNvbnN0IHNpZyA9IGFieXRlcyhzaWduYXR1cmUsIDY0LCAnc2lnbmF0dXJlJyk7XG4gIGNvbnN0IG0gPSBhYnl0ZXMobWVzc2FnZSwgdW5kZWZpbmVkLCAnbWVzc2FnZScpO1xuICBjb25zdCBwdWIgPSBhYnl0ZXMocHVibGljS2V5LCAzMiwgJ3B1YmxpY0tleScpO1xuICB0cnkge1xuICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIgXHUyMjY1IHAuXG4gICAgaWYgKCFGcC5pc1ZhbGlkTm90MChyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHMgPSBudW0oc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIFx1MjI2NSBuLlxuICAgIGlmICghRm4uaXNWYWxpZE5vdDAocykpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UoRm4udG9CeXRlcyhyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgLy8gUiA9IHNcdTIyQzVHIC0gZVx1MjJDNVAsIHdoZXJlIC1lUCA9PSAobi1lKVBcbiAgICBjb25zdCBSID0gQkFTRS5tdWx0aXBseVVuc2FmZShzKS5hZGQoUC5tdWx0aXBseVVuc2FmZShGbi5uZWcoZSkpKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IFIudG9BZmZpbmUoKTtcbiAgICAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIFx1MjI2MCByLlxuICAgIGlmIChSLmlzMCgpIHx8ICFoYXNFdmVuKHkpIHx8IHggIT09IHIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VjcFNjaG5vcnIgPSB7XG4gIGtleWdlbjogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiB7IHNlY3JldEtleTogVWludDhBcnJheTsgcHVibGljS2V5OiBVaW50OEFycmF5IH07XG4gIGdldFB1YmxpY0tleTogdHlwZW9mIHNjaG5vcnJHZXRQdWJsaWNLZXk7XG4gIHNpZ246IHR5cGVvZiBzY2hub3JyU2lnbjtcbiAgdmVyaWZ5OiB0eXBlb2Ygc2Nobm9yclZlcmlmeTtcbiAgUG9pbnQ6IFdlaWVyc3RyYXNzUG9pbnRDb25zPGJpZ2ludD47XG4gIHV0aWxzOiB7XG4gICAgcmFuZG9tU2VjcmV0S2V5OiAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXk7XG4gICAgcG9pbnRUb0J5dGVzOiAocG9pbnQ6IFBvaW50VHlwZTxiaWdpbnQ+KSA9PiBVaW50OEFycmF5O1xuICAgIGxpZnRfeDogdHlwZW9mIGxpZnRfeDtcbiAgICB0YWdnZWRIYXNoOiB0eXBlb2YgdGFnZ2VkSGFzaDtcbiAgfTtcbiAgbGVuZ3RoczogQ3VydmVMZW5ndGhzO1xufTtcbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNjaG5vcnIua2V5Z2VuKCk7XG4gKiAvLyBjb25zdCBwdWJsaWNLZXkgPSBzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2Nobm9ycjogU2VjcFNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IDMyO1xuICBjb25zdCBzZWVkTGVuZ3RoID0gNDg7XG4gIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXMoc2VlZExlbmd0aCkpOiBVaW50OEFycmF5ID0+IHtcbiAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGtleWdlbjogY3JlYXRlS2V5Z2VuKHJhbmRvbVNlY3JldEtleSwgc2Nobm9yckdldFB1YmxpY0tleSksXG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICBQb2ludDogUG9pbnRrMSxcbiAgICB1dGlsczoge1xuICAgICAgcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgIGxpZnRfeCxcbiAgICAgIHBvaW50VG9CeXRlcyxcbiAgICB9LFxuICAgIGxlbmd0aHM6IHtcbiAgICAgIHNlY3JldEtleTogc2l6ZSxcbiAgICAgIHB1YmxpY0tleTogc2l6ZSxcbiAgICAgIHB1YmxpY0tleUhhc1ByZWZpeDogZmFsc2UsXG4gICAgICBzaWduYXR1cmU6IHNpemUgKiAyLFxuICAgICAgc2VlZDogc2VlZExlbmd0aCxcbiAgICB9LFxuICB9O1xufSkoKTtcblxuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICBpc29nZW55TWFwKFxuICAgIEZwazEsXG4gICAgW1xuICAgICAgLy8geE51bVxuICAgICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgICAgXSxcbiAgICAgIC8vIHhEZW5cbiAgICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgICBdLFxuICAgICAgLy8geU51bVxuICAgICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICAgIF0sXG4gICAgICAvLyB5RGVuXG4gICAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICAgIF0sXG4gICAgXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSBhcyBbYmlnaW50W10sIGJpZ2ludFtdLCBiaWdpbnRbXSwgYmlnaW50W11dXG4gICkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG4gIH0pKSgpO1xuXG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHNlY3AyNTZrMSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azFfaGFzaGVyOiBIMkNIYXNoZXI8V2VpZXJzdHJhc3NQb2ludENvbnM8YmlnaW50Pj4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIGNyZWF0ZUhhc2hlcihcbiAgICBQb2ludGsxLFxuICAgIChzY2FsYXJzOiBiaWdpbnRbXSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnBrMS5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbiAgICB9LFxuICAgIHtcbiAgICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgICAgcDogRnBrMS5PUkRFUixcbiAgICAgIG06IDEsXG4gICAgICBrOiAxMjgsXG4gICAgICBleHBhbmQ6ICd4bWQnLFxuICAgICAgaGFzaDogc2hhMjU2LFxuICAgIH1cbiAgKSkoKTtcbiIsICIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVyPEYsIFQ+IHtcbiAgZW5jb2RlKGZyb206IEYpOiBUO1xuICBkZWNvZGUodG86IFQpOiBGO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlcjxVaW50OEFycmF5LCBzdHJpbmc+IHtcbiAgZW5jb2RlOiAoZGF0YTogVWludDhBcnJheSkgPT4gc3RyaW5nO1xuICBkZWNvZGU6IChzdHI6IHN0cmluZykgPT4gVWludDhBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNCeXRlcyhhOiB1bmtub3duKTogYSBpcyBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5mdW5jdGlvbiBhYnl0ZXMoYjogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICBpZiAoIWlzQnl0ZXMoYikpIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5T2YoaXNTdHJpbmc6IGJvb2xlYW4sIGFycjogYW55W10pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBpZiAoaXNTdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZm4oaW5wdXQ6IEZ1bmN0aW9uKTogaW5wdXQgaXMgRnVuY3Rpb24ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uIGV4cGVjdGVkJyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhc3RyKGxhYmVsOiBzdHJpbmcsIGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IHN0cmluZyBleHBlY3RlZGApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYW51bWJlcihuOiBudW1iZXIpOiB2b2lkIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7bn1gKTtcbn1cblxuZnVuY3Rpb24gYUFycihpbnB1dDogYW55W10pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXN0ckFycihsYWJlbDogc3RyaW5nLCBpbnB1dDogc3RyaW5nW10pIHtcbiAgaWYgKCFpc0FycmF5T2YodHJ1ZSwgaW5wdXQpKSB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBzdHJpbmdzIGV4cGVjdGVkYCk7XG59XG5mdW5jdGlvbiBhbnVtQXJyKGxhYmVsOiBzdHJpbmcsIGlucHV0OiBudW1iZXJbXSkge1xuICBpZiAoIWlzQXJyYXlPZihmYWxzZSwgaW5wdXQpKSB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBudW1iZXJzIGV4cGVjdGVkYCk7XG59XG5cbi8vIFRPRE86IHNvbWUgcmVjdXNpdmUgdHlwZSBpbmZlcmVuY2Ugc28gaXQgd291bGQgY2hlY2sgY29ycmVjdCBvcmRlciBvZiBpbnB1dC9vdXRwdXQgaW5zaWRlIHJlc3Q/XG4vLyBsaWtlIDxzdHJpbmcsIG51bWJlcj4sIDxudW1iZXIsIGJ5dGVzPiwgPGJ5dGVzLCBmbG9hdD5cbnR5cGUgQ2hhaW4gPSBbQ29kZXI8YW55LCBhbnk+LCAuLi5Db2RlcjxhbnksIGFueT5bXV07XG4vLyBFeHRyYWN0IGluZm8gZnJvbSBDb2RlciB0eXBlXG50eXBlIElucHV0PEY+ID0gRiBleHRlbmRzIENvZGVyPGluZmVyIFQsIGFueT4gPyBUIDogbmV2ZXI7XG50eXBlIE91dHB1dDxGPiA9IEYgZXh0ZW5kcyBDb2RlcjxhbnksIGluZmVyIFQ+ID8gVCA6IG5ldmVyO1xuLy8gR2VuZXJpYyBmdW5jdGlvbiBmb3IgYXJyYXlzXG50eXBlIEZpcnN0PFQ+ID0gVCBleHRlbmRzIFtpbmZlciBVLCAuLi5hbnlbXV0gPyBVIDogbmV2ZXI7XG50eXBlIExhc3Q8VD4gPSBUIGV4dGVuZHMgWy4uLmFueVtdLCBpbmZlciBVXSA/IFUgOiBuZXZlcjtcbnR5cGUgVGFpbDxUPiA9IFQgZXh0ZW5kcyBbYW55LCAuLi5pbmZlciBVXSA/IFUgOiBuZXZlcjtcblxudHlwZSBBc0NoYWluPEMgZXh0ZW5kcyBDaGFpbiwgUmVzdCA9IFRhaWw8Qz4+ID0ge1xuICAvLyBDW0tdID0gQ29kZXI8SW5wdXQ8Q1tLXT4sIElucHV0PFJlc3Rba10+PlxuICBbSyBpbiBrZXlvZiBDXTogQ29kZXI8SW5wdXQ8Q1tLXT4sIElucHV0PEsgZXh0ZW5kcyBrZXlvZiBSZXN0ID8gUmVzdFtLXSA6IGFueT4+O1xufTtcblxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbjxUIGV4dGVuZHMgQ2hhaW4gJiBBc0NoYWluPFQ+PiguLi5hcmdzOiBUKTogQ29kZXI8SW5wdXQ8Rmlyc3Q8VD4+LCBPdXRwdXQ8TGFzdDxUPj4+IHtcbiAgY29uc3QgaWQgPSAoYTogYW55KSA9PiBhO1xuICAvLyBXcmFwIGNhbGwgaW4gY2xvc3VyZSBzbyBKSVQgY2FuIGlubGluZSBjYWxsc1xuICBjb25zdCB3cmFwID0gKGE6IGFueSwgYjogYW55KSA9PiAoYzogYW55KSA9PiBhKGIoYykpO1xuICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gIGNvbnN0IGVuY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmVuY29kZSkucmVkdWNlUmlnaHQod3JhcCwgaWQpO1xuICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuXG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrLlxuICogQ291bGQgYWxzbyBiZSBhcnJheSBvZiBzdHJpbmdzLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQobGV0dGVyczogc3RyaW5nIHwgc3RyaW5nW10pOiBDb2RlcjxudW1iZXJbXSwgc3RyaW5nW10+IHtcbiAgLy8gbWFwcGluZyAxIHRvIFwiYlwiXG4gIGNvbnN0IGxldHRlcnNBID0gdHlwZW9mIGxldHRlcnMgPT09ICdzdHJpbmcnID8gbGV0dGVycy5zcGxpdCgnJykgOiBsZXR0ZXJzO1xuICBjb25zdCBsZW4gPSBsZXR0ZXJzQS5sZW5ndGg7XG4gIGFzdHJBcnIoJ2FscGhhYmV0JywgbGV0dGVyc0EpO1xuXG4gIC8vIG1hcHBpbmcgXCJiXCIgdG8gMVxuICBjb25zdCBpbmRleGVzID0gbmV3IE1hcChsZXR0ZXJzQS5tYXAoKGwsIGkpID0+IFtsLCBpXSkpO1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogKGRpZ2l0czogbnVtYmVyW10pID0+IHtcbiAgICAgIGFBcnIoZGlnaXRzKTtcbiAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaSkgfHwgaSA8IDAgfHwgaSA+PSBsZW4pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGFscGhhYmV0LmVuY29kZTogZGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldCBcIiR7aX1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWBcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbGV0dGVyc0FbaV0hO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWNvZGU6IChpbnB1dDogc3RyaW5nW10pOiBudW1iZXJbXSA9PiB7XG4gICAgICBhQXJyKGlucHV0KTtcbiAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICBhc3RyKCdhbHBoYWJldC5kZWNvZGUnLCBsZXR0ZXIpO1xuICAgICAgICBjb25zdCBpID0gaW5kZXhlcy5nZXQobGV0dGVyKTtcbiAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJyk6IENvZGVyPHN0cmluZ1tdLCBzdHJpbmc+IHtcbiAgYXN0cignam9pbicsIHNlcGFyYXRvcik7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgYXN0ckFycignam9pbi5kZWNvZGUnLCBmcm9tKTtcbiAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9LFxuICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICBhc3RyKCdqb2luLmRlY29kZScsIHRvKTtcbiAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0czogbnVtYmVyLCBjaHIgPSAnPScpOiBDb2RlcjxzdHJpbmdbXSwgc3RyaW5nW10+IHtcbiAgYW51bWJlcihiaXRzKTtcbiAgYXN0cigncGFkZGluZycsIGNocik7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlKGRhdGE6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgICAgYXN0ckFycigncGFkZGluZy5lbmNvZGUnLCBkYXRhKTtcbiAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpIGRhdGEucHVzaChjaHIpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQ6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgICAgYXN0ckFycigncGFkZGluZy5kZWNvZGUnLCBpbnB1dCk7XG4gICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IGVuZCAtIDE7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBsYXN0ICogYml0cztcbiAgICAgICAgaWYgKGJ5dGUgJSA4ID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmc6IGludmFsaWQsIHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemU8VD4oZm46ICh2YWw6IFQpID0+IFQpOiBDb2RlcjxULCBUPiB7XG4gIGFmbihmbik7XG4gIHJldHVybiB7IGVuY29kZTogKGZyb206IFQpID0+IGZyb20sIGRlY29kZTogKHRvOiBUKSA9PiBmbih0bykgfTtcbn1cblxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhOiBudW1iZXJbXSwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogbnVtYmVyW10ge1xuICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICBpZiAoZnJvbSA8IDIpIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgaWYgKHRvIDwgMikgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IGludmFsaWQgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gIGFBcnIoZGF0YSk7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcbiAgbGV0IHBvcyA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEsIChkKSA9PiB7XG4gICAgYW51bWJlcihkKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtkfWApO1xuICAgIHJldHVybiBkO1xuICB9KTtcbiAgY29uc3QgZGxlbiA9IGRpZ2l0cy5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRsZW47IGkrKykge1xuICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV0hO1xuICAgICAgY29uc3QgZnJvbUNhcnJ5ID0gZnJvbSAqIGNhcnJ5O1xuICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbUNhcnJ5ICsgZGlnaXQ7XG4gICAgICBpZiAoXG4gICAgICAgICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgIGZyb21DYXJyeSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tQ2FycnlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpdiA9IGRpZ2l0QmFzZSAvIHRvO1xuICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpdik7XG4gICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgIGlmICghZG9uZSkgY29udGludWU7XG4gICAgICBlbHNlIGlmICghcm91bmRlZCkgcG9zID0gaTtcbiAgICAgIGVsc2UgZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXMucHVzaChjYXJyeSk7XG4gICAgaWYgKGRvbmUpIGJyZWFrO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKykgcmVzLnB1c2goMCk7XG4gIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuXG5jb25zdCBnY2QgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIgPT4gKGIgPT09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+XG4gIGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmNvbnN0IHBvd2VyczogbnVtYmVyW10gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHJlcy5wdXNoKDIgKiogaSk7XG4gIHJldHVybiByZXM7XG59KSgpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGE6IG51bWJlcltdLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIHBhZGRpbmc6IGJvb2xlYW4pOiBudW1iZXJbXSB7XG4gIGFBcnIoZGF0YSk7XG4gIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWBcbiAgICApO1xuICB9XG4gIGxldCBjYXJyeSA9IDA7XG4gIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICBjb25zdCBtYXggPSBwb3dlcnNbZnJvbV0hO1xuICBjb25zdCBtYXNrID0gcG93ZXJzW3RvXSEgLSAxO1xuICBjb25zdCByZXM6IG51bWJlcltdID0gW107XG4gIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgYW51bWJlcihuKTtcbiAgICBpZiAobiA+PSBtYXgpIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgaWYgKHBvcyArIGZyb20gPiAzMikgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgIHBvcyArPSBmcm9tO1xuICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bykgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICBjb25zdCBwb3cgPSBwb3dlcnNbcG9zXTtcbiAgICBpZiAocG93ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjYXJyeScpO1xuICAgIGNhcnJ5ICY9IHBvdyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICB9XG4gIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gIGlmICghcGFkZGluZyAmJiBjYXJyeSA+IDApIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMCkgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bTogbnVtYmVyKTogQ29kZXI8VWludDhBcnJheSwgbnVtYmVyW10+IHtcbiAgYW51bWJlcihudW0pO1xuICBjb25zdCBfMjU2ID0gMiAqKiA4O1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogKGJ5dGVzOiBVaW50OEFycmF5KSA9PiB7XG4gICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgXzI1NiwgbnVtKTtcbiAgICB9LFxuICAgIGRlY29kZTogKGRpZ2l0czogbnVtYmVyW10pID0+IHtcbiAgICAgIGFudW1BcnIoJ3JhZGl4LmRlY29kZScsIGRpZ2l0cyk7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgXzI1NikpO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0czogbnVtYmVyLCByZXZQYWRkaW5nID0gZmFsc2UpOiBDb2RlcjxVaW50OEFycmF5LCBudW1iZXJbXT4ge1xuICBhbnVtYmVyKGJpdHMpO1xuICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMikgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChieXRlczogVWludDhBcnJheSkgPT4ge1xuICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSkgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZGlnaXRzOiBudW1iZXJbXSkgPT4ge1xuICAgICAgYW51bUFycigncmFkaXgyLmRlY29kZScsIGRpZ2l0cyk7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgfSxcbiAgfTtcbn1cblxudHlwZSBBcmd1bWVudFR5cGVzPEYgZXh0ZW5kcyBGdW5jdGlvbj4gPSBGIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIEEpID0+IGFueSA/IEEgOiBuZXZlcjtcbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXI8VCBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4oZm46IFQpIHtcbiAgYWZuKGZuKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBBcmd1bWVudFR5cGVzPFQ+KTogUmV0dXJuVHlwZTxUPiB8IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tzdW0oXG4gIGxlbjogbnVtYmVyLFxuICBmbjogKGRhdGE6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcbik6IENvZGVyPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgYW51bWJlcihsZW4pO1xuICBhZm4oZm4pO1xuICByZXR1cm4ge1xuICAgIGVuY29kZShkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgY29uc3Qgc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICByZXMuc2V0KHN1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH0sXG4gIH07XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IHV0aWxzOiB7IGFscGhhYmV0OiB0eXBlb2YgYWxwaGFiZXQ7IGNoYWluOiB0eXBlb2YgY2hhaW47IGNoZWNrc3VtOiB0eXBlb2YgY2hlY2tzdW07IGNvbnZlcnRSYWRpeDogdHlwZW9mIGNvbnZlcnRSYWRpeDsgY29udmVydFJhZGl4MjogdHlwZW9mIGNvbnZlcnRSYWRpeDI7IHJhZGl4OiB0eXBlb2YgcmFkaXg7IHJhZGl4MjogdHlwZW9mIHJhZGl4Mjsgam9pbjogdHlwZW9mIGpvaW47IHBhZGRpbmc6IHR5cGVvZiBwYWRkaW5nOyB9ID0ge1xuICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuXG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIGJhc2UxNiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMTYuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcxMkFCJ1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMTY6IEJ5dGVzQ29kZXIgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcblxuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gSGFzIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2UzMm5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEFsc28gY2hlY2sgb3V0IGBiYXNlMzJoZXhgLCBgYmFzZTMyaGV4bm9wYWRgLCBgYmFzZTMyY3JvY2tmb3JkYC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTMyLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnQ0tWUT09PT0nXG4gKiBiYXNlMzIuZGVjb2RlKCdDS1ZRPT09PScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyOiBCeXRlc0NvZGVyID0gY2hhaW4oXG4gIHJhZGl4Mig1KSxcbiAgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksXG4gIHBhZGRpbmcoNSksXG4gIGpvaW4oJycpXG4pO1xuXG4vKipcbiAqIGJhc2UzMiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LiBObyBwYWRkaW5nLlxuICogVXNlIGBiYXNlMzJgIGZvciBwYWRkZWQgdmVyc2lvbi5cbiAqIEFsc28gY2hlY2sgb3V0IGBiYXNlMzJoZXhgLCBgYmFzZTMyaGV4bm9wYWRgLCBgYmFzZTMyY3JvY2tmb3JkYC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTMybm9wYWQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICdDS1ZRJ1xuICogYmFzZTMybm9wYWQuZGVjb2RlKCdDS1ZRJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMzJub3BhZDogQnl0ZXNDb2RlciA9IGNoYWluKFxuICByYWRpeDIoNSksXG4gIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLFxuICBqb2luKCcnKVxuKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIFBhZGRlZC4gQ29tcGFyZWQgdG8gb3JkaW5hcnkgYGJhc2UzMmAsIHNsaWdodGx5IGRpZmZlcmVudCBhbHBoYWJldC5cbiAqIFVzZSBgYmFzZTMyaGV4bm9wYWRgIGZvciB1bnBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJoZXguZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcyQUxHPT09PSdcbiAqIGJhc2UzMmhleC5kZWNvZGUoJzJBTEc9PT09Jyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMzJoZXg6IEJ5dGVzQ29kZXIgPSBjaGFpbihcbiAgcmFkaXgyKDUpLFxuICBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSxcbiAgcGFkZGluZyg1KSxcbiAgam9pbignJylcbik7XG5cbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuIENvbXBhcmVkIHRvIG9yZGluYXJ5IGBiYXNlMzJgLCBzbGlnaHRseSBkaWZmZXJlbnQgYWxwaGFiZXQuXG4gKiBVc2UgYGJhc2UzMmhleGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJoZXhub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEcnXG4gKiBiYXNlMzJoZXhub3BhZC5kZWNvZGUoJzJBTEcnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleG5vcGFkOiBCeXRlc0NvZGVyID0gY2hhaW4oXG4gIHJhZGl4Mig1KSxcbiAgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksXG4gIGpvaW4oJycpXG4pO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gRG91ZyBDcm9ja2ZvcmQncyB2ZXJzaW9uLlxuICogaHR0cHM6Ly93d3cuY3JvY2tmb3JkLmNvbS9iYXNlMzIuaHRtbFxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJjcm9ja2ZvcmQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcyQU5HJ1xuICogYmFzZTMyY3JvY2tmb3JkLmRlY29kZSgnMkFORycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkOiBCeXRlc0NvZGVyID0gY2hhaW4oXG4gIHJhZGl4Mig1KSxcbiAgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksXG4gIGpvaW4oJycpLFxuICBub3JtYWxpemUoKHM6IHN0cmluZykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpXG4pO1xuXG4vLyBCdWlsdC1pbiBiYXNlNjQgY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWJhc2U2NFxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNCYXNlNjRCdWlsdGluOiBib29sZWFuID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICB0eXBlb2YgKFVpbnQ4QXJyYXkgYXMgYW55KS5mcm9tKFtdKS50b0Jhc2U2NCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgKFVpbnQ4QXJyYXkgYXMgYW55KS5mcm9tQmFzZTY0ID09PSAnZnVuY3Rpb24nKSgpO1xuXG5jb25zdCBkZWNvZGVCYXNlNjRCdWlsdGluID0gKHM6IHN0cmluZywgaXNVcmw6IGJvb2xlYW4pID0+IHtcbiAgYXN0cignYmFzZTY0Jywgcyk7XG4gIGNvbnN0IHJlID0gaXNVcmwgPyAvXltBLVphLXowLTk9Xy1dKyQvIDogL15bQS1aYS16MC05PSsvXSskLztcbiAgY29uc3QgYWxwaGFiZXQgPSBpc1VybCA/ICdiYXNlNjR1cmwnIDogJ2Jhc2U2NCc7XG4gIGlmIChzLmxlbmd0aCA+IDAgJiYgIXJlLnRlc3QocykpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlNjQnKTtcbiAgcmV0dXJuIChVaW50OEFycmF5IGFzIGFueSkuZnJvbUJhc2U2NChzLCB7IGFscGhhYmV0LCBsYXN0Q2h1bmtIYW5kbGluZzogJ3N0cmljdCcgfSk7XG59O1xuXG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LiBQYWRkZWQuXG4gKiBVc2UgYGJhc2U2NG5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEFsc28gY2hlY2sgb3V0IGBiYXNlNjR1cmxgLCBgYmFzZTY0dXJsbm9wYWRgLlxuICogRmFsbHMgYmFjayB0byBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0Vxcz0nXG4gKiBiYXNlNjQuZGVjb2RlKCdFcXM9Jyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IGJhc2U2NDogQnl0ZXNDb2RlciA9IGhhc0Jhc2U2NEJ1aWx0aW4gPyB7XG4gIGVuY29kZShiKSB7IGFieXRlcyhiKTsgcmV0dXJuIChiIGFzIGFueSkudG9CYXNlNjQoKTsgfSxcbiAgZGVjb2RlKHMpIHsgcmV0dXJuIGRlY29kZUJhc2U2NEJ1aWx0aW4ocywgZmFsc2UpOyB9LFxufSA6IGNoYWluKFxuICByYWRpeDIoNiksXG4gIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksXG4gIHBhZGRpbmcoNiksXG4gIGpvaW4oJycpXG4pO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTY0YCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzJ1xuICogYmFzZTY0bm9wYWQuZGVjb2RlKCdFcXMnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkOiBCeXRlc0NvZGVyID0gY2hhaW4oXG4gIHJhZGl4Mig2KSxcbiAgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSxcbiAgam9pbignJylcbik7XG5cbi8qKlxuICogYmFzZTY0IGZyb20gUkZDIDQ2NDgsIHVzaW5nIFVSTC1zYWZlIGFscGhhYmV0LiBQYWRkZWQuXG4gKiBVc2UgYGJhc2U2NHVybG5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEZhbGxzIGJhY2sgdG8gYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmwuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICdFcXM9J1xuICogYmFzZTY0dXJsLmRlY29kZSgnRXFzPScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmw6IEJ5dGVzQ29kZXIgPSBoYXNCYXNlNjRCdWlsdGluID8ge1xuICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiAoYiBhcyBhbnkpLnRvQmFzZTY0KHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnIH0pOyB9LFxuICBkZWNvZGUocykgeyByZXR1cm4gZGVjb2RlQmFzZTY0QnVpbHRpbihzLCB0cnVlKTsgfSxcbn0gOiBjaGFpbihcbiAgcmFkaXgyKDYpLFxuICBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLFxuICBwYWRkaW5nKDYpLFxuICBqb2luKCcnKVxuKTtcblxuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OCwgdXNpbmcgVVJMLXNhZmUgYWxwaGFiZXQuIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2U2NHVybGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmxub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0VxcydcbiAqIGJhc2U2NHVybG5vcGFkLmRlY29kZSgnRXFzJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZDogQnl0ZXNDb2RlciA9IGNoYWluKFxuICByYWRpeDIoNiksXG4gIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksXG4gIGpvaW4oJycpXG4pO1xuXG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhYmM6IHN0cmluZykgPT5cbiAgY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5cbi8qKlxuICogYmFzZTU4OiBiYXNlNjQgd2l0aG91dCBhbWJpZ291cyBjaGFyYWN0ZXJzICssIC8sIDAsIE8sIEksIGwuXG4gKiBRdWFkcmF0aWMgKE8obl4yKSkgLSBzbywgY2FuJ3QgYmUgdXNlZCBvbiBsYXJnZSBpbnB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U1OC5kZWNvZGUoJzAxYWJjZGVmJyk7XG4gKiAvLyA9PiAnM1VoSlcnXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1ODogQnl0ZXNDb2RlciA9IGdlbkJhc2U1OChcbiAgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG4pO1xuLyoqXG4gKiBiYXNlNTg6IGZsaWNrciB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3I6IEJ5dGVzQ29kZXIgPSBnZW5CYXNlNTgoXG4gICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ1xuKTtcbi8qKlxuICogYmFzZTU4OiBYUlAgdmVyc2lvbi4gQ2hlY2sgb3V0IGBiYXNlNThgLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eHJwOiBCeXRlc0NvZGVyID0gZ2VuQmFzZTU4KFxuICAncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eidcbik7XG5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcblxuLyoqXG4gKiBiYXNlNTg6IFhNUiB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKiBEb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuICogQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtcjogQnl0ZXNDb2RlciA9IHtcbiAgZW5jb2RlKGRhdGE6IFVpbnQ4QXJyYXkpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSEsICcxJyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGRlY29kZShzdHI6IHN0cmluZykge1xuICAgIGxldCByZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgfVxuICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gIH0sXG59O1xuXG4vKipcbiAqIE1ldGhvZCwgd2hpY2ggY3JlYXRlcyBiYXNlNThjaGVjayBlbmNvZGVyLlxuICogUmVxdWlyZXMgZnVuY3Rpb24sIGNhbGN1bGF0aW5nIHNoYTI1Ni5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gKHNoYTI1NjogKGRhdGE6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXkpOiBCeXRlc0NvZGVyID0+XG4gIGNoYWluKFxuICAgIGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksXG4gICAgYmFzZTU4XG4gICk7XG5cbi8qKlxuICogVXNlIGBjcmVhdGVCYXNlNThjaGVja2AgaW5zdGVhZC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjazogKHNoYTI1NjogKGRhdGE6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXkpID0+IEJ5dGVzQ29kZXIgPVxuICBjcmVhdGVCYXNlNThjaGVjaztcblxuLy8gQmVjaDMyIGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5leHBvcnQgaW50ZXJmYWNlIEJlY2gzMkRlY29kZWQ8UHJlZml4IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHByZWZpeDogUHJlZml4O1xuICB3b3JkczogbnVtYmVyW107XG59XG5leHBvcnQgaW50ZXJmYWNlIEJlY2gzMkRlY29kZWRXaXRoQXJyYXk8UHJlZml4IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHByZWZpeDogUHJlZml4O1xuICB3b3JkczogbnVtYmVyW107XG4gIGJ5dGVzOiBVaW50OEFycmF5O1xufVxuXG5jb25zdCBCRUNIX0FMUEhBQkVUOiBDb2RlcjxudW1iZXJbXSwgc3RyaW5nPiA9IGNoYWluKFxuICBhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSxcbiAgam9pbignJylcbik7XG5cbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBiID0gcHJlID4+IDI1O1xuICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV0hO1xuICB9XG4gIHJldHVybiBjaGs7XG59XG5cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXg6IHN0cmluZywgd29yZHM6IG51bWJlcltdLCBlbmNvZGluZ0NvbnN0ID0gMSk6IHN0cmluZyB7XG4gIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gIGxldCBjaGsgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNikgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICB9XG4gIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gIGZvciAobGV0IHYgb2Ygd29yZHMpIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgcG93ZXJzWzMwXSFdLCAzMCwgNSwgZmFsc2UpKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCZWNoMzIge1xuICBlbmNvZGU8UHJlZml4IGV4dGVuZHMgc3RyaW5nPihcbiAgICBwcmVmaXg6IFByZWZpeCxcbiAgICB3b3JkczogbnVtYmVyW10gfCBVaW50OEFycmF5LFxuICAgIGxpbWl0PzogbnVtYmVyIHwgZmFsc2VcbiAgKTogYCR7TG93ZXJjYXNlPFByZWZpeD59MSR7c3RyaW5nfWA7XG4gIGRlY29kZTxQcmVmaXggZXh0ZW5kcyBzdHJpbmc+KFxuICAgIHN0cjogYCR7UHJlZml4fTEke3N0cmluZ31gLFxuICAgIGxpbWl0PzogbnVtYmVyIHwgZmFsc2VcbiAgKTogQmVjaDMyRGVjb2RlZDxQcmVmaXg+O1xuICBlbmNvZGVGcm9tQnl0ZXMocHJlZml4OiBzdHJpbmcsIGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nO1xuICBkZWNvZGVUb0J5dGVzKHN0cjogc3RyaW5nKTogQmVjaDMyRGVjb2RlZFdpdGhBcnJheTtcbiAgZGVjb2RlVW5zYWZlKHN0cjogc3RyaW5nLCBsaW1pdD86IG51bWJlciB8IGZhbHNlKTogdm9pZCB8IEJlY2gzMkRlY29kZWQ8c3RyaW5nPjtcbiAgZnJvbVdvcmRzKHRvOiBudW1iZXJbXSk6IFVpbnQ4QXJyYXk7XG4gIGZyb21Xb3Jkc1Vuc2FmZSh0bzogbnVtYmVyW10pOiB2b2lkIHwgVWludDhBcnJheTtcbiAgdG9Xb3Jkcyhmcm9tOiBVaW50OEFycmF5KTogbnVtYmVyW107XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZzogJ2JlY2gzMicgfCAnYmVjaDMybScpOiBCZWNoMzIge1xuICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlPFByZWZpeCBleHRlbmRzIHN0cmluZz4oXG4gICAgcHJlZml4OiBQcmVmaXgsXG4gICAgd29yZHM6IG51bWJlcltdIHwgVWludDhBcnJheSxcbiAgICBsaW1pdDogbnVtYmVyIHwgZmFsc2UgPSA5MFxuICApOiBgJHtMb3dlcmNhc2U8UHJlZml4Pn0xJHtzdHJpbmd9YCB7XG4gICAgYXN0cignYmVjaDMyLmVuY29kZSBwcmVmaXgnLCBwcmVmaXgpO1xuICAgIGlmIChpc0J5dGVzKHdvcmRzKSkgd29yZHMgPSBBcnJheS5mcm9tKHdvcmRzKTtcbiAgICBhbnVtQXJyKCdiZWNoMzIuZW5jb2RlJywgd29yZHMpO1xuICAgIGNvbnN0IHBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGlmIChwbGVuID09PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwbGVufWApO1xuICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHBsZW4gKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgcmV0dXJuIGAke2xvd2VyZWR9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7c3VtfWAgYXMgYCR7TG93ZXJjYXNlPFByZWZpeD59MSR7c3RyaW5nfWA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGU8UHJlZml4IGV4dGVuZHMgc3RyaW5nPihcbiAgICBzdHI6IGAke1ByZWZpeH0xJHtzdHJpbmd9YCxcbiAgICBsaW1pdD86IG51bWJlciB8IGZhbHNlXG4gICk6IEJlY2gzMkRlY29kZWQ8UHJlZml4PjtcbiAgZnVuY3Rpb24gZGVjb2RlKHN0cjogc3RyaW5nLCBsaW1pdD86IG51bWJlciB8IGZhbHNlKTogQmVjaDMyRGVjb2RlZDtcbiAgZnVuY3Rpb24gZGVjb2RlKHN0cjogc3RyaW5nLCBsaW1pdDogbnVtYmVyIHwgZmFsc2UgPSA5MCk6IEJlY2gzMkRlY29kZWQge1xuICAgIGFzdHIoJ2JlY2gzMi5kZWNvZGUgaW5wdXQnLCBzdHIpO1xuICAgIGNvbnN0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGlmIChzbGVuIDwgOCB8fCAobGltaXQgIT09IGZhbHNlICYmIHNsZW4gPiBsaW1pdCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIHN0cmluZyBsZW5ndGg6ICR7c2xlbn0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgNikgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICB9XG5cbiAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuXG4gIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyOiBzdHJpbmcpOiBCZWNoMzJEZWNvZGVkV2l0aEFycmF5IHtcbiAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlRnJvbUJ5dGVzKHByZWZpeDogc3RyaW5nLCBieXRlczogVWludDhBcnJheSkge1xuICAgIHJldHVybiBlbmNvZGUocHJlZml4LCB0b1dvcmRzKGJ5dGVzKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgIGRlY29kZVRvQnl0ZXMsXG4gICAgZGVjb2RlVW5zYWZlLFxuICAgIGZyb21Xb3JkcyxcbiAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgdG9Xb3JkcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBiZWNoMzIgZnJvbSBCSVAgMTczLiBPcGVyYXRlcyBvbiB3b3Jkcy5cbiAqIEZvciBoaWdoLWxldmVsLCBjaGVjayBvdXQgc2N1cmUtYnRjLXNpZ25lcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYnRjLXNpZ25lci5cbiAqL1xuZXhwb3J0IGNvbnN0IGJlY2gzMjogQmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcblxuLyoqXG4gKiBiZWNoMzJtIGZyb20gQklQIDM1MC4gT3BlcmF0ZXMgb24gd29yZHMuXG4gKiBJdCB3YXMgdG8gbWl0aWdhdGUgYGJlY2gzMmAgd2Vha25lc3Nlcy5cbiAqIEZvciBoaWdoLWxldmVsLCBjaGVjayBvdXQgc2N1cmUtYnRjLXNpZ25lcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYnRjLXNpZ25lci5cbiAqL1xuZXhwb3J0IGNvbnN0IGJlY2gzMm06IEJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuXG5kZWNsYXJlIGNvbnN0IFRleHRFbmNvZGVyOiBhbnk7XG5kZWNsYXJlIGNvbnN0IFRleHREZWNvZGVyOiBhbnk7XG5cbi8qKlxuICogVVRGLTgtdG8tYnl0ZSBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIFRleHREZWNvZGVyIC8gVGV4dEVuY29kZXIuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGIgPSB1dGY4LmRlY29kZShcImhleVwiKTsgLy8gPT4gbmV3IFVpbnQ4QXJyYXkoWyAxMDQsIDEwMSwgMTIxIF0pXG4gKiBjb25zdCBzdHIgPSB1dGY4LmVuY29kZShiKTsgLy8gXCJoZXlcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4OiBCeXRlc0NvZGVyID0ge1xuICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuXG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNIZXhCdWlsdGluOiBib29sZWFuID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICB0eXBlb2YgKFVpbnQ4QXJyYXkgYXMgYW55KS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgKFVpbnQ4QXJyYXkgYXMgYW55KS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoZXhCdWlsdGluOiBCeXRlc0NvZGVyID0ge1xuICBlbmNvZGUoZGF0YSkgeyBhYnl0ZXMoZGF0YSk7IHJldHVybiAoZGF0YSBhcyBhbnkpLnRvSGV4KCk7IH0sXG4gIGRlY29kZShzKSB7IGFzdHIoJ2hleCcsIHMpOyByZXR1cm4gKFVpbnQ4QXJyYXkgYXMgYW55KS5mcm9tSGV4KHMpOyB9LFxufTtcbi8qKlxuICogaGV4IHN0cmluZyBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgYiA9IGhleC5kZWNvZGUoXCIwMTAyZmZcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMSwgMiwgMjU1IF0pXG4gKiBjb25zdCBzdHIgPSBoZXguZW5jb2RlKGIpOyAvLyBcIjAxMDJmZlwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGhleDogQnl0ZXNDb2RlciA9IGhhc0hleEJ1aWx0aW5cbiAgPyBoZXhCdWlsdGluXG4gIDogY2hhaW4oXG4gICAgICByYWRpeDIoNCksXG4gICAgICBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLFxuICAgICAgam9pbignJyksXG4gICAgICBub3JtYWxpemUoKHM6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YFxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KVxuICAgICk7XG5cbmV4cG9ydCB0eXBlIFNvbWVDb2RlcnMgPSB7XG4gIHV0Zjg6IEJ5dGVzQ29kZXI7XG4gIGhleDogQnl0ZXNDb2RlcjtcbiAgYmFzZTE2OiBCeXRlc0NvZGVyO1xuICBiYXNlMzI6IEJ5dGVzQ29kZXI7XG4gIGJhc2U2NDogQnl0ZXNDb2RlcjtcbiAgYmFzZTY0dXJsOiBCeXRlc0NvZGVyO1xuICBiYXNlNTg6IEJ5dGVzQ29kZXI7XG4gIGJhc2U1OHhtcjogQnl0ZXNDb2Rlcjtcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUzogU29tZUNvZGVycyA9IHtcbiAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xudHlwZSBDb2RlclR5cGUgPSBrZXlvZiBTb21lQ29kZXJzO1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPVxuICAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZTogQ29kZXJUeXBlLCBieXRlczogVWludDhBcnJheSk6IHN0cmluZyA9PiB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gIGlmICghaXNCeXRlcyhieXRlcykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3Qgc3RyOiAodHlwZTogQ29kZXJUeXBlLCBieXRlczogVWludDhBcnJheSkgPT4gc3RyaW5nID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlOiBDb2RlclR5cGUsIHN0cjogc3RyaW5nKTogVWludDhBcnJheSA9PiB7XG4gIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlczogKHR5cGU6IENvZGVyVHlwZSwgc3RyOiBzdHJpbmcpID0+IFVpbnQ4QXJyYXkgPSBzdHJpbmdUb0J5dGVzO1xuIiwgIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jaXBoZXJzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGE6IHVua25vd24pOiBhIGlzIFVpbnQ4QXJyYXkge1xuICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG5cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBib29sZWFuLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKGI6IGJvb2xlYW4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcihgYm9vbGVhbiBleHBlY3RlZCwgbm90ICR7Yn1gKTtcbn1cblxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuOiBudW1iZXIpOiB2b2lkIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuXG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXModmFsdWU6IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlciwgdGl0bGU6IHN0cmluZyA9ICcnKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJ5dGVzID0gaXNCeXRlcyh2YWx1ZSk7XG4gIGNvbnN0IGxlbiA9IHZhbHVlPy5sZW5ndGg7XG4gIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gIGlmICghYnl0ZXMgfHwgKG5lZWRzTGVuICYmIGxlbiAhPT0gbGVuZ3RoKSkge1xuICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICBjb25zdCBvZkxlbiA9IG5lZWRzTGVuID8gYCBvZiBsZW5ndGggJHtsZW5ndGh9YCA6ICcnO1xuICAgIGNvbnN0IGdvdCA9IGJ5dGVzID8gYGxlbmd0aD0ke2xlbn1gIDogYHR5cGU9JHt0eXBlb2YgdmFsdWV9YDtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZTogYW55LCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSk6IHZvaWQge1xuICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cblxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dDogYW55LCBpbnN0YW5jZTogYW55KTogdm9pZCB7XG4gIGFieXRlcyhvdXQsIHVuZGVmaW5lZCwgJ291dHB1dCcpO1xuICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBJSGFzaCA9IHtcbiAgKGRhdGE6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgY3JlYXRlOiBhbnk7XG59O1xuXG4vKiogR2VuZXJpYyB0eXBlIGVuY29tcGFzc2luZyA4LzE2LzMyLWJ5dGUgYXJyYXlzIC0gYnV0IG5vdCA2NC1ieXRlLiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhDbGFtcGVkQXJyYXkgfCBVaW50OEFycmF5IHxcbiAgVWludDE2QXJyYXkgfCBJbnQxNkFycmF5IHwgVWludDMyQXJyYXkgfCBJbnQzMkFycmF5O1xuXG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnI6IFR5cGVkQXJyYXkpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyOiBUeXBlZEFycmF5KTogVWludDMyQXJyYXkge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuXG4vKiogWmVyb2l6ZSBhIGJ5dGUgYXJyYXkuIFdhcm5pbmc6IEpTIHByb3ZpZGVzIG5vIGd1YXJhbnRlZXMuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzOiBUeXBlZEFycmF5W10pOiB2b2lkIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgfVxufVxuXG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyOiBUeXBlZEFycmF5KTogRGF0YVZpZXcge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFOiBib29sZWFuID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuXG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbjogYm9vbGVhbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuXG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PlxuICBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpXG4pO1xuXG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBhYnl0ZXMoYnl0ZXMpO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChoYXNIZXhCdWlsdGluKSByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gIGxldCBoZXggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cblxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9IGFzIGNvbnN0O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaDogbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRikgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGhhc0hleEJ1aWx0aW4pIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgaWYgKGhsICUgMikgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICB9XG4gICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIFVzZWQgaW4gbWljcm9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXg6IHN0cmluZyk6IGJpZ2ludCB7XG4gIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiAnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuXG4vLyBVc2VkIGluIGZmMVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cblxuLy8gVXNlZCBpbiBtaWNybywgZmYxXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG46IG51bWJlciB8IGJpZ2ludCwgbGVuOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5cbi8vIEdsb2JhbCBzeW1ib2xzLCBidXQgdHMgZG9lc24ndCBzZWUgdGhlbTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTUzNVxuZGVjbGFyZSBjb25zdCBUZXh0RW5jb2RlcjogYW55O1xuZGVjbGFyZSBjb25zdCBUZXh0RGVjb2RlcjogYW55O1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgobmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBVOEEgdXNlIHNhbWUgdW5kZXJseWluZyBidWZmZXIgYW5kIG92ZXJsYXBzLlxuICogVGhpcyBpcyBpbnZhbGlkIGFuZCBjYW4gY29ycnVwdCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxhcEJ5dGVzKGE6IFVpbnQ4QXJyYXksIGI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBhLmJ1ZmZlciA9PT0gYi5idWZmZXIgJiYgLy8gYmVzdCB3ZSBjYW4gZG8sIG1heSBmYWlsIHdpdGggYW4gb2JzY3VyZSBQcm94eVxuICAgIGEuYnl0ZU9mZnNldCA8IGIuYnl0ZU9mZnNldCArIGIuYnl0ZUxlbmd0aCAmJiAvLyBhIHN0YXJ0cyBiZWZvcmUgYiBlbmRcbiAgICBiLmJ5dGVPZmZzZXQgPCBhLmJ5dGVPZmZzZXQgKyBhLmJ5dGVMZW5ndGggLy8gYiBzdGFydHMgYmVmb3JlIGEgZW5kXG4gICk7XG59XG5cbi8qKlxuICogSWYgaW5wdXQgYW5kIG91dHB1dCBvdmVybGFwIGFuZCBpbnB1dCBzdGFydHMgYmVmb3JlIG91dHB1dCwgd2Ugd2lsbCBvdmVyd3JpdGUgZW5kIG9mIGlucHV0IGJlZm9yZVxuICogd2Ugc3RhcnQgcHJvY2Vzc2luZyBpdCwgc28gdGhpcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBtb3N0IGNpcGhlcnMgKGV4Y2VwdCBjaGFjaGEvc2Fsc2UsIHdoaWNoIGRlc2lnbmVkIHdpdGggdGhpcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXhPdmVybGFwQnl0ZXMoaW5wdXQ6IFVpbnQ4QXJyYXksIG91dHB1dDogVWludDhBcnJheSk6IHZvaWQge1xuICAvLyBUaGlzIGlzIHZlcnkgY3Vyc2VkLiBJdCB3b3JrcyBzb21laG93LCBidXQgSSdtIGNvbXBsZXRlbHkgdW5zdXJlLFxuICAvLyByZWFzb25pbmcgYWJvdXQgb3ZlcmxhcHBpbmcgYWxpZ25lZCB3aW5kb3dzIGlzIHZlcnkgaGFyZC5cbiAgaWYgKG92ZXJsYXBCeXRlcyhpbnB1dCwgb3V0cHV0KSAmJiBpbnB1dC5ieXRlT2Zmc2V0IDwgb3V0cHV0LmJ5dGVPZmZzZXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wbGV4IG92ZXJsYXAgb2YgaW5wdXQgYW5kIG91dHB1dCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXM6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkge1xuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgIGFieXRlcyhhKTtcbiAgICBzdW0gKz0gYS5sZW5ndGg7XG4gIH1cbiAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICBwYWQgKz0gYS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gVXNlZCBpbiBBUlggb25seVxudHlwZSBFbXB0eU9iaiA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0czxUMSBleHRlbmRzIEVtcHR5T2JqLCBUMiBleHRlbmRzIEVtcHR5T2JqPihcbiAgZGVmYXVsdHM6IFQxLFxuICBvcHRzOiBUMlxuKTogVDEgJiBUMiB7XG4gIGlmIChvcHRzID09IG51bGwgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICByZXR1cm4gbWVyZ2VkIGFzIFQxICYgVDI7XG59XG5cbi8qKiBDb21wYXJlcyAyIHVpbnQ4YXJyYXktcyBpbiBraW5kYSBjb25zdGFudCB0aW1lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBkaWZmID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cblxuLy8gVE9ETzogcmVtb3ZlXG5leHBvcnQgaW50ZXJmYWNlIElIYXNoMiB7XG4gIGJsb2NrTGVuOiBudW1iZXI7IC8vIEJ5dGVzIHBlciBibG9ja1xuICBvdXRwdXRMZW46IG51bWJlcjsgLy8gQnl0ZXMgaW4gb3V0cHV0XG4gIHVwZGF0ZShidWY6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiB0aGlzO1xuICAvLyBXcml0ZXMgZGlnZXN0IGludG8gYnVmXG4gIGRpZ2VzdEludG8oYnVmOiBVaW50OEFycmF5KTogdm9pZDtcbiAgZGlnZXN0KCk6IFVpbnQ4QXJyYXk7XG4gIC8qKlxuICAgKiBSZXNldHMgaW50ZXJuYWwgc3RhdGUuIE1ha2VzIEhhc2ggaW5zdGFuY2UgdW51c2FibGUuXG4gICAqIFJlc2V0IGlzIGltcG9zc2libGUgZm9yIGtleWVkIGhhc2hlcyBpZiBrZXkgaXMgY29uc3VtZWQgaW50byBzdGF0ZS4gSWYgZGlnZXN0IGlzIG5vdCBjb25zdW1lZFxuICAgKiBieSB1c2VyLCB0aGV5IHdpbGwgbmVlZCB0byBtYW51YWxseSBjYWxsIGBkZXN0cm95KClgIHdoZW4gemVyb2luZyBpcyBuZWNlc3NhcnkuXG4gICAqL1xuICBkZXN0cm95KCk6IHZvaWQ7XG59XG5cbi8vIFRoaXMgd2lsbCBhbGxvdyB0byByZS11c2Ugd2l0aCBjb21wb3NhYmxlIHRoaW5ncyBsaWtlIHBhY2tlZCAmIGJhc2UgZW5jb2RlcnNcbi8vIEFsc28sIHdlIHByb2JhYmx5IGNhbiBtYWtlIHRhZ3MgY29tcG9zYWJsZVxuXG4vKiogU3luYyBjaXBoZXI6IHRha2VzIGJ5dGUgYXJyYXkgYW5kIHJldHVybnMgYnl0ZSBhcnJheS4gKi9cbmV4cG9ydCB0eXBlIENpcGhlciA9IHtcbiAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xufTtcblxuLyoqIEFzeW5jIGNpcGhlciBlLmcuIGZyb20gYnVpbHQtaW4gV2ViQ3J5cHRvLiAqL1xuZXhwb3J0IHR5cGUgQXN5bmNDaXBoZXIgPSB7XG4gIGVuY3J5cHQocGxhaW50ZXh0OiBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PjtcbiAgZGVjcnlwdChjaXBoZXJ0ZXh0OiBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5Pjtcbn07XG5cbi8qKiBDaXBoZXIgd2l0aCBgb3V0cHV0YCBhcmd1bWVudCB3aGljaCBjYW4gb3B0aW1pemUgYnkgZG9pbmcgMSBsZXNzIGFsbG9jYXRpb24uICovXG5leHBvcnQgdHlwZSBDaXBoZXJXaXRoT3V0cHV0ID0gQ2lwaGVyICYge1xuICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSwgb3V0cHV0PzogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG4gIGRlY3J5cHQoY2lwaGVydGV4dDogVWludDhBcnJheSwgb3V0cHV0PzogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG59O1xuXG4vKipcbiAqIFBhcmFtcyBhcmUgb3V0c2lkZSBvZiByZXR1cm4gdHlwZSwgc28gaXQgaXMgYWNjZXNzaWJsZSBiZWZvcmUgY2FsbGluZyBjb25zdHJ1Y3Rvci5cbiAqIElmIGZ1bmN0aW9uIHN1cHBvcnQgbXVsdGlwbGUgbm9uY2VMZW5ndGgncywgd2UgcmV0dXJuIHRoZSBiZXN0IG9uZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2lwaGVyUGFyYW1zID0ge1xuICBibG9ja1NpemU6IG51bWJlcjtcbiAgbm9uY2VMZW5ndGg/OiBudW1iZXI7XG4gIHRhZ0xlbmd0aD86IG51bWJlcjtcbiAgdmFyU2l6ZU5vbmNlPzogYm9vbGVhbjtcbn07XG4vKiogQVJYIGNpcGhlciwgbGlrZSBzYWxzYSBvciBjaGFjaGEuICovXG5leHBvcnQgdHlwZSBBUlhDaXBoZXIgPSAoKFxuICBrZXk6IFVpbnQ4QXJyYXksXG4gIG5vbmNlOiBVaW50OEFycmF5LFxuICBBQUQ/OiBVaW50OEFycmF5XG4pID0+IENpcGhlcldpdGhPdXRwdXQpICYge1xuICBibG9ja1NpemU6IG51bWJlcjtcbiAgbm9uY2VMZW5ndGg6IG51bWJlcjtcbiAgdGFnTGVuZ3RoOiBudW1iZXI7XG59O1xuZXhwb3J0IHR5cGUgQ2lwaGVyQ29uczxUIGV4dGVuZHMgYW55W10+ID0gKGtleTogVWludDhBcnJheSwgLi4uYXJnczogVCkgPT4gQ2lwaGVyO1xuLyoqXG4gKiBXcmFwcyBhIGNpcGhlcjogdmFsaWRhdGVzIGFyZ3MsIGVuc3VyZXMgZW5jcnlwdCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZXhwb3J0IGNvbnN0IHdyYXBDaXBoZXIgPSA8QyBleHRlbmRzIENpcGhlckNvbnM8YW55PiwgUCBleHRlbmRzIENpcGhlclBhcmFtcz4oXG4gIHBhcmFtczogUCxcbiAgY29uc3RydWN0b3I6IENcbik6IEMgJiBQID0+IHtcbiAgZnVuY3Rpb24gd3JhcHBlZENpcGhlcihrZXk6IFVpbnQ4QXJyYXksIC4uLmFyZ3M6IGFueVtdKTogQ2lwaGVyV2l0aE91dHB1dCB7XG4gICAgLy8gVmFsaWRhdGUga2V5XG4gICAgYWJ5dGVzKGtleSwgdW5kZWZpbmVkLCAna2V5Jyk7XG5cbiAgICAvLyBCaWctRW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4gICAgaWYgKCFpc0xFKSB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG5cbiAgICAvLyBWYWxpZGF0ZSBub25jZSBpZiBub25jZUxlbmd0aCBpcyBwcmVzZW50XG4gICAgaWYgKHBhcmFtcy5ub25jZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBub25jZSA9IGFyZ3NbMF07XG4gICAgICBhYnl0ZXMobm9uY2UsIHBhcmFtcy52YXJTaXplTm9uY2UgPyB1bmRlZmluZWQgOiBwYXJhbXMubm9uY2VMZW5ndGgsICdub25jZScpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIEFBRCBpZiB0YWdMZW5ndGggcHJlc2VudFxuICAgIGNvbnN0IHRhZ2wgPSBwYXJhbXMudGFnTGVuZ3RoO1xuICAgIGlmICh0YWdsICYmIGFyZ3NbMV0gIT09IHVuZGVmaW5lZCkgYWJ5dGVzKGFyZ3NbMV0sIHVuZGVmaW5lZCwgJ0FBRCcpO1xuXG4gICAgY29uc3QgY2lwaGVyID0gY29uc3RydWN0b3Ioa2V5LCAuLi5hcmdzKTtcbiAgICBjb25zdCBjaGVja091dHB1dCA9IChmbkxlbmd0aDogbnVtYmVyLCBvdXRwdXQ/OiBVaW50OEFycmF5KSA9PiB7XG4gICAgICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGZuTGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgRXJyb3IoJ2NpcGhlciBvdXRwdXQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBhYnl0ZXMob3V0cHV0LCB1bmRlZmluZWQsICdvdXRwdXQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIENyZWF0ZSB3cmFwcGVkIGNpcGhlciB3aXRoIHZhbGlkYXRpb24gYW5kIHNpbmdsZS11c2UgZW5jcnlwdGlvblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCB3ckNpcGhlciA9IHtcbiAgICAgIGVuY3J5cHQoZGF0YTogVWludDhBcnJheSwgb3V0cHV0PzogVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBlbmNyeXB0KCkgdHdpY2Ugd2l0aCBzYW1lIGtleSArIG5vbmNlJyk7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY2hlY2tPdXRwdXQoY2lwaGVyLmVuY3J5cHQubGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm4gKGNpcGhlciBhcyBDaXBoZXJXaXRoT3V0cHV0KS5lbmNyeXB0KGRhdGEsIG91dHB1dCk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdChkYXRhOiBVaW50OEFycmF5LCBvdXRwdXQ/OiBVaW50OEFycmF5KSB7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgaWYgKHRhZ2wgJiYgZGF0YS5sZW5ndGggPCB0YWdsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjaXBoZXJ0ZXh0XCIgZXhwZWN0ZWQgbGVuZ3RoIGJpZ2dlciB0aGFuIHRhZ0xlbmd0aD0nICsgdGFnbCk7XG4gICAgICAgIGNoZWNrT3V0cHV0KGNpcGhlci5kZWNyeXB0Lmxlbmd0aCwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIChjaXBoZXIgYXMgQ2lwaGVyV2l0aE91dHB1dCkuZGVjcnlwdChkYXRhLCBvdXRwdXQpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyQ2lwaGVyO1xuICB9XG5cbiAgT2JqZWN0LmFzc2lnbih3cmFwcGVkQ2lwaGVyLCBwYXJhbXMpO1xuICByZXR1cm4gd3JhcHBlZENpcGhlciBhcyBDICYgUDtcbn07XG5cbi8qKiBSZXByZXNlbnRzIHNhbHNhIC8gY2hhY2hhIHN0cmVhbS4gKi9cbmV4cG9ydCB0eXBlIFhvclN0cmVhbSA9IChcbiAga2V5OiBVaW50OEFycmF5LFxuICBub25jZTogVWludDhBcnJheSxcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb3V0cHV0PzogVWludDhBcnJheSxcbiAgY291bnRlcj86IG51bWJlclxuKSA9PiBVaW50OEFycmF5O1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHJldHVybnMgdThhIG9mIGxlbmd0aC5cbiAqIFdoZW4gb3V0IGlzIGF2YWlsYWJsZSwgaXQgY2hlY2tzIGl0IGZvciB2YWxpZGl0eSBhbmQgdXNlcyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE91dHB1dChcbiAgZXhwZWN0ZWRMZW5ndGg6IG51bWJlcixcbiAgb3V0PzogVWludDhBcnJheSxcbiAgb25seUFsaWduZWQgPSB0cnVlXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWRMZW5ndGgpO1xuICBpZiAob3V0Lmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1wib3V0cHV0XCIgZXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJywgZ290OiAnICsgb3V0Lmxlbmd0aFxuICAgICk7XG4gIGlmIChvbmx5QWxpZ25lZCAmJiAhaXNBbGlnbmVkMzIob3V0KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCwgbXVzdCBiZSBhbGlnbmVkJyk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1NjRMZW5ndGhzKGRhdGFMZW5ndGg6IG51bWJlciwgYWFkTGVuZ3RoOiBudW1iZXIsIGlzTEU6IGJvb2xlYW4pOiBVaW50OEFycmF5IHtcbiAgYWJvb2woaXNMRSk7XG4gIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcobnVtKTtcbiAgdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KGFhZExlbmd0aCksIGlzTEUpO1xuICB2aWV3LnNldEJpZ1VpbnQ2NCg4LCBCaWdJbnQoZGF0YUxlbmd0aCksIGlzTEUpO1xuICByZXR1cm4gbnVtO1xufVxuXG4vLyBJcyBieXRlIGFycmF5IGFsaWduZWQgdG8gNCBieXRlIG9mZnNldCAodTMyKT9cbmV4cG9ydCBmdW5jdGlvbiBpc0FsaWduZWQzMihieXRlczogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYnl0ZXMuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG5cbi8vIGNvcHkgYnl0ZXMgdG8gbmV3IHU4YSAoYWxpZ25lZCkuIEJlY2F1c2UgQnVmZmVyLnNsaWNlIGlzIGJyb2tlbi5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5Qnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShieXRlcyk7XG59XG5cbi8qKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgUFJORy4gVXNlcyBpbnRlcm5hbCBPUy1sZXZlbCBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBjciA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IChnbG9iYWxUaGlzIGFzIGFueSkuY3J5cHRvIDogbnVsbDtcbiAgaWYgKHR5cGVvZiBjcj8uZ2V0UmFuZG9tVmFsdWVzICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgcmV0dXJuIGNyLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xufVxuXG4vKipcbiAqIFRoZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBkb2Vzbid0IHdpcGUgY3VycmVudCBzdGF0ZTpcbiAqIGluc3RlYWQsIGl0IGdlbmVyYXRlcyBuZXcgb25lIGJhc2VkIG9uIHByZXZpb3VzIHN0YXRlICsgZW50cm9weS5cbiAqIE5vdCByZXNlZWQvcmVrZXksIHNpbmNlIEFFUyBDVFIgRFJCRyBkb2VzIHJla2V5IG9uIGVhY2ggcmFuZG9tQnl0ZXMsXG4gKiB3aGljaCBpcyBpbiBmYWN0IGByZXNlZWRgLCBzaW5jZSBpdCBjaGFuZ2VzIGNvdW50ZXIgdG9vLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBSRyB7XG4gIGFkZEVudHJvcHkoc2VlZDogVWludDhBcnJheSk6IHZvaWQ7XG4gIHJhbmRvbUJ5dGVzKGxlbmd0aDogbnVtYmVyKTogVWludDhBcnJheTtcbiAgY2xlYW4oKTogdm9pZDtcbn1cblxudHlwZSBSZW1vdmVOb25jZUlubmVyPFQgZXh0ZW5kcyBhbnlbXSwgUmV0PiA9ICgoLi4uYXJnczogVCkgPT4gUmV0KSBleHRlbmRzIChcbiAgYXJnMDogYW55LFxuICBhcmcxOiBhbnksXG4gIC4uLnJlc3Q6IGluZmVyIFJcbikgPT4gYW55XG4gID8gKGtleTogVWludDhBcnJheSwgLi4uYXJnczogUikgPT4gUmV0XG4gIDogbmV2ZXI7XG5cbmV4cG9ydCB0eXBlIFJlbW92ZU5vbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55KSA9PiBhbnk+ID0gUmVtb3ZlTm9uY2VJbm5lcjxcbiAgUGFyYW1ldGVyczxUPixcbiAgUmV0dXJuVHlwZTxUPlxuPjtcbmV4cG9ydCB0eXBlIENpcGhlcldpdGhOb25jZSA9ICgoXG4gIGtleTogVWludDhBcnJheSxcbiAgbm9uY2U6IFVpbnQ4QXJyYXksXG4gIC4uLmFyZ3M6IGFueVtdXG4pID0+IENpcGhlciB8IEFzeW5jQ2lwaGVyKSAmIHtcbiAgbm9uY2VMZW5ndGg6IG51bWJlcjtcbn07XG5cbi8qKlxuICogVXNlcyBDU1BSRyBmb3Igbm9uY2UsIG5vbmNlIGluamVjdGVkIGluIGNpcGhlcnRleHQuXG4gKiBGb3IgYGVuY3J5cHRgLCBhIGBub25jZUJ5dGVzYC1sZW5ndGggYnVmZmVyIGlzIGZldGNoZWQgZnJvbSBDU1BSTkcgYW5kXG4gKiBwcmVwZW5kZWQgdG8gZW5jcnlwdGVkIGNpcGhlcnRleHQuIEZvciBgZGVjcnlwdGAsIGZpcnN0IGBub25jZUJ5dGVzYCBvZiBjaXBoZXJ0ZXh0XG4gKiBhcmUgdHJlYXRlZCBhcyBub25jZS5cbiAqXG4gKiBOT1RFOiBVbmRlciB0aGUgc2FtZSBrZXksIHVzaW5nIHJhbmRvbSBub25jZXMgKGUuZy4gYG1hbmFnZWROb25jZWApIHdpdGggQUVTLUdDTSBhbmQgQ2hhQ2hhXG4gKiBzaG91bGQgYmUgbGltaXRlZCB0byBgMioqMjNgICg4TSkgbWVzc2FnZXMgdG8gZ2V0IGEgY29sbGlzaW9uIGNoYW5jZSBvZiBgMioqLTUwYC4gU3RyZXRjaGluZyB0byAgKiBgMioqMzJgICg0QikgbWVzc2FnZXMsIGNoYW5jZSB3b3VsZCBiZWNvbWUgYDIqKi0zM2AgLSBzdGlsbCBuZWdsaWdpYmxlLCBidXQgY3JlZXBpbmcgdXAuXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZ2NtID0gbWFuYWdlZE5vbmNlKGFlcy5nY20pO1xuICogY29uc3QgY2lwaHIgPSBnY20oa2V5KS5lbmNyeXB0KGRhdGEpO1xuICogY29uc3QgcGxhaW4gPSBnY20oa2V5KS5kZWNyeXB0KGNpcGgpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFuYWdlZE5vbmNlPFQgZXh0ZW5kcyBDaXBoZXJXaXRoTm9uY2U+KFxuICBmbjogVCxcbiAgcmFuZG9tQnl0ZXNfOiB0eXBlb2YgcmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlc1xuKTogUmVtb3ZlTm9uY2U8VD4ge1xuICBjb25zdCB7IG5vbmNlTGVuZ3RoIH0gPSBmbjtcbiAgYW51bWJlcihub25jZUxlbmd0aCk7XG4gIGNvbnN0IGFkZE5vbmNlID0gKG5vbmNlOiBVaW50OEFycmF5LCBjaXBoZXJ0ZXh0OiBVaW50OEFycmF5KSA9PiB7XG4gICAgY29uc3Qgb3V0ID0gY29uY2F0Qnl0ZXMobm9uY2UsIGNpcGhlcnRleHQpO1xuICAgIGNpcGhlcnRleHQuZmlsbCgwKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuICAvLyBOT1RFOiB3ZSBjYW5ub3Qgc3VwcG9ydCBEU1QgaGVyZSwgaXQgd291bGQgYmUgbWlzdGFrZTpcbiAgLy8gLSB3ZSBkb24ndCBrbm93IGhvdyBtdWNoIGRzdCBsZW5ndGggY2lwaGVyIHJlcXVpcmVzXG4gIC8vIC0gbm9uY2UgbWF5IHVuYWxpZ24gZHN0IGFuZCBicmVhayBldmVyeXRoaW5nXG4gIC8vIC0gd2UgY3JlYXRlIG5ldyB1OGEgYW55d2F5IChjb25jYXRCeXRlcylcbiAgLy8gLSBwcmV2aW91c2x5IHdlIHBhc3NlZCBhbGwgYXJncyB0byBjaXBoZXIsIGJ1dCB0aGF0IHdhcyBtaXN0YWtlIVxuICByZXR1cm4gKChrZXk6IFVpbnQ4QXJyYXksIC4uLmFyZ3M6IGFueVtdKTogYW55ID0+ICh7XG4gICAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIGFieXRlcyhwbGFpbnRleHQpO1xuICAgICAgY29uc3Qgbm9uY2UgPSByYW5kb21CeXRlc18obm9uY2VMZW5ndGgpO1xuICAgICAgY29uc3QgZW5jcnlwdGVkID0gZm4oa2V5LCBub25jZSwgLi4uYXJncykuZW5jcnlwdChwbGFpbnRleHQpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKGVuY3J5cHRlZCBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBlbmNyeXB0ZWQudGhlbigoY3QpID0+IGFkZE5vbmNlKG5vbmNlLCBjdCkpO1xuICAgICAgcmV0dXJuIGFkZE5vbmNlKG5vbmNlLCBlbmNyeXB0ZWQpO1xuICAgIH0sXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0OiBVaW50OEFycmF5KSB7XG4gICAgICBhYnl0ZXMoY2lwaGVydGV4dCk7XG4gICAgICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgbm9uY2VMZW5ndGgpO1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gY2lwaGVydGV4dC5zdWJhcnJheShub25jZUxlbmd0aCk7XG4gICAgICByZXR1cm4gZm4oa2V5LCBub25jZSwgLi4uYXJncykuZGVjcnlwdChkZWNyeXB0ZWQpO1xuICAgIH0sXG4gIH0pKSBhcyBSZW1vdmVOb25jZTxUPjtcbn1cblxuLy8gd29ya2Fyb3VuZCBmb3IgVFMgNS45IGxhbmd1YWdlIG1lc3M6XG5leHBvcnQgdHlwZSBVaW50OEFycmF5QnVmZmVyID0gUmV0dXJuVHlwZTx0eXBlb2YgVWludDhBcnJheS5vZj47XG4iLCAiLyoqXG4gKiBbQUVTXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkKVxuICogYS5rLmEuIEFkdmFuY2VkIEVuY3J5cHRpb24gU3RhbmRhcmRcbiAqIGlzIGEgdmFyaWFudCBvZiBSaWpuZGFlbCBibG9jayBjaXBoZXIsIHN0YW5kYXJkaXplZCBieSBOSVNUIGluIDIwMDEuXG4gKiBXZSBwcm92aWRlIHRoZSBmYXN0ZXN0IGF2YWlsYWJsZSBwdXJlIEpTIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIGBjaXBoZXIgPSBlbmNyeXB0KGJsb2NrLCBrZXkpYFxuICpcbiAqIERhdGEgaXMgc3BsaXQgaW50byAxMjgtYml0IGJsb2Nrcy4gRW5jcnlwdGVkIGluIDEwLzEyLzE0IHJvdW5kcyAoMTI4LzE5Mi8yNTYgYml0cykuIEluIGV2ZXJ5IHJvdW5kOlxuICogMS4gKipTLWJveCoqLCB0YWJsZSBzdWJzdGl0dXRpb25cbiAqIDIuICoqU2hpZnQgcm93cyoqLCBjeWNsaWMgc2hpZnQgbGVmdCBvZiBhbGwgcm93cyBvZiBkYXRhIGFycmF5XG4gKiAzLiAqKk1peCBjb2x1bW5zKiosIG11bHRpcGx5aW5nIGV2ZXJ5IGNvbHVtbiBieSBmaXhlZCBwb2x5bm9taWFsXG4gKiA0LiAqKkFkZCByb3VuZCBrZXkqKiwgcm91bmRfa2V5IHhvciBpLXRoIGNvbHVtbiBvZiBhcnJheVxuICpcbiAqIENoZWNrIG91dCBbRklQUy0xOTddKGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9maWxlcy9wdWJzL2ZpcHMvMTk3L2ZpbmFsL2RvY3MvZmlwcy0xOTcucGRmKSxcbiAqIFtOSVNUIDgwMC0zOEddKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9TcGVjaWFsUHVibGljYXRpb25zL05JU1QuU1AuODAwLTM4Ry5wZGYpXG4gKiBhbmQgW29yaWdpbmFsIHByb3Bvc2FsXShodHRwczovL2NzcmMubmlzdC5nb3YvY3NyYy9tZWRpYS9wcm9qZWN0cy9jcnlwdG9ncmFwaGljLXN0YW5kYXJkcy1hbmQtZ3VpZGVsaW5lcy9kb2N1bWVudHMvYWVzLWRldmVsb3BtZW50L3Jpam5kYWVsLWFtbWVuZGVkLnBkZilcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgZ2hhc2gsIHBvbHl2YWwgfSBmcm9tICcuL19wb2x5dmFsLnRzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHtcbiAgYWJ5dGVzLCBhbnVtYmVyLCBjbGVhbiwgY29tcGxleE92ZXJsYXBCeXRlcywgY29uY2F0Qnl0ZXMsXG4gIGNvcHlCeXRlcywgY3JlYXRlVmlldywgZXF1YWxCeXRlcywgZ2V0T3V0cHV0LCBpc0FsaWduZWQzMiwgb3ZlcmxhcEJ5dGVzLFxuICB1MzIsIHU2NExlbmd0aHMsIHU4LCB3cmFwQ2lwaGVyLFxuICB0eXBlIENpcGhlciwgdHlwZSBDaXBoZXJXaXRoT3V0cHV0LCB0eXBlIFBSRywgdHlwZSBVaW50OEFycmF5QnVmZmVyXG59IGZyb20gJy4vdXRpbHMudHMnO1xuXG5jb25zdCBCTE9DS19TSVpFID0gMTY7XG5jb25zdCBCTE9DS19TSVpFMzIgPSA0O1xuY29uc3QgRU1QVFlfQkxPQ0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG5jb25zdCBPTkVfQkxPQ0sgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKFtcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbl0pO1xuY29uc3QgUE9MWSA9IDB4MTFiOyAvLyAxICsgeCArIHgqKjMgKyB4Kio0ICsgeCoqOFxuXG5mdW5jdGlvbiB2YWxpZGF0ZUtleUxlbmd0aChrZXk6IFVpbnQ4QXJyYXkpIHtcbiAgaWYgKCFbMTYsIDI0LCAzMl0uaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImFlcyBrZXlcIiBleHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAxNi8yNC8zMiwgZ290IGxlbmd0aD0nICsga2V5Lmxlbmd0aCk7XG59XG5cbi8vIFRPRE86IHJlbW92ZSBtdWx0aXBsaWNhdGlvbiwgYmluYXJ5IG9wcyBvbmx5XG5mdW5jdGlvbiBtdWwyKG46IG51bWJlcikge1xuICByZXR1cm4gKG4gPDwgMSkgXiAoUE9MWSAmIC0obiA+PiA3KSk7XG59XG5cbmZ1bmN0aW9uIG11bChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yICg7IGIgPiAwOyBiID4+PSAxKSB7XG4gICAgLy8gTW9udGdvbWVyeSBsYWRkZXJcbiAgICByZXMgXj0gYSAmIC0oYiAmIDEpOyAvLyBpZiAoYiYxKSByZXMgXj1hIChidXQgY29uc3QtdGltZSkuXG4gICAgYSA9IG11bDIoYSk7IC8vIGEgPSAyKmFcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBJbmNyZW1lbnRzIGJpZ2ludCB3aXRoIHdyYXAgYXJvdW5kXG4vLyBOT1RFOiB3ZSBjYW5ub3QgdXNlIHUzMiBoZXJlIHNpbmNlIGl0IG1heSBvdmVyZmxvdyBvbiBjYXJyeSFcbmNvbnN0IGluY0J5dGVzID0gKGRhdGE6IFVpbnQ4QXJyYXksIGlzTEU6IGJvb2xlYW4sIGNhcnJ5OiBudW1iZXIgPSAxKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY2FycnkpKSB0aHJvdyBuZXcgRXJyb3IoJ2luY0J5dGVzOiB3cm9uZyBjYXJyeSAnICsgY2FycnkpO1xuICBhYnl0ZXMoZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9ICFpc0xFID8gZGF0YS5sZW5ndGggLSAxIC0gaSA6IGk7XG4gICAgY2FycnkgPSAoY2FycnkgKyAoZGF0YVtwb3NdICYgMHhmZikpIHwgMDtcbiAgICBkYXRhW3Bvc10gPSBjYXJyeSAmIDB4ZmY7XG4gICAgY2FycnkgPj4+PSA4O1xuICB9XG59O1xuXG4vLyBBRVMgUy1ib3ggaXMgZ2VuZXJhdGVkIHVzaW5nIGZpbml0ZSBmaWVsZCBpbnZlcnNpb24sXG4vLyBhbiBhZmZpbmUgdHJhbnNmb3JtLCBhbmQgeG9yIG9mIGEgY29uc3RhbnQgMHg2My5cbmNvbnN0IHNib3ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgdCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDI1NjsgaSsrLCB4IF49IG11bDIoeCkpIHRbaV0gPSB4O1xuICBjb25zdCBib3ggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBib3hbMF0gPSAweDYzOyAvLyBmaXJzdCBlbG1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuICAgIGxldCB4ID0gdFsyNTUgLSBpXTtcbiAgICB4IHw9IHggPDwgODtcbiAgICBib3hbdFtpXV0gPSAoeCBeICh4ID4+IDQpIF4gKHggPj4gNSkgXiAoeCA+PiA2KSBeICh4ID4+IDcpIF4gMHg2MykgJiAweGZmO1xuICB9XG4gIGNsZWFuKHQpO1xuICByZXR1cm4gYm94O1xufSkoKTtcblxuLy8gSW52ZXJ0ZWQgUy1ib3hcbmNvbnN0IGludlNib3ggPSAvKiBAX19QVVJFX18gKi8gc2JveC5tYXAoKF8sIGopID0+IHNib3guaW5kZXhPZihqKSk7XG5cbi8vIFJvdGF0ZSB1MzIgYnkgOFxuY29uc3Qgcm90cjMyXzggPSAobjogbnVtYmVyKSA9PiAobiA8PCAyNCkgfCAobiA+Pj4gOCk7XG5jb25zdCByb3RsMzJfOCA9IChuOiBudW1iZXIpID0+IChuIDw8IDgpIHwgKG4gPj4+IDI0KTtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKExFPC0+QkUpXG5jb25zdCBieXRlU3dhcCA9ICh3b3JkOiBudW1iZXIpID0+XG4gICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcblxuLy8gVC10YWJsZSBpcyBvcHRpbWl6YXRpb24gc3VnZ2VzdGVkIGluIDUuMiBvZiBvcmlnaW5hbCBwcm9wb3NhbCAobWlzc2VkIGZyb20gRklQUy0xOTcpLiBDaGFuZ2VzOlxuLy8gLSBMRSBpbnN0ZWFkIG9mIEJFXG4vLyAtIGJpZ2dlciB0YWJsZXM6IFQwIGFuZCBUMSBhcmUgbWVyZ2VkIGludG8gVDAxIHRhYmxlIGFuZCBUMiAmIFQzIGludG8gVDIzO1xuLy8gICBzbyBpbmRleCBpcyB1MTYsIGluc3RlYWQgb2YgdTguIFRoaXMgc3BlZWRzIHVwIHRoaW5ncywgdW5leHBlY3RlZGx5XG5mdW5jdGlvbiBnZW5UdGFibGUoc2JveDogVWludDhBcnJheSwgZm46IChuOiBudW1iZXIpID0+IG51bWJlcikge1xuICBpZiAoc2JveC5sZW5ndGggIT09IDI1NikgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBzYm94IGxlbmd0aCcpO1xuICBjb25zdCBUMCA9IG5ldyBVaW50MzJBcnJheSgyNTYpLm1hcCgoXywgaikgPT4gZm4oc2JveFtqXSkpO1xuICBjb25zdCBUMSA9IFQwLm1hcChyb3RsMzJfOCk7XG4gIGNvbnN0IFQyID0gVDEubWFwKHJvdGwzMl84KTtcbiAgY29uc3QgVDMgPSBUMi5tYXAocm90bDMyXzgpO1xuICBjb25zdCBUMDEgPSBuZXcgVWludDMyQXJyYXkoMjU2ICogMjU2KTtcbiAgY29uc3QgVDIzID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gIGNvbnN0IHNib3gyID0gbmV3IFVpbnQxNkFycmF5KDI1NiAqIDI1Nik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgICBjb25zdCBpZHggPSBpICogMjU2ICsgajtcbiAgICAgIFQwMVtpZHhdID0gVDBbaV0gXiBUMVtqXTtcbiAgICAgIFQyM1tpZHhdID0gVDJbaV0gXiBUM1tqXTtcbiAgICAgIHNib3gyW2lkeF0gPSAoc2JveFtpXSA8PCA4KSB8IHNib3hbal07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHNib3gsIHNib3gyLCBUMCwgVDEsIFQyLCBUMywgVDAxLCBUMjMgfTtcbn1cblxuY29uc3QgdGFibGVFbmNvZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBnZW5UdGFibGUoXG4gIHNib3gsXG4gIChzOiBudW1iZXIpID0+IChtdWwocywgMykgPDwgMjQpIHwgKHMgPDwgMTYpIHwgKHMgPDwgOCkgfCBtdWwocywgMilcbik7XG5jb25zdCB0YWJsZURlY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShcbiAgaW52U2JveCxcbiAgKHMpID0+IChtdWwocywgMTEpIDw8IDI0KSB8IChtdWwocywgMTMpIDw8IDE2KSB8IChtdWwocywgOSkgPDwgOCkgfCBtdWwocywgMTQpXG4pO1xuXG5jb25zdCB4UG93ZXJzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDE2OyBpKyssIHggPSBtdWwyKHgpKSBwW2ldID0geDtcbiAgcmV0dXJuIHA7XG59KSgpO1xuXG4vKiogS2V5IGV4cGFuc2lvbiB1c2VkIGluIENUUi4gKi9cbmZ1bmN0aW9uIGV4cGFuZEtleUxFKGtleTogVWludDhBcnJheSk6IFVpbnQzMkFycmF5IHtcbiAgYWJ5dGVzKGtleSk7XG4gIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gIHZhbGlkYXRlS2V5TGVuZ3RoKGtleSk7XG4gIGNvbnN0IHsgc2JveDIgfSA9IHRhYmxlRW5jb2Rpbmc7XG4gIGNvbnN0IHRvQ2xlYW4gPSBbXTtcbiAgaWYgKCFpc0FsaWduZWQzMihrZXkpKSB0b0NsZWFuLnB1c2goKGtleSA9IGNvcHlCeXRlcyhrZXkpKSk7XG4gIGNvbnN0IGszMiA9IHUzMihrZXkpO1xuICBjb25zdCBOayA9IGszMi5sZW5ndGg7XG4gIGNvbnN0IHN1YkJ5dGUgPSAobjogbnVtYmVyKSA9PiBhcHBseVNib3goc2JveDIsIG4sIG4sIG4sIG4pO1xuICBjb25zdCB4ayA9IG5ldyBVaW50MzJBcnJheShsZW4gKyAyOCk7IC8vIGV4cGFuZGVkIGtleVxuICB4ay5zZXQoazMyKTtcbiAgLy8gNC4zLjEgS2V5IGV4cGFuc2lvblxuICBmb3IgKGxldCBpID0gTms7IGkgPCB4ay5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0ID0geGtbaSAtIDFdO1xuICAgIGlmIChpICUgTmsgPT09IDApIHQgPSBzdWJCeXRlKHJvdHIzMl84KHQpKSBeIHhQb3dlcnNbaSAvIE5rIC0gMV07XG4gICAgZWxzZSBpZiAoTmsgPiA2ICYmIGkgJSBOayA9PT0gNCkgdCA9IHN1YkJ5dGUodCk7XG4gICAgeGtbaV0gPSB4a1tpIC0gTmtdIF4gdDtcbiAgfVxuICBjbGVhbiguLi50b0NsZWFuKTtcbiAgcmV0dXJuIHhrO1xufVxuXG5mdW5jdGlvbiBleHBhbmRLZXlEZWNMRShrZXk6IFVpbnQ4QXJyYXkpOiBVaW50MzJBcnJheSB7XG4gIGNvbnN0IGVuY0tleSA9IGV4cGFuZEtleUxFKGtleSk7XG4gIGNvbnN0IHhrID0gZW5jS2V5LnNsaWNlKCk7XG4gIGNvbnN0IE5rID0gZW5jS2V5Lmxlbmd0aDtcbiAgY29uc3QgeyBzYm94MiB9ID0gdGFibGVFbmNvZGluZztcbiAgY29uc3QgeyBUMCwgVDEsIFQyLCBUMyB9ID0gdGFibGVEZWNvZGluZztcbiAgLy8gSW52ZXJzZSBrZXkgYnkgY2h1bmtzIG9mIDQgKHJvdW5kcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOazsgaSArPSA0KSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHhrW2kgKyBqXSA9IGVuY0tleVtOayAtIGkgLSA0ICsgal07XG4gIH1cbiAgY2xlYW4oZW5jS2V5KTtcbiAgLy8gYXBwbHkgSW52TWl4Q29sdW1uIGV4Y2VwdCBmaXJzdCAmIGxhc3Qgcm91bmRcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPCBOayAtIDQ7IGkrKykge1xuICAgIGNvbnN0IHggPSB4a1tpXTtcbiAgICBjb25zdCB3ID0gYXBwbHlTYm94KHNib3gyLCB4LCB4LCB4LCB4KTtcbiAgICB4a1tpXSA9IFQwW3cgJiAweGZmXSBeIFQxWyh3ID4+PiA4KSAmIDB4ZmZdIF4gVDJbKHcgPj4+IDE2KSAmIDB4ZmZdIF4gVDNbdyA+Pj4gMjRdO1xuICB9XG4gIHJldHVybiB4aztcbn1cblxuLy8gQXBwbHkgdGFibGVzXG5mdW5jdGlvbiBhcHBseTAxMjMoXG4gIFQwMTogVWludDMyQXJyYXksXG4gIFQyMzogVWludDMyQXJyYXksXG4gIHMwOiBudW1iZXIsXG4gIHMxOiBudW1iZXIsXG4gIHMyOiBudW1iZXIsXG4gIHMzOiBudW1iZXJcbikge1xuICByZXR1cm4gKFxuICAgIFQwMVsoKHMwIDw8IDgpICYgMHhmZjAwKSB8ICgoczEgPj4+IDgpICYgMHhmZildIF5cbiAgICBUMjNbKChzMiA+Pj4gOCkgJiAweGZmMDApIHwgKChzMyA+Pj4gMjQpICYgMHhmZildXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U2JveChzYm94MjogVWludDE2QXJyYXksIHMwOiBudW1iZXIsIHMxOiBudW1iZXIsIHMyOiBudW1iZXIsIHMzOiBudW1iZXIpIHtcbiAgcmV0dXJuIChcbiAgICBzYm94MlsoczAgJiAweGZmKSB8IChzMSAmIDB4ZmYwMCldIHxcbiAgICAoc2JveDJbKChzMiA+Pj4gMTYpICYgMHhmZikgfCAoKHMzID4+PiAxNikgJiAweGZmMDApXSA8PCAxNilcbiAgKTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdChcbiAgeGs6IFVpbnQzMkFycmF5LFxuICBzMDogbnVtYmVyLFxuICBzMTogbnVtYmVyLFxuICBzMjogbnVtYmVyLFxuICBzMzogbnVtYmVyXG4pOiB7IHMwOiBudW1iZXI7IHMxOiBudW1iZXI7IHMyOiBudW1iZXI7IHMzOiBudW1iZXIgfSB7XG4gIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZUVuY29kaW5nO1xuICBsZXQgayA9IDA7XG4gICgoczAgXj0geGtbaysrXSksIChzMSBePSB4a1trKytdKSwgKHMyIF49IHhrW2srK10pLCAoczMgXj0geGtbaysrXSkpO1xuICBjb25zdCByb3VuZHMgPSB4ay5sZW5ndGggLyA0IC0gMjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczAsIHMxLCBzMiwgczMpO1xuICAgIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczEsIHMyLCBzMywgczApO1xuICAgIGNvbnN0IHQyID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczIsIHMzLCBzMCwgczEpO1xuICAgIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczMsIHMwLCBzMSwgczIpO1xuICAgICgoczAgPSB0MCksIChzMSA9IHQxKSwgKHMyID0gdDIpLCAoczMgPSB0MykpO1xuICB9XG4gIC8vIGxhc3Qgcm91bmQgKHdpdGhvdXQgbWl4Y29sdW1ucywgc28gdXNpbmcgU0JPWDIgdGFibGUpXG4gIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczAsIHMxLCBzMiwgczMpO1xuICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMiwgczMsIHMwKTtcbiAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMiwgczMsIHMwLCBzMSk7XG4gIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczMsIHMwLCBzMSwgczIpO1xuICByZXR1cm4geyBzMDogdDAsIHMxOiB0MSwgczI6IHQyLCBzMzogdDMgfTtcbn1cblxuLy8gQ2FuJ3QgYmUgbWVyZ2VkIHdpdGggZW5jcnlwdDogYXJnIHBvc2l0aW9ucyBmb3IgYXBwbHkwMTIzIC8gYXBwbHlTYm94IGFyZSBkaWZmZXJlbnRcbmZ1bmN0aW9uIGRlY3J5cHQoXG4gIHhrOiBVaW50MzJBcnJheSxcbiAgczA6IG51bWJlcixcbiAgczE6IG51bWJlcixcbiAgczI6IG51bWJlcixcbiAgczM6IG51bWJlclxuKToge1xuICBzMDogbnVtYmVyO1xuICBzMTogbnVtYmVyO1xuICBzMjogbnVtYmVyO1xuICBzMzogbnVtYmVyO1xufSB7XG4gIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZURlY29kaW5nO1xuICBsZXQgayA9IDA7XG4gICgoczAgXj0geGtbaysrXSksIChzMSBePSB4a1trKytdKSwgKHMyIF49IHhrW2srK10pLCAoczMgXj0geGtbaysrXSkpO1xuICBjb25zdCByb3VuZHMgPSB4ay5sZW5ndGggLyA0IC0gMjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczAsIHMzLCBzMiwgczEpO1xuICAgIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczEsIHMwLCBzMywgczIpO1xuICAgIGNvbnN0IHQyID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczIsIHMxLCBzMCwgczMpO1xuICAgIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczMsIHMyLCBzMSwgczApO1xuICAgICgoczAgPSB0MCksIChzMSA9IHQxKSwgKHMyID0gdDIpLCAoczMgPSB0MykpO1xuICB9XG4gIC8vIExhc3Qgcm91bmRcbiAgY29uc3QgdDA6IG51bWJlciA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMwLCBzMywgczIsIHMxKTtcbiAgY29uc3QgdDE6IG51bWJlciA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMCwgczMsIHMyKTtcbiAgY29uc3QgdDI6IG51bWJlciA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMSwgczAsIHMzKTtcbiAgY29uc3QgdDM6IG51bWJlciA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMzLCBzMiwgczEsIHMwKTtcbiAgcmV0dXJuIHsgczA6IHQwLCBzMTogdDEsIHMyOiB0MiwgczM6IHQzIH07XG59XG5cbi8vIFRPRE86IGludmVzdGlnYXRlIG1lcmdpbmcgd2l0aCBjdHIzMlxuZnVuY3Rpb24gY3RyQ291bnRlcihcbiAgeGs6IFVpbnQzMkFycmF5LFxuICBub25jZTogVWludDhBcnJheSxcbiAgc3JjOiBVaW50OEFycmF5LFxuICBkc3Q/OiBVaW50OEFycmF5XG4pOiBVaW50OEFycmF5IHtcbiAgYWJ5dGVzKG5vbmNlLCBCTE9DS19TSVpFLCAnbm9uY2UnKTtcbiAgYWJ5dGVzKHNyYyk7XG4gIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gIGRzdCA9IGdldE91dHB1dChzcmNMZW4sIGRzdCk7XG4gIGNvbXBsZXhPdmVybGFwQnl0ZXMoc3JjLCBkc3QpO1xuICBjb25zdCBjdHIgPSBub25jZTtcbiAgY29uc3QgYzMyID0gdTMyKGN0cik7XG4gIC8vIEZpbGwgYmxvY2sgKGVtcHR5LCBjdHI9MClcbiAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSk7XG4gIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gIGNvbnN0IGRzdDMyID0gdTMyKGRzdCk7XG4gIC8vIHByb2Nlc3MgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBzcmMzMi5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRzdDMyW2kgKyAwXSA9IHNyYzMyW2kgKyAwXSBeIHMwO1xuICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIHMxO1xuICAgIGRzdDMyW2kgKyAyXSA9IHNyYzMyW2kgKyAyXSBeIHMyO1xuICAgIGRzdDMyW2kgKyAzXSA9IHNyYzMyW2kgKyAzXSBeIHMzO1xuICAgIGluY0J5dGVzKGN0ciwgZmFsc2UsIDEpOyAvLyBGdWxsIDEyOCBiaXQgY291bnRlciB3aXRoIHdyYXAgYXJvdW5kXG4gICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSkpO1xuICB9XG4gIC8vIGxlZnRvdmVycyAobGVzcyB0aGFuIGJsb2NrKVxuICAvLyBJdCdzIHBvc3NpYmxlIHRvIGhhbmRsZSA+IHUzMiBmYXN0LCBidXQgaXMgaXQgd29ydGggaXQ/XG4gIGNvbnN0IHN0YXJ0ID0gQkxPQ0tfU0laRSAqIE1hdGguZmxvb3Ioc3JjMzIubGVuZ3RoIC8gQkxPQ0tfU0laRTMyKTtcbiAgaWYgKHN0YXJ0IDwgc3JjTGVuKSB7XG4gICAgY29uc3QgYjMyID0gbmV3IFVpbnQzMkFycmF5KFtzMCwgczEsIHMyLCBzM10pO1xuICAgIGNvbnN0IGJ1ZiA9IHU4KGIzMik7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwb3MgPSAwOyBpIDwgc3JjTGVuOyBpKyssIHBvcysrKSBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICBjbGVhbihiMzIpO1xuICB9XG4gIHJldHVybiBkc3Q7XG59XG5cbi8vIEFFUyBDVFIgd2l0aCBvdmVyZmxvd2luZyAzMiBiaXQgY291bnRlclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuLy8gQnV0LCB3ZSBuZWVkIGJvdGgsIGFuZCBwZXJmIGJvdHRsZW5lY2sgaXMgaW4gZ2hhc2ggYW55d2F5LlxuZnVuY3Rpb24gY3RyMzIoXG4gIHhrOiBVaW50MzJBcnJheSxcbiAgaXNMRTogYm9vbGVhbixcbiAgbm9uY2U6IFVpbnQ4QXJyYXksXG4gIHNyYzogVWludDhBcnJheSxcbiAgZHN0PzogVWludDhBcnJheVxuKTogVWludDhBcnJheSB7XG4gIGFieXRlcyhub25jZSwgQkxPQ0tfU0laRSwgJ25vbmNlJyk7XG4gIGFieXRlcyhzcmMpO1xuICBkc3QgPSBnZXRPdXRwdXQoc3JjLmxlbmd0aCwgZHN0KTtcbiAgY29uc3QgY3RyID0gbm9uY2U7IC8vIHdyaXRlIG5ldyB2YWx1ZSB0byBub25jZSwgc28gaXQgY2FuIGJlIHJlLXVzZWRcbiAgY29uc3QgYzMyID0gdTMyKGN0cik7XG4gIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGN0cik7XG4gIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gIGNvbnN0IGRzdDMyID0gdTMyKGRzdCk7XG4gIGNvbnN0IGN0clBvcyA9IGlzTEUgPyAwIDogMTI7XG4gIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gIC8vIEZpbGwgYmxvY2sgKGVtcHR5LCBjdHI9MClcbiAgbGV0IGN0ck51bSA9IHZpZXcuZ2V0VWludDMyKGN0clBvcywgaXNMRSk7IC8vIHJlYWQgY3VycmVudCBjb3VudGVyIHZhbHVlXG4gIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICAvLyBwcm9jZXNzIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBzMDtcbiAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcbiAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBzMztcbiAgICBjdHJOdW0gPSAoY3RyTnVtICsgMSkgPj4+IDA7IC8vIHUzMiB3cmFwXG4gICAgdmlldy5zZXRVaW50MzIoY3RyUG9zLCBjdHJOdW0sIGlzTEUpO1xuICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pKTtcbiAgfVxuICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBhIGJsb2NrKVxuICBjb25zdCBzdGFydCA9IEJMT0NLX1NJWkUgKiBNYXRoLmZsb29yKHNyYzMyLmxlbmd0aCAvIEJMT0NLX1NJWkUzMik7XG4gIGlmIChzdGFydCA8IHNyY0xlbikge1xuICAgIGNvbnN0IGIzMiA9IG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKTtcbiAgICBjb25zdCBidWYgPSB1OChiMzIpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgcG9zID0gMDsgaSA8IHNyY0xlbjsgaSsrLCBwb3MrKykgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG4gICAgY2xlYW4oYjMyKTtcbiAgfVxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqICoqQ1RSKiogKENvdW50ZXIgTW9kZSk6IFR1cm5zIGEgYmxvY2sgY2lwaGVyIGludG8gYSBzdHJlYW0gY2lwaGVyIHVzaW5nIGEgY291bnRlciBhbmQgSVYgKG5vbmNlKS5cbiAqIEVmZmljaWVudCBhbmQgcGFyYWxsZWxpemFibGUuIFJlcXVpcmVzIGEgdW5pcXVlIG5vbmNlIHBlciBlbmNyeXB0aW9uLiBVbmF1dGhlbnRpY2F0ZWQ6IG5lZWRzIE1BQy5cbiAqL1xuZXhwb3J0IGNvbnN0IGN0cjogKChrZXk6IFVpbnQ4QXJyYXksIG5vbmNlOiBVaW50OEFycmF5KSA9PiBDaXBoZXJXaXRoT3V0cHV0KSAmIHtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG4gIG5vbmNlTGVuZ3RoOiBudW1iZXI7XG59ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sXG4gIGZ1bmN0aW9uIGFlc2N0cihrZXk6IFVpbnQ4QXJyYXksIG5vbmNlOiBVaW50OEFycmF5KTogQ2lwaGVyV2l0aE91dHB1dCB7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0N0cihidWY6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpIHtcbiAgICAgIGFieXRlcyhidWYpO1xuICAgICAgaWYgKGRzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFieXRlcyhkc3QpO1xuICAgICAgICBpZiAoIWlzQWxpZ25lZDMyKGRzdCkpIHRocm93IG5ldyBFcnJvcigndW5hbGlnbmVkIGRlc3RpbmF0aW9uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICBjb25zdCBuID0gY29weUJ5dGVzKG5vbmNlKTsgLy8gYWxpZ24gKyBhdm9pZCBjaGFuZ2luZ1xuICAgICAgY29uc3QgdG9DbGVhbiA9IFt4aywgbl07XG4gICAgICBpZiAoIWlzQWxpZ25lZDMyKGJ1ZikpIHRvQ2xlYW4ucHVzaCgoYnVmID0gY29weUJ5dGVzKGJ1ZikpKTtcbiAgICAgIGNvbnN0IG91dCA9IGN0ckNvdW50ZXIoeGssIG4sIGJ1ZiwgZHN0KTtcbiAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpID0+IHByb2Nlc3NDdHIocGxhaW50ZXh0LCBkc3QpLFxuICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpID0+IHByb2Nlc3NDdHIoY2lwaGVydGV4dCwgZHN0KSxcbiAgICB9O1xuICB9XG4pO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRGVjcnlwdChkYXRhOiBVaW50OEFycmF5KSB7XG4gIGFieXRlcyhkYXRhKTtcbiAgaWYgKGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdhZXMtKGNiYy9lY2IpLmRlY3J5cHQgY2lwaGVydGV4dCBzaG91bGQgY29uc2lzdCBvZiBibG9ja3Mgd2l0aCBzaXplICcgKyBCTE9DS19TSVpFXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIHBja3M1OiBib29sZWFuLCBkc3Q/OiBVaW50OEFycmF5KSB7XG4gIGFieXRlcyhwbGFpbnRleHQpO1xuICBsZXQgb3V0TGVuID0gcGxhaW50ZXh0Lmxlbmd0aDtcbiAgY29uc3QgcmVtYWluaW5nID0gb3V0TGVuICUgQkxPQ0tfU0laRTtcbiAgaWYgKCFwY2tzNSAmJiByZW1haW5pbmcgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZWMvKGNiYy1lY2IpOiB1bnBhZGRlZCBwbGFpbnRleHQgd2l0aCBkaXNhYmxlZCBwYWRkaW5nJyk7XG4gIGlmICghaXNBbGlnbmVkMzIocGxhaW50ZXh0KSkgcGxhaW50ZXh0ID0gY29weUJ5dGVzKHBsYWludGV4dCk7XG4gIGNvbnN0IGIgPSB1MzIocGxhaW50ZXh0KTtcbiAgaWYgKHBja3M1KSB7XG4gICAgbGV0IGxlZnQgPSBCTE9DS19TSVpFIC0gcmVtYWluaW5nO1xuICAgIGlmICghbGVmdCkgbGVmdCA9IEJMT0NLX1NJWkU7IC8vIGlmIG5vIGJ5dGVzIGxlZnQsIGNyZWF0ZSBlbXB0eSBwYWRkaW5nIGJsb2NrXG4gICAgb3V0TGVuID0gb3V0TGVuICsgbGVmdDtcbiAgfVxuICBkc3QgPSBnZXRPdXRwdXQob3V0TGVuLCBkc3QpO1xuICBjb21wbGV4T3ZlcmxhcEJ5dGVzKHBsYWludGV4dCwgZHN0KTtcbiAgY29uc3QgbyA9IHUzMihkc3QpO1xuICByZXR1cm4geyBiLCBvLCBvdXQ6IGRzdCB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBDS1MoZGF0YTogVWludDhBcnJheSwgcGNrczU6IGJvb2xlYW4pIHtcbiAgaWYgKCFwY2tzNSkgcmV0dXJuIGRhdGE7XG4gIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICBpZiAoIWxlbikgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IGVtcHR5IGNpcGhlcnRleHQgbm90IGFsbG93ZWQnKTtcbiAgY29uc3QgbGFzdEJ5dGUgPSBkYXRhW2xlbiAtIDFdO1xuICBpZiAobGFzdEJ5dGUgPD0gMCB8fCBsYXN0Qnl0ZSA+IDE2KSB0aHJvdyBuZXcgRXJyb3IoJ2Flcy9wY2tzNTogd3JvbmcgcGFkZGluZycpO1xuICBjb25zdCBvdXQgPSBkYXRhLnN1YmFycmF5KDAsIC1sYXN0Qnl0ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEJ5dGU7IGkrKylcbiAgICBpZiAoZGF0YVtsZW4gLSBpIC0gMV0gIT09IGxhc3RCeXRlKSB0aHJvdyBuZXcgRXJyb3IoJ2Flcy9wY2tzNTogd3JvbmcgcGFkZGluZycpO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwYWRQQ0tTKGxlZnQ6IFVpbnQ4QXJyYXkpIHtcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjb25zdCB0bXAzMiA9IHUzMih0bXApO1xuICB0bXAuc2V0KGxlZnQpO1xuICBjb25zdCBwYWRkaW5nQnl0ZSA9IEJMT0NLX1NJWkUgLSBsZWZ0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IEJMT0NLX1NJWkUgLSBwYWRkaW5nQnl0ZTsgaSA8IEJMT0NLX1NJWkU7IGkrKykgdG1wW2ldID0gcGFkZGluZ0J5dGU7XG4gIHJldHVybiB0bXAzMjtcbn1cblxuLyoqIE9wdGlvbnMgZm9yIEVDQiBhbmQgQ0JDLiAqL1xuZXhwb3J0IHR5cGUgQmxvY2tPcHRzID0geyBkaXNhYmxlUGFkZGluZz86IGJvb2xlYW4gfTtcblxuLyoqXG4gKiAqKkVDQioqIChFbGVjdHJvbmljIENvZGVib29rKTogRGV0ZXJtaW5pc3RpYyBlbmNyeXB0aW9uOyBpZGVudGljYWwgcGxhaW50ZXh0IGJsb2NrcyB5aWVsZFxuICogaWRlbnRpY2FsIGNpcGhlcnRleHRzLiBOb3Qgc2VjdXJlIGR1ZSB0byBwYXR0ZXJuIGxlYWthZ2UuXG4gKiBTZWUgW0FFUyBQZW5ndWluXShodHRwczovL3dvcmRzLmZpbGlwcG8uaW8vdGhlLWVjYi1wZW5ndWluLykuXG4gKi9cbmV4cG9ydCBjb25zdCBlY2I6ICgoa2V5OiBVaW50OEFycmF5LCBvcHRzPzogQmxvY2tPcHRzKSA9PiBDaXBoZXJXaXRoT3V0cHV0KSAmIHtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiAxNiB9LFxuICBmdW5jdGlvbiBhZXNlY2Ioa2V5OiBVaW50OEFycmF5LCBvcHRzOiBCbG9ja09wdHMgPSB7fSk6IENpcGhlcldpdGhPdXRwdXQge1xuICAgIGNvbnN0IHBja3M1ID0gIW9wdHMuZGlzYWJsZVBhZGRpbmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQocGxhaW50ZXh0OiBVaW50OEFycmF5LCBkc3Q/OiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IHsgYiwgbywgb3V0OiBfb3V0IH0gPSB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpO1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgKyA0IDw9IGIubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG4gICAgICAgICAgKChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwY2tzNSkge1xuICAgICAgICAgIGNvbnN0IHRtcDMyID0gcGFkUENLUyhwbGFpbnRleHQuc3ViYXJyYXkoaSAqIDQpKTtcbiAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCB0bXAzMlswXSwgdG1wMzJbMV0sIHRtcDMyWzJdLCB0bXAzMlszXSk7XG4gICAgICAgICAgKChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMykpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuKHhrKTtcbiAgICAgICAgcmV0dXJuIF9vdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0OiBVaW50OEFycmF5LCBkc3Q/OiBVaW50OEFycmF5KSB7XG4gICAgICAgIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGNpcGhlcnRleHQpO1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG4gICAgICAgIGRzdCA9IGdldE91dHB1dChjaXBoZXJ0ZXh0Lmxlbmd0aCwgZHN0KTtcbiAgICAgICAgY29uc3QgdG9DbGVhbjogKFVpbnQ4QXJyYXkgfCBVaW50MzJBcnJheSlbXSA9IFt4a107XG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIoY2lwaGVydGV4dCkpIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9IGNvcHlCeXRlcyhjaXBoZXJ0ZXh0KSkpO1xuICAgICAgICBjb21wbGV4T3ZlcmxhcEJ5dGVzKGNpcGhlcnRleHQsIGRzdCk7XG4gICAgICAgIGNvbnN0IGIgPSB1MzIoY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IG8gPSB1MzIoZHN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IGIubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBkZWNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG4gICAgICAgICAgKChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMykpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVQQ0tTKGRzdCwgcGNrczUpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG4pO1xuXG4vKipcbiAqICoqQ0JDKiogKENpcGhlciBCbG9jayBDaGFpbmluZyk6IEVhY2ggcGxhaW50ZXh0IGJsb2NrIGlzIFhPUmVkIHdpdGggdGhlXG4gKiBwcmV2aW91cyBibG9jayBvZiBjaXBoZXJ0ZXh0IGJlZm9yZSBlbmNyeXB0aW9uLlxuICogSGFyZCB0byB1c2U6IHJlcXVpcmVzIHByb3BlciBwYWRkaW5nIGFuZCBhbiBJVi4gVW5hdXRoZW50aWNhdGVkOiBuZWVkcyBNQUMuXG4gKi9cbmV4cG9ydCBjb25zdCBjYmM6ICgoa2V5OiBVaW50OEFycmF5LCBpdjogVWludDhBcnJheSwgb3B0cz86IEJsb2NrT3B0cykgPT4gQ2lwaGVyV2l0aE91dHB1dCkgJiB7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xuICBub25jZUxlbmd0aDogbnVtYmVyO1xufSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxNiB9LFxuICBmdW5jdGlvbiBhZXNjYmMoa2V5OiBVaW50OEFycmF5LCBpdjogVWludDhBcnJheSwgb3B0czogQmxvY2tPcHRzID0ge30pOiBDaXBoZXJXaXRoT3V0cHV0IHtcbiAgICBjb25zdCBwY2tzNSA9ICFvcHRzLmRpc2FibGVQYWRkaW5nO1xuICAgIHJldHVybiB7XG4gICAgICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IHsgYiwgbywgb3V0OiBfb3V0IH0gPSB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpO1xuICAgICAgICBsZXQgX2l2ID0gaXY7XG4gICAgICAgIGNvbnN0IHRvQ2xlYW46IChVaW50OEFycmF5IHwgVWludDMyQXJyYXkpW10gPSBbeGtdO1xuICAgICAgICBpZiAoIWlzQWxpZ25lZDMyKF9pdikpIHRvQ2xlYW4ucHVzaCgoX2l2ID0gY29weUJ5dGVzKF9pdikpKTtcbiAgICAgICAgY29uc3QgbjMyID0gdTMyKF9pdik7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgKyA0IDw9IGIubGVuZ3RoOyApIHtcbiAgICAgICAgICAoKHMwIF49IGJbaSArIDBdKSwgKHMxIF49IGJbaSArIDFdKSwgKHMyIF49IGJbaSArIDJdKSwgKHMzIF49IGJbaSArIDNdKSk7XG4gICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICAgKChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwY2tzNSkge1xuICAgICAgICAgIGNvbnN0IHRtcDMyID0gcGFkUENLUyhwbGFpbnRleHQuc3ViYXJyYXkoaSAqIDQpKTtcbiAgICAgICAgICAoKHMwIF49IHRtcDMyWzBdKSwgKHMxIF49IHRtcDMyWzFdKSwgKHMyIF49IHRtcDMyWzJdKSwgKHMzIF49IHRtcDMyWzNdKSk7XG4gICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICAgKChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMykpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gX291dDtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdmFsaWRhdGVCbG9ja0RlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5RGVjTEUoa2V5KTtcbiAgICAgICAgbGV0IF9pdiA9IGl2O1xuICAgICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW3hrXTtcbiAgICAgICAgaWYgKCFpc0FsaWduZWQzMihfaXYpKSB0b0NsZWFuLnB1c2goKF9pdiA9IGNvcHlCeXRlcyhfaXYpKSk7XG4gICAgICAgIGNvbnN0IG4zMiA9IHUzMihfaXYpO1xuICAgICAgICBkc3QgPSBnZXRPdXRwdXQoY2lwaGVydGV4dC5sZW5ndGgsIGRzdCk7XG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIoY2lwaGVydGV4dCkpIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9IGNvcHlCeXRlcyhjaXBoZXJ0ZXh0KSkpO1xuICAgICAgICBjb21wbGV4T3ZlcmxhcEJ5dGVzKGNpcGhlcnRleHQsIGRzdCk7XG4gICAgICAgIGNvbnN0IGIgPSB1MzIoY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IG8gPSB1MzIoZHN0KTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IG4zMlswXSwgczEgPSBuMzJbMV0sIHMyID0gbjMyWzJdLCBzMyA9IG4zMlszXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IGIubGVuZ3RoOyApIHtcbiAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICBjb25zdCBwczAgPSBzMCwgcHMxID0gczEsIHBzMiA9IHMyLCBwczMgPSBzMztcbiAgICAgICAgICAoKHMwID0gYltpICsgMF0pLCAoczEgPSBiW2kgKyAxXSksIChzMiA9IGJbaSArIDJdKSwgKHMzID0gYltpICsgM10pKTtcbiAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xLCBzMjogbzIsIHMzOiBvMyB9ID0gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICgob1tpKytdID0gbzAgXiBwczApLCAob1tpKytdID0gbzEgXiBwczEpLCAob1tpKytdID0gbzIgXiBwczIpLCAob1tpKytdID0gbzMgXiBwczMpKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhbiguLi50b0NsZWFuKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhkc3QsIHBja3M1KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuKTtcblxuLyoqXG4gKiBDRkI6IENpcGhlciBGZWVkYmFjayBNb2RlLiBUaGUgaW5wdXQgZm9yIHRoZSBibG9jayBjaXBoZXIgaXMgdGhlIHByZXZpb3VzIGNpcGhlciBvdXRwdXQuXG4gKiBVbmF1dGhlbnRpY2F0ZWQ6IG5lZWRzIE1BQy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNmYjogKChrZXk6IFVpbnQ4QXJyYXksIGl2OiBVaW50OEFycmF5KSA9PiBDaXBoZXJXaXRoT3V0cHV0KSAmIHtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG4gIG5vbmNlTGVuZ3RoOiBudW1iZXI7XG59ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sXG4gIGZ1bmN0aW9uIGFlc2NmYihrZXk6IFVpbnQ4QXJyYXksIGl2OiBVaW50OEFycmF5KTogQ2lwaGVyV2l0aE91dHB1dCB7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NmYihzcmM6IFVpbnQ4QXJyYXksIGlzRW5jcnlwdDogYm9vbGVhbiwgZHN0PzogVWludDhBcnJheSkge1xuICAgICAgYWJ5dGVzKHNyYyk7XG4gICAgICBjb25zdCBzcmNMZW4gPSBzcmMubGVuZ3RoO1xuICAgICAgZHN0ID0gZ2V0T3V0cHV0KHNyY0xlbiwgZHN0KTtcbiAgICAgIGlmIChvdmVybGFwQnl0ZXMoc3JjLCBkc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ292ZXJsYXBwaW5nIHNyYyBhbmQgZHN0IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICBsZXQgX2l2ID0gaXY7XG4gICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW3hrXTtcbiAgICAgIGlmICghaXNBbGlnbmVkMzIoX2l2KSkgdG9DbGVhbi5wdXNoKChfaXYgPSBjb3B5Qnl0ZXMoX2l2KSkpO1xuICAgICAgaWYgKCFpc0FsaWduZWQzMihzcmMpKSB0b0NsZWFuLnB1c2goKHNyYyA9IGNvcHlCeXRlcyhzcmMpKSk7XG4gICAgICBjb25zdCBzcmMzMiA9IHUzMihzcmMpO1xuICAgICAgY29uc3QgZHN0MzIgPSB1MzIoZHN0KTtcbiAgICAgIGNvbnN0IG5leHQzMiA9IGlzRW5jcnlwdCA/IGRzdDMyIDogc3JjMzI7XG4gICAgICBjb25zdCBuMzIgPSB1MzIoX2l2KTtcbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IHMwID0gbjMyWzBdLCBzMSA9IG4zMlsxXSwgczIgPSBuMzJbMl0sIHMzID0gbjMyWzNdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IHsgczA6IGUwLCBzMTogZTEsIHMyOiBlMiwgczM6IGUzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgIGRzdDMyW2kgKyAwXSA9IHNyYzMyW2kgKyAwXSBeIGUwO1xuICAgICAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBlMTtcbiAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gZTI7XG4gICAgICAgIGRzdDMyW2kgKyAzXSA9IHNyYzMyW2kgKyAzXSBeIGUzO1xuICAgICAgICAoKHMwID0gbmV4dDMyW2krK10pLCAoczEgPSBuZXh0MzJbaSsrXSksIChzMiA9IG5leHQzMltpKytdKSwgKHMzID0gbmV4dDMyW2krK10pKTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZnRvdmVycyAobGVzcyB0aGFuIGJsb2NrKVxuICAgICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3JjTGVuKSB7XG4gICAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykpO1xuICAgICAgICBjb25zdCBidWYgPSB1OChuZXcgVWludDMyQXJyYXkoW3MwLCBzMSwgczIsIHMzXSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspIGRzdFtpXSA9IHNyY1tpXSBeIGJ1Zltwb3NdO1xuICAgICAgICBjbGVhbihidWYpO1xuICAgICAgfVxuICAgICAgY2xlYW4oLi4udG9DbGVhbik7XG4gICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdDogKHBsYWludGV4dDogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkgPT4gcHJvY2Vzc0NmYihwbGFpbnRleHQsIHRydWUsIGRzdCksXG4gICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dDogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkgPT4gcHJvY2Vzc0NmYihjaXBoZXJ0ZXh0LCBmYWxzZSwgZHN0KSxcbiAgICB9O1xuICB9XG4pO1xuXG4vLyBUT0RPOiBtZXJnZSB3aXRoIGNoYWNoYSwgaG93ZXZlciBnY20gaGFzIGJpdExlbiB3aGlsZSBjaGFjaGEgaGFzIGJ5dGVMZW5cbmZ1bmN0aW9uIGNvbXB1dGVUYWcoXG4gIGZuOiB0eXBlb2YgZ2hhc2gsXG4gIGlzTEU6IGJvb2xlYW4sXG4gIGtleTogVWludDhBcnJheSxcbiAgZGF0YTogVWludDhBcnJheSxcbiAgQUFEPzogVWludDhBcnJheVxuKSB7XG4gIGNvbnN0IGFhZExlbmd0aCA9IEFBRCA/IEFBRC5sZW5ndGggOiAwO1xuICBjb25zdCBoID0gZm4uY3JlYXRlKGtleSwgZGF0YS5sZW5ndGggKyBhYWRMZW5ndGgpO1xuICBpZiAoQUFEKSBoLnVwZGF0ZShBQUQpO1xuICBjb25zdCBudW0gPSB1NjRMZW5ndGhzKDggKiBkYXRhLmxlbmd0aCwgOCAqIGFhZExlbmd0aCwgaXNMRSk7XG4gIGgudXBkYXRlKGRhdGEpO1xuICBoLnVwZGF0ZShudW0pO1xuICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICBjbGVhbihudW0pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqICoqR0NNKiogKEdhbG9pcy9Db3VudGVyIE1vZGUpOiBDb21iaW5lcyBDVFIgbW9kZSB3aXRoIHBvbHlub21pYWwgTUFDLiBFZmZpY2llbnQgYW5kIHdpZGVseSB1c2VkLlxuICogTm90IHBlcmZlY3Q6XG4gKiBhKSBjb25zZXJ2YXRpdmUga2V5IHdlYXItb3V0IGlzIGAyKiozMmAgKDRCKSBtc2dzLlxuICogYikga2V5IHdlYXItb3V0IHVuZGVyIHJhbmRvbSBub25jZXMgaXMgZXZlbiBzbWFsbGVyOiBgMioqMjNgICg4TSkgbWVzc2FnZXMgZm9yIGAyKiotNTBgIGNoYW5jZS5cbiAqIGMpIE1BQyBjYW4gYmUgZm9yZ2VkOiBzZWUgUG9seTEzMDUgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdjbTogKChrZXk6IFVpbnQ4QXJyYXksIG5vbmNlOiBVaW50OEFycmF5LCBBQUQ/OiBVaW50OEFycmF5KSA9PiBDaXBoZXIpICYge1xuICBibG9ja1NpemU6IG51bWJlcjtcbiAgbm9uY2VMZW5ndGg6IG51bWJlcjtcbiAgdGFnTGVuZ3RoOiBudW1iZXI7XG4gIHZhclNpemVOb25jZTogdHJ1ZTtcbn0gPSAvKiBAX19QVVJFX18gKi8gd3JhcENpcGhlcihcbiAgeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYsIHZhclNpemVOb25jZTogdHJ1ZSB9LFxuICBmdW5jdGlvbiBhZXNnY20oa2V5OiBVaW50OEFycmF5LCBub25jZTogVWludDhBcnJheSwgQUFEPzogVWludDhBcnJheSk6IENpcGhlciB7XG4gICAgLy8gTklTVCA4MDAtMzhkIGRvZXNuJ3QgZW5mb3JjZSBtaW5pbXVtIG5vbmNlIGxlbmd0aC5cbiAgICAvLyBXZSBlbmZvcmNlIDggYnl0ZXMgZm9yIGNvbXBhdCB3aXRoIG9wZW5zc2wuXG4gICAgLy8gMTIgYnl0ZXMgYXJlIHJlY29tbWVuZGVkLiBNb3JlIHRoYW4gMTIgYnl0ZXMgd291bGQgYmUgY29udmVydGVkIGludG8gMTIuXG4gICAgaWYgKG5vbmNlLmxlbmd0aCA8IDgpIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBub25jZSBsZW5ndGgnKTtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhhdXRoS2V5OiBVaW50OEFycmF5LCB0YWdNYXNrOiBVaW50OEFycmF5LCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKGdoYXNoLCBmYWxzZSwgYXV0aEtleSwgZGF0YSwgQUFEKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnTWFzay5sZW5ndGg7IGkrKykgdGFnW2ldIF49IHRhZ01hc2tbaV07XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXJpdmVLZXlzKCkge1xuICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgY29uc3QgYXV0aEtleSA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG4gICAgICBjb25zdCBjb3VudGVyID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcbiAgICAgIGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgY291bnRlciwgYXV0aEtleSk7XG4gICAgICAvLyBOSVNUIDgwMC0zOGQsIHBhZ2UgMTU6IGRpZmZlcmVudCBiZWhhdmlvciBmb3IgOTYtYml0IGFuZCBub24tOTYtYml0IG5vbmNlc1xuICAgICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgY291bnRlci5zZXQobm9uY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9uY2VMZW4gPSBFTVBUWV9CTE9DSy5zbGljZSgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhub25jZUxlbik7XG4gICAgICAgIHZpZXcuc2V0QmlnVWludDY0KDgsIEJpZ0ludChub25jZS5sZW5ndGggKiA4KSwgZmFsc2UpO1xuICAgICAgICAvLyBnaGFzaChub25jZSB8fCB1NjRiZSgwKSB8fCB1NjRiZShub25jZUxlbio4KSlcbiAgICAgICAgY29uc3QgZyA9IGdoYXNoLmNyZWF0ZShhdXRoS2V5KS51cGRhdGUobm9uY2UpLnVwZGF0ZShub25jZUxlbik7XG4gICAgICAgIGcuZGlnZXN0SW50byhjb3VudGVyKTsgLy8gZGlnZXN0SW50byBkb2Vzbid0IHRyaWdnZXIgJy5kZXN0cm95J1xuICAgICAgICBnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhZ01hc2sgPSBjdHIzMih4aywgZmFsc2UsIGNvdW50ZXIsIEVNUFRZX0JMT0NLKTtcbiAgICAgIHJldHVybiB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGggKyB0YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW3hrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrXTtcbiAgICAgICAgaWYgKCFpc0FsaWduZWQzMihwbGFpbnRleHQpKSB0b0NsZWFuLnB1c2goKHBsYWludGV4dCA9IGNvcHlCeXRlcyhwbGFpbnRleHQpKSk7XG4gICAgICAgIGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgcGxhaW50ZXh0LCBvdXQuc3ViYXJyYXkoMCwgcGxhaW50ZXh0Lmxlbmd0aCkpO1xuICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBvdXQuc3ViYXJyYXkoMCwgb3V0Lmxlbmd0aCAtIHRhZ0xlbmd0aCkpO1xuICAgICAgICB0b0NsZWFuLnB1c2godGFnKTtcbiAgICAgICAgb3V0LnNldCh0YWcsIHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICBjbGVhbiguLi50b0NsZWFuKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW3hrLCBhdXRoS2V5LCB0YWdNYXNrLCBjb3VudGVyXTtcbiAgICAgICAgaWYgKCFpc0FsaWduZWQzMihjaXBoZXJ0ZXh0KSkgdG9DbGVhbi5wdXNoKChjaXBoZXJ0ZXh0ID0gY29weUJ5dGVzKGNpcGhlcnRleHQpKSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBkYXRhKTtcbiAgICAgICAgdG9DbGVhbi5wdXNoKHRhZyk7XG4gICAgICAgIGlmICghZXF1YWxCeXRlcyh0YWcsIHBhc3NlZFRhZykpIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBnaGFzaCB0YWcnKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBkYXRhKTtcbiAgICAgICAgY2xlYW4oLi4udG9DbGVhbik7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9LFxuICAgIH07XG4gIH1cbik7XG5cbmNvbnN0IGxpbWl0ID0gKG5hbWU6IHN0cmluZywgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiAodmFsdWU6IG51bWJlcikgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSB8fCBtaW4gPiB2YWx1ZSB8fCB2YWx1ZSA+IG1heCkge1xuICAgIGNvbnN0IG1pbm1heCA9ICdbJyArIG1pbiArICcuLicgKyBtYXggKyAnXSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcnICsgbmFtZSArICc6IGV4cGVjdGVkIHZhbHVlIGluIHJhbmdlICcgKyBtaW5tYXggKyAnLCBnb3QgJyArIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiAqKlNJVioqIChTeW50aGV0aWMgSVYpOiBHQ00gd2l0aCBub25jZS1taXN1c2UgcmVzaXN0YW5jZS5cbiAqIFJlcGVhdGluZyBub25jZXMgcmV2ZWFsIG9ubHkgdGhlIGZhY3QgcGxhaW50ZXh0cyBhcmUgaWRlbnRpY2FsLlxuICogQWxzbyBzdWZmZXJzIGZyb20gR0NNIGlzc3Vlczoga2V5IHdlYXItb3V0IGxpbWl0cyAmIE1BQyBmb3JnaW5nLlxuICogU2VlIFtSRkMgODQ1Ml0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzg0NTIpLlxuICovXG5leHBvcnQgY29uc3QgZ2Ntc2l2OiAoKGtleTogVWludDhBcnJheSwgbm9uY2U6IFVpbnQ4QXJyYXksIEFBRD86IFVpbnQ4QXJyYXkpID0+IENpcGhlcikgJiB7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xuICBub25jZUxlbmd0aDogbnVtYmVyO1xuICB0YWdMZW5ndGg6IG51bWJlcjtcbiAgdmFyU2l6ZU5vbmNlOiB0cnVlO1xufSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiwgdmFyU2l6ZU5vbmNlOiB0cnVlIH0sXG4gIGZ1bmN0aW9uIGFlc3NpdihrZXk6IFVpbnQ4QXJyYXksIG5vbmNlOiBVaW50OEFycmF5LCBBQUQ/OiBVaW50OEFycmF5KTogQ2lwaGVyIHtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICAvLyBGcm9tIFJGQyA4NDUyOiBTZWN0aW9uIDZcbiAgICBjb25zdCBBQURfTElNSVQgPSBsaW1pdCgnQUFEJywgMCwgMiAqKiAzNik7XG4gICAgY29uc3QgUExBSU5fTElNSVQgPSBsaW1pdCgncGxhaW50ZXh0JywgMCwgMiAqKiAzNik7XG4gICAgY29uc3QgTk9OQ0VfTElNSVQgPSBsaW1pdCgnbm9uY2UnLCAxMiwgMTIpO1xuICAgIGNvbnN0IENJUEhFUl9MSU1JVCA9IGxpbWl0KCdjaXBoZXJ0ZXh0JywgMTYsIDIgKiogMzYgKyAxNik7XG4gICAgYWJ5dGVzKGtleSk7XG4gICAgdmFsaWRhdGVLZXlMZW5ndGgoa2V5KTtcbiAgICBOT05DRV9MSU1JVChub25jZS5sZW5ndGgpO1xuICAgIGlmIChBQUQgIT09IHVuZGVmaW5lZCkgQUFEX0xJTUlUKEFBRC5sZW5ndGgpO1xuICAgIGZ1bmN0aW9uIGRlcml2ZUtleXMoKSB7XG4gICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICBjb25zdCBlbmNLZXkgPSBuZXcgVWludDhBcnJheShrZXkubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGF1dGhLZXkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW3hrLCBlbmNLZXldO1xuICAgICAgbGV0IF9ub25jZSA9IG5vbmNlO1xuICAgICAgaWYgKCFpc0FsaWduZWQzMihfbm9uY2UpKSB0b0NsZWFuLnB1c2goKF9ub25jZSA9IGNvcHlCeXRlcyhfbm9uY2UpKSk7XG4gICAgICBjb25zdCBuMzIgPSB1MzIoX25vbmNlKTtcbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IHMwID0gMCwgczEgPSBuMzJbMF0sIHMyID0gbjMyWzFdLCBzMyA9IG4zMlsyXTtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGZvciAoY29uc3QgZGVyaXZlZEtleSBvZiBbYXV0aEtleSwgZW5jS2V5XS5tYXAodTMyKSkge1xuICAgICAgICBjb25zdCBkMzIgPSB1MzIoZGVyaXZlZEtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZDMyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgLy8gYWVzKHUzMmxlKDApIHx8IG5vbmNlKVs6OF0gfHwgYWVzKHUzMmxlKDEpIHx8IG5vbmNlKVs6OF0gLi4uXG4gICAgICAgICAgY29uc3QgeyBzMDogbzAsIHMxOiBvMSB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgIGQzMltpICsgMF0gPSBvMDtcbiAgICAgICAgICBkMzJbaSArIDFdID0gbzE7XG4gICAgICAgICAgczAgPSArK2NvdW50ZXI7IC8vIGluY3JlbWVudCBjb3VudGVyIGluc2lkZSBzdGF0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSB7IGF1dGhLZXksIGVuY0tleTogZXhwYW5kS2V5TEUoZW5jS2V5KSB9O1xuICAgICAgLy8gQ2xlYW51cFxuICAgICAgY2xlYW4oLi4udG9DbGVhbik7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhlbmNLZXk6IFVpbnQzMkFycmF5LCBhdXRoS2V5OiBVaW50OEFycmF5LCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHBvbHl2YWwsIHRydWUsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAvLyBDb21wdXRlIHRoZSBleHBlY3RlZCB0YWcgYnkgWE9SaW5nIFNfcyBhbmQgdGhlIG5vbmNlLCBjbGVhcmluZyB0aGVcbiAgICAgIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IGJ5dGUgYW5kIGVuY3J5cHRpbmcgd2l0aCB0aGVcbiAgICAgIC8vIG1lc3NhZ2UtZW5jcnlwdGlvbiBrZXkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHRhZ1tpXSBePSBub25jZVtpXTtcbiAgICAgIHRhZ1sxNV0gJj0gMHg3ZjsgLy8gQ2xlYXIgdGhlIGhpZ2hlc3QgYml0XG4gICAgICAvLyBlbmNyeXB0IHRhZyBhcyBibG9ja1xuICAgICAgY29uc3QgdDMyID0gdTMyKHRhZyk7XG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGxldCBzMCA9IHQzMlswXSwgczEgPSB0MzJbMV0sIHMyID0gdDMyWzJdLCBzMyA9IHQzMlszXTtcbiAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KGVuY0tleSwgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICgodDMyWzBdID0gczApLCAodDMyWzFdID0gczEpLCAodDMyWzJdID0gczIpLCAodDMyWzNdID0gczMpKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vIGFjdHVhbCBkZWNyeXB0L2VuY3J5cHQgb2YgbWVzc2FnZS5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2l2KGVuY0tleTogVWludDMyQXJyYXksIHRhZzogVWludDhBcnJheSwgaW5wdXQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIGxldCBibG9jayA9IGNvcHlCeXRlcyh0YWcpO1xuICAgICAgYmxvY2tbMTVdIHw9IDB4ODA7IC8vIEZvcmNlIGhpZ2hlc3QgYml0XG4gICAgICBjb25zdCByZXMgPSBjdHIzMihlbmNLZXksIHRydWUsIGJsb2NrLCBpbnB1dCk7XG4gICAgICAvLyBDbGVhbnVwXG4gICAgICBjbGVhbihibG9jayk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgUExBSU5fTElNSVQocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHsgZW5jS2V5LCBhdXRoS2V5IH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IF9jb21wdXRlVGFnKGVuY0tleSwgYXV0aEtleSwgcGxhaW50ZXh0KTtcbiAgICAgICAgY29uc3QgdG9DbGVhbjogKFVpbnQ4QXJyYXkgfCBVaW50MzJBcnJheSlbXSA9IFtlbmNLZXksIGF1dGhLZXksIHRhZ107XG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIocGxhaW50ZXh0KSkgdG9DbGVhbi5wdXNoKChwbGFpbnRleHQgPSBjb3B5Qnl0ZXMocGxhaW50ZXh0KSkpO1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoICsgdGFnTGVuZ3RoKTtcbiAgICAgICAgb3V0LnNldCh0YWcsIHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICBvdXQuc2V0KHByb2Nlc3NTaXYoZW5jS2V5LCB0YWcsIHBsYWludGV4dCkpO1xuICAgICAgICAvLyBDbGVhbnVwXG4gICAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSxcbiAgICAgIGRlY3J5cHQoY2lwaGVydGV4dDogVWludDhBcnJheSkge1xuICAgICAgICBDSVBIRVJfTElNSVQoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCB0YWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICBjb25zdCB0b0NsZWFuOiAoVWludDhBcnJheSB8IFVpbnQzMkFycmF5KVtdID0gW2VuY0tleSwgYXV0aEtleV07XG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIoY2lwaGVydGV4dCkpIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9IGNvcHlCeXRlcyhjaXBoZXJ0ZXh0KSkpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUYWcgPSBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIHBsYWludGV4dCk7XG4gICAgICAgIHRvQ2xlYW4ucHVzaChleHBlY3RlZFRhZyk7XG4gICAgICAgIGlmICghZXF1YWxCeXRlcyh0YWcsIGV4cGVjdGVkVGFnKSkge1xuICAgICAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2x5dmFsIHRhZycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgY2xlYW4oLi4udG9DbGVhbik7XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgICB9LFxuICAgIH07XG4gIH1cbik7XG5cbmZ1bmN0aW9uIGlzQnl0ZXMzMihhOiB1bmtub3duKTogYSBpcyBVaW50MzJBcnJheSB7XG4gIHJldHVybiAoXG4gICAgYSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDMyQXJyYXknKVxuICApO1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0QmxvY2soeGs6IFVpbnQzMkFycmF5LCBibG9jazogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBhYnl0ZXMoYmxvY2ssIDE2LCAnYmxvY2snKTtcbiAgaWYgKCFpc0J5dGVzMzIoeGspKSB0aHJvdyBuZXcgRXJyb3IoJ19lbmNyeXB0QmxvY2sgYWNjZXB0cyByZXN1bHQgb2YgZXhwYW5kS2V5TEUnKTtcbiAgY29uc3QgYjMyID0gdTMyKGJsb2NrKTtcbiAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGIzMlswXSwgYjMyWzFdLCBiMzJbMl0sIGIzMlszXSk7XG4gICgoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpKTtcbiAgcmV0dXJuIGJsb2NrO1xufVxuXG5mdW5jdGlvbiBkZWNyeXB0QmxvY2soeGs6IFVpbnQzMkFycmF5LCBibG9jazogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBhYnl0ZXMoYmxvY2ssIDE2LCAnYmxvY2snKTtcbiAgaWYgKCFpc0J5dGVzMzIoeGspKSB0aHJvdyBuZXcgRXJyb3IoJ19kZWNyeXB0QmxvY2sgYWNjZXB0cyByZXN1bHQgb2YgZXhwYW5kS2V5TEUnKTtcbiAgY29uc3QgYjMyID0gdTMyKGJsb2NrKTtcbiAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGIzMlswXSwgYjMyWzFdLCBiMzJbMl0sIGIzMlszXSk7XG4gICgoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpKTtcbiAgcmV0dXJuIGJsb2NrO1xufVxuXG4vKipcbiAqIEFFUy1XIChiYXNlIGZvciBBRVNLVy9BRVNLV1ApLlxuICogU3BlY3M6IFtTUDgwMC0zOEZdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9TcGVjaWFsUHVibGljYXRpb25zL05JU1QuU1AuODAwLTM4Ri5wZGYpLFxuICogW1JGQyAzMzk0XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzM5NCksXG4gKiBbUkZDIDU2NDldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1NjQ5KS5cbiAqL1xuY29uc3QgQUVTVyA9IHtcbiAgLypcbiAgSGlnaC1sZXZlbCBwc2V1ZG9jb2RlOlxuICBgYGBcbiAgQTogdTY0ID0gSVZcbiAgb3V0ID0gW11cbiAgZm9yIChsZXQgaT0wLCBjdHIgPSAwOyBpPDY7IGkrKykge1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKHBsYWludGV4dCwgOCkpIHtcbiAgICAgIEEgXj0gc3dhcEVuZGlhbmVzcyhjdHIrKylcbiAgICAgIFtBLCByZXNdID0gY2h1bmtzKGVuY3J5cHQoQSB8fCBjaHVuayksIDgpO1xuICAgICAgb3V0IHx8PSByZXNcbiAgICB9XG4gIH1cbiAgb3V0ID0gQSB8fCBvdXRcbiAgYGBgXG4gIERlY3J5cHQgaXMgdGhlIHNhbWUsIGJ1dCByZXZlcnNlZC5cbiAgKi9cbiAgZW5jcnlwdChrZWs6IFVpbnQ4QXJyYXksIG91dDogVWludDhBcnJheSkge1xuICAgIC8vIFNpemUgaXMgbGltaXRlZCB0byA0R0IsIG90aGVyd2lzZSBjdHIgd2lsbCBvdmVyZmxvdyBhbmQgd2UnbGwgbmVlZCB0byBzd2l0Y2ggdG8gYmlnaW50cy5cbiAgICAvLyBJZiB5b3UgbmVlZCBpdCBsYXJnZXIsIG9wZW4gYW4gaXNzdWUuXG4gICAgaWYgKG91dC5sZW5ndGggPj0gMiAqKiAzMikgdGhyb3cgbmV3IEVycm9yKCdwbGFpbnRleHQgc2hvdWxkIGJlIGxlc3MgdGhhbiA0Z2InKTtcbiAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtlayk7XG4gICAgaWYgKG91dC5sZW5ndGggPT09IDE2KSBlbmNyeXB0QmxvY2soeGssIG91dCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IGEwID0gbzMyWzBdLCBhMSA9IG8zMlsxXTsgLy8gQVxuICAgICAgZm9yIChsZXQgaiA9IDAsIGN0ciA9IDE7IGogPCA2OyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMjsgcG9zIDwgbzMyLmxlbmd0aDsgcG9zICs9IDIsIGN0cisrKSB7XG4gICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYTAsIGExLCBvMzJbcG9zXSwgbzMyW3BvcyArIDFdKTtcbiAgICAgICAgICAvLyBBID0gTVNCKDY0LCBCKSBeIHQgd2hlcmUgdCA9IChuKmopK2lcbiAgICAgICAgICAoKGEwID0gczApLCAoYTEgPSBzMSBeIGJ5dGVTd2FwKGN0cikpLCAobzMyW3Bvc10gPSBzMiksIChvMzJbcG9zICsgMV0gPSBzMykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoKG8zMlswXSA9IGEwKSwgKG8zMlsxXSA9IGExKSk7IC8vIG91dCA9IEEgfHwgb3V0XG4gICAgfVxuICAgIHhrLmZpbGwoMCk7XG4gIH0sXG4gIGRlY3J5cHQoa2VrOiBVaW50OEFycmF5LCBvdXQ6IFVpbnQ4QXJyYXkpIHtcbiAgICBpZiAob3V0Lmxlbmd0aCAtIDggPj0gMiAqKiAzMikgdGhyb3cgbmV3IEVycm9yKCdjaXBoZXJ0ZXh0IHNob3VsZCBiZSBsZXNzIHRoYW4gNGdiJyk7XG4gICAgY29uc3QgeGsgPSBleHBhbmRLZXlEZWNMRShrZWspO1xuICAgIGNvbnN0IGNodW5rcyA9IG91dC5sZW5ndGggLyA4IC0gMTsgLy8gZmlyc3QgY2h1bmsgaXMgSVZcbiAgICBpZiAoY2h1bmtzID09PSAxKSBkZWNyeXB0QmxvY2soeGssIG91dCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IGEwID0gbzMyWzBdLCBhMSA9IG8zMlsxXTsgLy8gQVxuICAgICAgZm9yIChsZXQgaiA9IDAsIGN0ciA9IGNodW5rcyAqIDY7IGogPCA2OyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gY2h1bmtzICogMjsgcG9zID49IDE7IHBvcyAtPSAyLCBjdHItLSkge1xuICAgICAgICAgIGExIF49IGJ5dGVTd2FwKGN0cik7XG4gICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYTAsIGExLCBvMzJbcG9zXSwgbzMyW3BvcyArIDFdKTtcbiAgICAgICAgICAoKGEwID0gczApLCAoYTEgPSBzMSksIChvMzJbcG9zXSA9IHMyKSwgKG8zMltwb3MgKyAxXSA9IHMzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICgobzMyWzBdID0gYTApLCAobzMyWzFdID0gYTEpKTtcbiAgICB9XG4gICAgeGsuZmlsbCgwKTtcbiAgfSxcbn07XG5cbmNvbnN0IEFFU0tXX0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KDgpLmZpbGwoMHhhNik7IC8vIEE2QTZBNkE2QTZBNkE2QTZcblxuLyoqXG4gKiBBRVMtS1cgKGtleS13cmFwKS4gSW5qZWN0cyBzdGF0aWMgSVYgaW50byBwbGFpbnRleHQsIGFkZHMgY291bnRlciwgZW5jcnlwdHMgNiB0aW1lcy5cbiAqIFJlZHVjZXMgYmxvY2sgc2l6ZSBmcm9tIDE2IHRvIDggYnl0ZXMuXG4gKiBGb3IgcGFkZGVkIHZlcnNpb24sIHVzZSBhZXNrd3AuXG4gKiBbUkZDIDMzOTRdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMzMzk0LyksXG4gKiBbTklTVC5TUC44MDAtMzhGXShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvU3BlY2lhbFB1YmxpY2F0aW9ucy9OSVNULlNQLjgwMC0zOEYucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IGFlc2t3OiAoKGtlazogVWludDhBcnJheSkgPT4gQ2lwaGVyKSAmIHtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiA4IH0sXG4gIChrZWs6IFVpbnQ4QXJyYXkpOiBDaXBoZXIgPT4gKHtcbiAgICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSkge1xuICAgICAgaWYgKCFwbGFpbnRleHQubGVuZ3RoIHx8IHBsYWludGV4dC5sZW5ndGggJSA4ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IGxlbmd0aCcpO1xuICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggPT09IDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignOC1ieXRlIGtleXMgbm90IGFsbG93ZWQgaW4gQUVTS1csIHVzZSBBRVNLV1AgaW5zdGVhZCcpO1xuICAgICAgY29uc3Qgb3V0ID0gY29uY2F0Qnl0ZXMoQUVTS1dfSVYsIHBsYWludGV4dCk7XG4gICAgICBBRVNXLmVuY3J5cHQoa2VrLCBvdXQpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuICAgIGRlY3J5cHQoY2lwaGVydGV4dDogVWludDhBcnJheSkge1xuICAgICAgLy8gY2lwaGVydGV4dCBtdXN0IGJlIGF0IGxlYXN0IDI0IGJ5dGVzIGFuZCBhIG11bHRpcGxlIG9mIDggYnl0ZXNcbiAgICAgIC8vIDI0IGJlY2F1c2Ugc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGJsb2NrICgxIGl2ICsgMikuXG4gICAgICAvLyBSZXBsYWNlIHdpdGggMTYgdG8gZW5hYmxlICc4LWJ5dGUga2V5cydcbiAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDggIT09IDAgfHwgY2lwaGVydGV4dC5sZW5ndGggPCAzICogOClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoJyk7XG4gICAgICBjb25zdCBvdXQgPSBjb3B5Qnl0ZXMoY2lwaGVydGV4dCk7XG4gICAgICBBRVNXLmRlY3J5cHQoa2VrLCBvdXQpO1xuICAgICAgaWYgKCFlcXVhbEJ5dGVzKG91dC5zdWJhcnJheSgwLCA4KSwgQUVTS1dfSVYpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludGVncml0eSBjaGVjayBmYWlsZWQnKTtcbiAgICAgIG91dC5zdWJhcnJheSgwLCA4KS5maWxsKDApOyAvLyBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDgpID09PSBJViwgYnV0IHdlIGNsZWFuIGl0IGFueXdheVxuICAgICAgcmV0dXJuIG91dC5zdWJhcnJheSg4KTtcbiAgICB9LFxuICB9KVxuKTtcblxuLypcbldlIGRvbid0IHN1cHBvcnQgOC1ieXRlIGtleXMuIFRoZSByYWJiaXQgaG9sZTpcblxuLSBXeWNoZXByb29mIHNheXM6IFwiTklTVCBTUCA4MDAtMzhGIGRvZXMgbm90IGRlZmluZSB0aGUgd3JhcHBpbmcgb2YgOCBieXRlIGtleXMuXG4gIFJGQyAzMzk0IFNlY3Rpb24gMiAgb24gdGhlIG90aGVyIGhhbmQgc3BlY2lmaWVzIHRoYXQgOCBieXRlIGtleXMgYXJlIHdyYXBwZWRcbiAgYnkgZGlyZWN0bHkgZW5jcnlwdGluZyBvbmUgYmxvY2sgd2l0aCBBRVMuXCJcbiAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9DMlNQL3d5Y2hlcHJvb2YvYmxvYi9tYXN0ZXIvZG9jL2tleV93cmFwLm1kXG4gICAgLSBcIlJGQyAzMzk0IHNwZWNpZmllcyBpbiBTZWN0aW9uIDIsIHRoYXQgdGhlIGlucHV0IGZvciB0aGUga2V5IHdyYXBcbiAgICAgIGFsZ29yaXRobSBtdXN0IGJlIGF0IGxlYXN0IHR3byBibG9ja3MgYW5kIG90aGVyd2lzZSB0aGUgY29uc3RhbnRcbiAgICAgIGZpZWxkIGFuZCBrZXkgYXJlIHNpbXBseSBlbmNyeXB0ZWQgd2l0aCBFQ0IgYXMgYSBzaW5nbGUgYmxvY2tcIlxuLSBXaGF0IFJGQyAzMzk0IGFjdHVhbGx5IHNheXMgKGluIFNlY3Rpb24gMik6XG4gICAgLSBcIkJlZm9yZSBiZWluZyB3cmFwcGVkLCB0aGUga2V5IGRhdGEgaXMgcGFyc2VkIGludG8gbiBibG9ja3Mgb2YgNjQgYml0cy5cbiAgICAgIFRoZSBvbmx5IHJlc3RyaWN0aW9uIHRoZSBrZXkgd3JhcCBhbGdvcml0aG0gcGxhY2VzIG9uIG4gaXMgdGhhdCBuIGJlXG4gICAgICBhdCBsZWFzdCB0d29cIlxuICAgIC0gXCJGb3Iga2V5IGRhdGEgd2l0aCBsZW5ndGggbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDY0IGJpdHMsIHRoZSBjb25zdGFudFxuICAgICAgZmllbGQgdXNlZCBpbiB0aGlzIHNwZWNpZmljYXRpb24gYW5kIHRoZSBrZXkgZGF0YSBmb3JtIGEgc2luZ2xlXG4gICAgICAxMjgtYml0IGNvZGVib29rIGlucHV0IG1ha2luZyB0aGlzIGtleSB3cmFwIHVubmVjZXNzYXJ5LlwiXG4tIFdoaWNoIG1lYW5zIFwiYXNzZXJ0KG4gPj0gMilcIiBhbmQgXCJ1c2Ugc29tZXRoaW5nIGVsc2UgZm9yIDggYnl0ZSBrZXlzXCJcbi0gTklTVCBTUDgwMC0zOEYgYWN0dWFsbHkgcHJvaGliaXRzIDgtYnl0ZSBpbiBcIjUuMy4xIE1hbmRhdG9yeSBMaW1pdHNcIi5cbiAgSXQgc3RhdGVzIHRoYXQgcGxhaW50ZXh0IGZvciBLVyBzaG91bGQgYmUgXCIyIHRvIDJeNTQgLTEgc2VtaWJsb2Nrc1wiLlxuLSBTbywgd2hlcmUgZG9lcyBcImRpcmVjdGx5IGVuY3J5cHQgc2luZ2xlIGJsb2NrIHdpdGggQUVTXCIgY29tZSBmcm9tP1xuICAgIC0gTm90IFJGQyAzMzk0LiBQc2V1ZG9jb2RlIG9mIGtleSB3cmFwIGluIDIuMiBleHBsaWNpdGx5IHVzZXNcbiAgICAgIGxvb3Agb2YgNiBmb3IgYW55IGNvZGUgcGF0aFxuICAgIC0gVGhlcmUgaXMgYSB3ZWlyZCBXM0Mgc3BlYzpcbiAgICAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAyL1JFQy14bWxlbmMtY29yZS0yMDAyMTIxMC9PdmVydmlldy5odG1sI2t3LWFlczEyOFxuICAgIC0gVGhpcyBzcGVjIGlzIG91dGRhdGVkLCBhcyBhZG1pdHRlZCBieSBXeWNoZXByb29mIGF1dGhvcnNcbiAgICAtIFRoZXJlIGlzIFJGQyA1NjQ5IGZvciBwYWRkZWQga2V5IHdyYXAsIHdoaWNoIGlzIHBhZGRpbmcgY29uc3RydWN0aW9uIG9uXG4gICAgICB0b3Agb2YgQUVTS1cuIEluICc0LjEuMicgaXQgc2F5czogXCJJZiB0aGUgcGFkZGVkIHBsYWludGV4dCBjb250YWlucyBleGFjdGx5XG4gICAgICBlaWdodCBvY3RldHMsIHRoZW4gcHJlcGVuZCB0aGUgQUlWIGFzIGRlZmluZWQgaW4gU2VjdGlvbiAzIGFib3ZlIHRvIFBbMV0gYW5kXG4gICAgICBlbmNyeXB0IHRoZSByZXN1bHRpbmcgMTI4LWJpdCBibG9jayB1c2luZyBBRVMgaW4gRUNCIG1vZGUgW01vZGVzXSB3aXRoIGtleVxuICAgICAgSyAodGhlIEtFSykuICBJbiB0aGlzIGNhc2UsIHRoZSBvdXRwdXQgaXMgdHdvIDY0LWJpdCBibG9ja3MgQ1swXSBhbmQgQ1sxXTpcIlxuICAgIC0gQnJvd3NlciBzdWJ0bGUgY3J5cHRvIGlzIGFjdHVhbGx5IGNyYXNoZXMgb24gd3JhcHBpbmcga2V5cyBsZXNzIHRoYW4gMTYgYnl0ZXM6XG4gICAgICBgRXJyb3I6IGVycm9yOjFDODAwMEU2OlByb3ZpZGVyIHJvdXRpbmVzOjppbnZhbGlkIGlucHV0IGxlbmd0aF0geyBvcGVuc3NsRXJyb3JTdGFjazogWyAnZXJyb3I6MDMwMDAwQkQ6ZGlnaXRhbCBlbnZlbG9wZSByb3V0aW5lczo6dXBkYXRlIGVycm9yJyBdYFxuXG5JbiB0aGUgZW5kLCBzZWVtcyBsaWtlIGEgYnVnIGluIFd5Y2hlcHJvb2YuXG5UaGUgOC1ieXRlIGNoZWNrIGNhbiBiZSBlYXNpbHkgZGlzYWJsZWQgaW5zaWRlIG9mIEFFU19XLlxuKi9cblxuY29uc3QgQUVTS1dQX0lWID0gMHhhNjU5NTlhNjsgLy8gc2luZ2xlIHUzMmxlIHZhbHVlXG5cbi8qKlxuICogQUVTLUtXLCBidXQgd2l0aCBwYWRkaW5nIGFuZCBhbGxvd3MgcmFuZG9tIGtleXMuXG4gKiBTZWNvbmQgdTMyIG9mIElWIGlzIHVzZWQgYXMgY291bnRlciBmb3IgbGVuZ3RoLlxuICogW1JGQyA1NjQ5XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTY0OSlcbiAqL1xuZXhwb3J0IGNvbnN0IGFlc2t3cDogKChrZWs6IFVpbnQ4QXJyYXkpID0+IENpcGhlcikgJiB7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xufSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogOCB9LFxuICAoa2VrOiBVaW50OEFycmF5KTogQ2lwaGVyID0+ICh7XG4gICAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIGlmICghcGxhaW50ZXh0Lmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBsZW5ndGgnKTtcbiAgICAgIGNvbnN0IHBhZGRlZCA9IE1hdGguY2VpbChwbGFpbnRleHQubGVuZ3RoIC8gOCkgKiA4O1xuICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCArIHBhZGRlZCk7XG4gICAgICBvdXQuc2V0KHBsYWludGV4dCwgOCk7XG4gICAgICBjb25zdCBvdXQzMiA9IHUzMihvdXQpO1xuICAgICAgb3V0MzJbMF0gPSBBRVNLV1BfSVY7XG4gICAgICBvdXQzMlsxXSA9IGJ5dGVTd2FwKHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgQUVTVy5lbmNyeXB0KGtlaywgb3V0KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIC8vIDE2IGJlY2F1c2Ugc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrXG4gICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggPCAxNikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoJyk7XG4gICAgICBjb25zdCBvdXQgPSBjb3B5Qnl0ZXMoY2lwaGVydGV4dCk7XG4gICAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICAgIEFFU1cuZGVjcnlwdChrZWssIG91dCk7XG4gICAgICBjb25zdCBsZW4gPSBieXRlU3dhcChvMzJbMV0pID4+PiAwO1xuICAgICAgY29uc3QgcGFkZGVkID0gTWF0aC5jZWlsKGxlbiAvIDgpICogODtcbiAgICAgIGlmIChvMzJbMF0gIT09IEFFU0tXUF9JViB8fCBvdXQubGVuZ3RoIC0gOCAhPT0gcGFkZGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVncml0eSBjaGVjayBmYWlsZWQnKTtcbiAgICAgIGZvciAobGV0IGkgPSBsZW47IGkgPCBwYWRkZWQ7IGkrKylcbiAgICAgICAgaWYgKG91dFs4ICsgaV0gIT09IDApIHRocm93IG5ldyBFcnJvcignaW50ZWdyaXR5IGNoZWNrIGZhaWxlZCcpO1xuICAgICAgb3V0LnN1YmFycmF5KDAsIDgpLmZpbGwoMCk7IC8vIGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgOCkgPT09IElWLCBidXQgd2UgY2xlYW4gaXQgYW55d2F5XG4gICAgICByZXR1cm4gb3V0LnN1YmFycmF5KDgsIDggKyBsZW4pO1xuICAgIH0sXG4gIH0pXG4pO1xuXG5jbGFzcyBfQWVzQ3RyRFJCRyBpbXBsZW1lbnRzIFBSRyB7XG4gIHJlYWRvbmx5IGJsb2NrTGVuOiBudW1iZXI7XG4gIHByaXZhdGUga2V5OiBVaW50OEFycmF5O1xuICBwcml2YXRlIG5vbmNlOiBVaW50OEFycmF5O1xuICBwcml2YXRlIHN0YXRlOiBVaW50OEFycmF5O1xuICBwcml2YXRlIHJlc2VlZENudDogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihrZXlMZW46IG51bWJlciwgc2VlZDogVWludDhBcnJheSwgcGVyc29uYWxpemF0aW9uPzogVWludDhBcnJheSkge1xuICAgIHRoaXMuYmxvY2tMZW4gPSBjdHIuYmxvY2tTaXplO1xuICAgIGNvbnN0IGtleUxlbkJ5dGVzID0ga2V5TGVuIC8gODtcbiAgICBjb25zdCBub25jZUxlbiA9IDE2O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheShrZXlMZW5CeXRlcyArIG5vbmNlTGVuKTtcbiAgICB0aGlzLmtleSA9IHRoaXMuc3RhdGUuc3ViYXJyYXkoMCwga2V5TGVuQnl0ZXMpO1xuICAgIHRoaXMubm9uY2UgPSB0aGlzLnN0YXRlLnN1YmFycmF5KGtleUxlbkJ5dGVzLCBrZXlMZW5CeXRlcyArIG5vbmNlTGVuKTtcbiAgICB0aGlzLnJlc2VlZENudCA9IDE7XG4gICAgaW5jQnl0ZXModGhpcy5ub25jZSwgZmFsc2UsIDEpO1xuICAgIHRoaXMuYWRkRW50cm9weShzZWVkLCBwZXJzb25hbGl6YXRpb24pO1xuICB9XG4gIHByaXZhdGUgdXBkYXRlKGRhdGE/OiBVaW50OEFycmF5KSB7XG4gICAgLy8gY2Fubm90IHJlLXVzZSBzdGF0ZSBoZXJlLCBiZWNhdXNlIHdlIHdpbGwgd2lwZSBjdXJyZW50IGtleVxuICAgIGN0cih0aGlzLmtleSwgdGhpcy5ub25jZSkuZW5jcnlwdChuZXcgVWludDhBcnJheSh0aGlzLnN0YXRlLmxlbmd0aCksIHRoaXMuc3RhdGUpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHRoaXMuc3RhdGVbaV0gXj0gZGF0YVtpXTtcbiAgICB9XG4gICAgaW5jQnl0ZXModGhpcy5ub25jZSwgZmFsc2UsIDEpO1xuICB9XG4gIGFkZEVudHJvcHkoc2VlZDogVWludDhBcnJheSwgaW5mbz86IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBhYnl0ZXMoc2VlZCwgdGhpcy5zdGF0ZS5sZW5ndGgsICdzZWVkJyk7XG4gICAgY29uc3QgX3NlZWQgPSBzZWVkLnNsaWNlKCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGFieXRlcyhpbmZvKTtcbiAgICAgIGlmIChpbmZvLmxlbmd0aCA+IF9zZWVkLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdpbmZvIGxlbmd0aCBpcyB0b28gYmlnJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZm8ubGVuZ3RoOyBpKyspIF9zZWVkW2ldIF49IGluZm9baV07XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKF9zZWVkKTtcbiAgICBfc2VlZC5maWxsKDApO1xuICAgIHRoaXMucmVzZWVkQ250ID0gMTtcbiAgfVxuICByYW5kb21CeXRlcyhsZW46IG51bWJlciwgaW5mbz86IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgICBhbnVtYmVyKGxlbik7XG4gICAgaWYgKHRoaXMucmVzZWVkQ250KysgPj0gMiAqKiA0OCkgdGhyb3cgbmV3IEVycm9yKCdlbnRyb3B5IGV4aGF1c3RlZCcpO1xuICAgIGlmIChpbmZvKSB0aGlzLnVwZGF0ZShpbmZvKTtcbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGN0cih0aGlzLmtleSwgdGhpcy5ub25jZSkuZW5jcnlwdChyZXMsIHJlcyk7XG4gICAgaW5jQnl0ZXModGhpcy5ub25jZSwgZmFsc2UsIE1hdGguY2VpbChsZW4gLyB0aGlzLmJsb2NrTGVuKSk7XG4gICAgdGhpcy51cGRhdGUoaW5mbyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjbGVhbigpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgdGhpcy5yZXNlZWRDbnQgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFlc0N0ckRyYmcgPSAoc2VlZDogVWludDhBcnJheSwgcGVyc29uYWxpemF0aW9uPzogVWludDhBcnJheSkgPT4gX0Flc0N0ckRSQkc7XG5cbmNvbnN0IGNyZWF0ZUFlc0RyYmc6IChrZXlMZW46IG51bWJlcikgPT4gQWVzQ3RyRHJiZyA9IChrZXlMZW4pID0+IHtcbiAgcmV0dXJuIChzZWVkLCBwZXJzb25hbGl6YXRpb24gPSB1bmRlZmluZWQpID0+IG5ldyBfQWVzQ3RyRFJCRyhrZXlMZW4sIHNlZWQsIHBlcnNvbmFsaXphdGlvbik7XG59O1xuXG4vKipcbiAqIEFFUy1DVFIgRFJCRyAxMjgtYml0IC0gQ1NQUk5HIChjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLlxuICogSXQncyBiZXN0IHRvIGxpbWl0IHVzYWdlIHRvIG5vbi1wcm9kdWN0aW9uLCBub24tY3JpdGljYWwgY2FzZXM6IGZvciBleGFtcGxlLCB0ZXN0LW9ubHkuXG4gKi9cbmV4cG9ydCBjb25zdCBybmdBZXNDdHJEcmJnMTI4OiBBZXNDdHJEcmJnID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFlc0RyYmcoMTI4KTtcbi8qKlxuICogQUVTLUNUUiBEUkJHIDI1Ni1iaXQgLSBDU1BSTkcgKGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvcikuXG4gKiBJdCdzIGJlc3QgdG8gbGltaXQgdXNhZ2UgdG8gbm9uLXByb2R1Y3Rpb24sIG5vbi1jcml0aWNhbCBjYXNlczogZm9yIGV4YW1wbGUsIHRlc3Qtb25seS5cbiAqL1xuZXhwb3J0IGNvbnN0IHJuZ0Flc0N0ckRyYmcyNTY6IEFlc0N0ckRyYmcgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWVzRHJiZygyNTYpO1xuXG4vLyNyZWdpb24gQ01BQ1xuXG4vKipcbiAqIExlZnQtc2hpZnQgYnkgb25lIGJpdCBhbmQgY29uZGl0aW9uYWxseSBYT1Igd2l0aCAweDg3OlxuICogYGBgXG4gKiBpZiBNU0IoTCkgaXMgZXF1YWwgdG8gMFxuICogdGhlbiAgICBLMSA6PSBMIDw8IDE7XG4gKiBlbHNlICAgIEsxIDo9IChMIDw8IDEpIFhPUiBjb25zdF9SYjtcbiAqIGBgYFxuICpcbiAqIFNwZWNzOiBbUkZDIDQ0OTMsIFNlY3Rpb24gMi4zXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNDQ5My5odG1sI3NlY3Rpb24tMi4zKSxcbiAqICAgICAgICBbUkZDIDUyOTcgU2VjdGlvbiAyLjNdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNTI5Ny5odG1sI3NlY3Rpb24tMi4zKVxuICpcbiAqIEByZXR1cm5zIG1vZGlmaWVkIGBibG9ja2AgKGZvciBjaGFpbmluZylcbiAqL1xuZnVuY3Rpb24gZGJsPFQgZXh0ZW5kcyBVaW50OEFycmF5PihibG9jazogVCk6IFQge1xuICBsZXQgY2FycnkgPSAwO1xuXG4gIC8vIExlZnQgc2hpZnQgYnkgMSBiaXRcbiAgZm9yIChsZXQgaSA9IEJMT0NLX1NJWkUgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG5ld0NhcnJ5ID0gKGJsb2NrW2ldICYgMHg4MCkgPj4+IDc7XG4gICAgYmxvY2tbaV0gPSAoYmxvY2tbaV0gPDwgMSkgfCBjYXJyeTtcbiAgICBjYXJyeSA9IG5ld0NhcnJ5O1xuICB9XG5cbiAgLy8gWE9SIHdpdGggMHg4NyBpZiB0aGVyZSB3YXMgYSBjYXJyeSBmcm9tIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdFxuICBpZiAoY2FycnkpIHtcbiAgICBibG9ja1tCTE9DS19TSVpFIC0gMV0gXj0gMHg4NztcbiAgfVxuXG4gIHJldHVybiBibG9jaztcbn1cblxuLyoqXG4gKiBgYSBYT1IgYmAsIHJ1bm5pbmcgaW4tc2l0ZSBvbiBgYWAuXG4gKiBAcGFyYW0gYSBsZWZ0IG9wZXJhbmQgYW5kIG91dHB1dFxuICogQHBhcmFtIGIgcmlnaHQgb3BlcmFuZFxuICogQHJldHVybnMgYGFgIChmb3IgY2hhaW5pbmcpXG4gKi9cbmZ1bmN0aW9uIHhvckJsb2NrPFQgZXh0ZW5kcyBVaW50OEFycmF5PihhOiBULCBiOiBVaW50OEFycmF5KTogVCB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigneG9yQmxvY2s6IGJsb2NrcyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgYVtpXSA9IGFbaV0gXiBiW2ldO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIHhvcmVuZCBhcyBkZWZpbmVkIGluIFtSRkMgNTI5NyBTZWN0aW9uIDIuMV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM1Mjk3Lmh0bWwjc2VjdGlvbi0yLjEpLlxuICpcbiAqIGBgYFxuICogbGVmdG1vc3QoQSwgbGVuKEEpLWxlbihCKSkgfHwgKHJpZ2h0bW9zdChBLCBsZW4oQikpIHhvciBCKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHhvcmVuZDxUIGV4dGVuZHMgVWludDhBcnJheT4oYTogVCwgYjogVWludDhBcnJheSk6IFQge1xuICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigneG9yZW5kOiBsZW4oQikgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbGVuKEEpJyk7XG4gIH1cbiAgLy8ga2VlcCBsZWZ0bW9zdCBwYXJ0IG9mIGBhYCB1bmNoYW5nZWRcbiAgLy8gYW5kIHhvciBvbmx5IHRoZSByaWdodG1vc3QgcGFydDpcbiAgY29uc3Qgb2Zmc2V0ID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgYVtvZmZzZXQgKyBpXSA9IGFbb2Zmc2V0ICsgaV0gXiBiW2ldO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIEludGVybmFsIENNQUMgY2xhc3MuXG4gKi9cbmNsYXNzIF9DTUFDIHtcbiAgcHJpdmF0ZSBidWZmZXI6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgZGVzdHJveWVkOiBib29sZWFuO1xuICBwcml2YXRlIGsxOiBVaW50OEFycmF5O1xuICBwcml2YXRlIGsyOiBVaW50OEFycmF5O1xuICBwcml2YXRlIHhrOiBVaW50MzJBcnJheTtcblxuICBjb25zdHJ1Y3RvcihrZXk6IFVpbnQ4QXJyYXkpIHtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICB2YWxpZGF0ZUtleUxlbmd0aChrZXkpO1xuICAgIHRoaXMueGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAvLyBMID0gQUVTX2VuY3J5cHQoSywgY29uc3RfWmVybylcbiAgICBjb25zdCBMID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG4gICAgZW5jcnlwdEJsb2NrKHRoaXMueGssIEwpO1xuICAgIC8vIEdlbmVyYXRlIHN1YmtleXMgSzEgYW5kIEsyIGZyb20gdGhlIG1haW4ga2V5IGFjY29yZGluZyB0b1xuICAgIC8vIFtSRkMgNDQ5MywgU2VjdGlvbiAyLjNdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM0NDkzLmh0bWwjc2VjdGlvbi0yLjMpXG4gICAgLy8gSzFcbiAgICB0aGlzLmsxID0gZGJsKEwpO1xuICAgIHRoaXMuazIgPSBkYmwobmV3IFVpbnQ4QXJyYXkodGhpcy5rMSkpO1xuICB9XG5cbiAgdXBkYXRlKGRhdGE6IFVpbnQ4QXJyYXkpOiBfQ01BQyB7XG4gICAgY29uc3QgeyBkZXN0cm95ZWQsIGJ1ZmZlciB9ID0gdGhpcztcbiAgICBpZiAoZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ0NNQUMgaW5zdGFuY2Ugd2FzIGRlc3Ryb3llZCcpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuICAgIG5ld0J1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICBuZXdCdWZmZXIuc2V0KGRhdGEsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM0NDkzLmh0bWwjc2VjdGlvbi0yLjRcbiAgZGlnZXN0KCk6IFVpbnQ4QXJyYXlCdWZmZXIge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdDTUFDIGluc3RhbmNlIHdhcyBkZXN0cm95ZWQnKTtcbiAgICBjb25zdCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICBjb25zdCBtc2dMZW4gPSBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gU3RlcCAyOlxuICAgIGxldCBuID0gTWF0aC5jZWlsKG1zZ0xlbiAvIEJMT0NLX1NJWkUpOyAvLyBuIDo9IGNlaWwobGVuL2NvbnN0X0JzaXplKTtcblxuICAgIC8vIFN0ZXAgMzpcbiAgICBsZXQgZmxhZzogYm9vbGVhbjsgLy8gZGVub3RpbmcgaWYgbGFzdCBibG9jayBpcyBjb21wbGV0ZSBvciBub3RcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgbiA9IDE7XG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBtc2dMZW4gJSBCTE9DS19TSVpFID09PSAwOyAvLyBpZiBsZW4gbW9kIGNvbnN0X0JzaXplIGlzIDBcbiAgICB9XG5cbiAgICAvLyBTdGVwIDQ6XG4gICAgY29uc3QgbGFzdEJsb2NrU3RhcnQgPSAobiAtIDEpICogQkxPQ0tfU0laRTtcbiAgICBjb25zdCBsYXN0QmxvY2tEYXRhID0gYnVmZmVyLnN1YmFycmF5KGxhc3RCbG9ja1N0YXJ0KTtcbiAgICBsZXQgbV9sYXN0OiBVaW50OEFycmF5QnVmZmVyO1xuICAgIGlmIChmbGFnKSB7XG4gICAgICAvLyBNX2xhc3QgOj0gTV9uIFhPUiBLMTtcbiAgICAgIG1fbGFzdCA9IHhvckJsb2NrKG5ldyBVaW50OEFycmF5KGxhc3RCbG9ja0RhdGEpLCB0aGlzLmsxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTV9sYXN0IDo9IHBhZGRpbmcoTV9uKSBYT1IgSzI7XG4gICAgICAvL1xuICAgICAgLy8gWy4uLl0gcGFkZGluZyh4KSBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB4IGFuZCBhIHNpbmdsZSAnMScsXG4gICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbWluaW11bSBudW1iZXIgb2YgJzAncywgc28gdGhhdCB0aGUgdG90YWwgbGVuZ3RoIGlzXG4gICAgICAvLyBlcXVhbCB0byAxMjggYml0cy5cbiAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KEJMT0NLX1NJWkUpO1xuICAgICAgcGFkZGVkLnNldChsYXN0QmxvY2tEYXRhKTtcbiAgICAgIHBhZGRlZFtsYXN0QmxvY2tEYXRhLmxlbmd0aF0gPSAweDgwOyAvLyBzaW5nbGUgJzEnIGJpdFxuICAgICAgbV9sYXN0ID0geG9yQmxvY2socGFkZGVkLCB0aGlzLmsyKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDU6XG4gICAgbGV0IHggPSBuZXcgVWludDhBcnJheShCTE9DS19TSVpFKTsgLy8gWCA6PSBjb25zdF9aZXJvO1xuXG4gICAgLy8gU3RlcCA2OlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgY29uc3QgbV9pID0gYnVmZmVyLnN1YmFycmF5KGkgKiBCTE9DS19TSVpFLCAoaSArIDEpICogQkxPQ0tfU0laRSk7IC8vIE1faVxuICAgICAgeG9yQmxvY2soeCwgbV9pKTsgLy8gWSA6PSBYIFhPUiBNX2k7XG4gICAgICBlbmNyeXB0QmxvY2sodGhpcy54aywgeCk7IC8vIFggOj0gQUVTLTEyOChLLFkpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgNzpcbiAgICB4b3JCbG9jayh4LCBtX2xhc3QpOyAvLyBZIDo9IE1fbGFzdCBYT1IgWDtcbiAgICBlbmNyeXB0QmxvY2sodGhpcy54aywgeCk7IC8vIFQgOj0gQUVTLTEyOChLLFkpO1xuXG4gICAgLy8gY2xlYW51cDpcbiAgICBjbGVhbihtX2xhc3QpO1xuXG4gICAgcmV0dXJuIHg7IC8vIFRcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgY29uc3QgeyBidWZmZXIsIGRlc3Ryb3llZCwgeGssIGsxLCBrMiB9ID0gdGhpcztcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNsZWFuKGJ1ZmZlciwgeGssIGsxLCBrMik7XG4gIH1cbn1cblxuLyoqXG4gKiBBRVMtQ01BQyAoQ2lwaGVyLWJhc2VkIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSkuXG4gKiBTcGVjczogW1JGQyA0NDkzXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNDQ5My5odG1sKS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNtYWM6IHtcbiAgKGtleTogVWludDhBcnJheSwgbWVzc2FnZTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG4gIGNyZWF0ZShrZXk6IFVpbnQ4QXJyYXkpOiBfQ01BQztcbn0gPSAoa2V5OiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5KTogVWludDhBcnJheSA9PiBuZXcgX0NNQUMoa2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5jbWFjLmNyZWF0ZSA9IChrZXk6IFVpbnQ4QXJyYXkpOiBfQ01BQyA9PiBuZXcgX0NNQUMoa2V5KTtcblxuLyoqXG4gKiBTMlYgKFN5bnRoZXRpYyBJbml0aWFsaXphdGlvbiBWZWN0b3IpIGZ1bmN0aW9uIGFzIGRlc2NyaWJlZCBpbiBbUkZDIDUyOTcgU2VjdGlvbiAyLjRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNTI5Ny5odG1sI3NlY3Rpb24tMi40KS5cbiAqXG4gKiBgYGBcbiAqIFMyVihLLCBTMSwgLi4uLCBTbikge1xuICogICBpZiBuID0gMCB0aGVuXG4gKiAgICAgcmV0dXJuIFYgPSBBRVMtQ01BQyhLLCA8b25lPilcbiAqICAgZmlcbiAqICAgRCA9IEFFUy1DTUFDKEssIDx6ZXJvPilcbiAqICAgZm9yIGkgPSAxIHRvIG4tMSBkb1xuICogICAgIEQgPSBkYmwoRCkgeG9yIEFFUy1DTUFDKEssIFNpKVxuICogICBkb25lXG4gKiAgIGlmIGxlbihTbikgPj0gMTI4IHRoZW5cbiAqICAgICBUID0gU24geG9yZW5kIERcbiAqICAgZWxzZVxuICogICAgIFQgPSBkYmwoRCkgeG9yIHBhZChTbilcbiAqICAgZmlcbiAqICAgcmV0dXJuIFYgPSBBRVMtQ01BQyhLLCBUKVxuICogfVxuICogYGBgXG4gKlxuICogUzJWIHRha2VzIGEga2V5IGFuZCBhIHZlY3RvciBvZiBzdHJpbmdzIFMxLCBTMiwgLi4uLCBTbiBhbmQgcmV0dXJucyBhIDEyOC1iaXQgc3RyaW5nLlxuICogVGhlIFMyViBmdW5jdGlvbiBpcyB1c2VkIHRvIGdlbmVyYXRlIGEgc3ludGhldGljIElWIGZvciBBRVMtU0lWLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBBRVMga2V5ICgxMjgsIDE5Miwgb3IgMjU2IGJpdHMpXG4gKiBAcGFyYW0gc3RyaW5ncyAtIEFycmF5IG9mIGJ5dGUgYXJyYXlzIHRvIHByb2Nlc3NcbiAqIEByZXR1cm5zIDEyOC1iaXQgc3ludGhldGljIElWXG4gKi9cbmZ1bmN0aW9uIHMydihrZXk6IFVpbnQ4QXJyYXksIHN0cmluZ3M6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkge1xuICB2YWxpZGF0ZUtleUxlbmd0aChrZXkpO1xuICBjb25zdCBsZW4gPSBzdHJpbmdzLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDEyNykge1xuICAgIC8vIHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzUyOTcuaHRtbCNzZWN0aW9uLTdcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3MydjogbnVtYmVyIG9mIGlucHV0IHN0cmluZ3MgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTI3Jyk7XG4gIH1cblxuICBpZiAobGVuID09PSAwKSByZXR1cm4gY21hYyhrZXksIE9ORV9CTE9DSyk7XG5cbiAgLy8gRCA9IEFFUy1DTUFDKEssIDx6ZXJvPilcbiAgbGV0IGQgPSBjbWFjKGtleSwgRU1QVFlfQkxPQ0spO1xuXG4gIC8vIGZvciBpID0gMSB0byBuLTEgZG9cbiAgLy8gICBEID0gZGJsKEQpIHhvciBBRVMtQ01BQyhLLCBTaSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBkYmwoZCk7XG4gICAgY29uc3QgY21hY1Jlc3VsdCA9IGNtYWMoa2V5LCBzdHJpbmdzW2ldKTtcbiAgICB4b3JCbG9jayhkLCBjbWFjUmVzdWx0KTtcbiAgICBjbGVhbihjbWFjUmVzdWx0KTtcbiAgfVxuXG4gIGNvbnN0IHNfbiA9IHN0cmluZ3NbbGVuIC0gMV07XG4gIGxldCB0OiBVaW50OEFycmF5O1xuXG4gIC8vIGlmIGxlbihTbikgPj0gMTI4IHRoZW5cbiAgaWYgKHNfbi5ieXRlTGVuZ3RoID49IEJMT0NLX1NJWkUpIHtcbiAgICAvLyBUID0gU24geG9yZW5kIERcbiAgICB0ID0geG9yZW5kKFVpbnQ4QXJyYXkuZnJvbShzX24pLCBkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwYWQoU24pOlxuICAgIGNvbnN0IHBhZGRlZFNuID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG4gICAgcGFkZGVkU24uc2V0KHNfbik7XG4gICAgcGFkZGVkU25bc19uLmxlbmd0aF0gPSAweDgwOyAvLyBwYWRkaW5nOiAweDgwIGZvbGxvd2VkIGJ5IHplcm9zXG5cbiAgICAvLyBUID0gZGJsKEQpIHhvciBwYWQoU24pXG4gICAgdCA9IHhvckJsb2NrKGRibChkKSwgcGFkZGVkU24pO1xuICAgIGNsZWFuKHBhZGRlZFNuKTtcbiAgfVxuXG4gIC8vIFYgPSBBRVMtQ01BQyhLLCBUKVxuICBjb25zdCByZXN1bHQgPSBjbWFjKGtleSwgdCk7XG4gIGNsZWFuKGQsIHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlIGBnY21zaXZgIG9yIGBhZXNzaXZgLiAqL1xuZXhwb3J0IGNvbnN0IHNpdjogKCkgPT4gbmV2ZXIgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignXCJzaXZcIiBmcm9tIHYxIGlzIG5vdyBcImdjbXNpdlwiJyk7XG59O1xuXG4vKipcbiAqICoqU0lWKio6IFN5bnRoZXRpYyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKFNJVikgQXV0aGVudGljYXRlZCBFbmNyeXB0aW9uXG4gKiBOb25jZSBpcyBkZXJpdmVkIGZyb20gdGhlIHBsYWludGV4dCBhbmQgQUFEIHVzaW5nIHRoZSBTMlYgZnVuY3Rpb24uXG4gKiBTZWUgW1JGQyA1Mjk3XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzUyOTcuaHRtbCkuXG4gKi9cbmV4cG9ydCBjb25zdCBhZXNzaXY6ICgoa2V5OiBVaW50OEFycmF5LCAuLi5BQUQ6IFVpbnQ4QXJyYXlbXSkgPT4gQ2lwaGVyKSAmIHtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG4gIHRhZ0xlbmd0aDogbnVtYmVyO1xufSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogMTYsIHRhZ0xlbmd0aDogMTYgfSxcbiAgZnVuY3Rpb24gYWVzc2l2KGtleTogVWludDhBcnJheSwgLi4uQUFEOiBVaW50OEFycmF5W10pOiBDaXBoZXIge1xuICAgIC8vIEZyb20gUkZDIDUyOTc6IFNlY3Rpb24gNi4xLCA2LjIsIDYuMzpcbiAgICBjb25zdCBQTEFJTl9MSU1JVCA9IGxpbWl0KCdwbGFpbnRleHQnLCAwLCAyICoqIDEzMik7XG4gICAgY29uc3QgQ0lQSEVSX0xJTUlUID0gbGltaXQoJ2NpcGhlcnRleHQnLCAxNiwgMiAqKiAxMzIgKyAxNik7XG4gICAgaWYgKEFBRC5sZW5ndGggPiAxMjYpIHtcbiAgICAgIC8vIHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzUyOTcuaHRtbCNzZWN0aW9uLTdcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBQURcIiBudW1iZXIgb2YgZWxlbWVudHMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTI2Jyk7XG4gICAgfVxuICAgIEFBRC5mb3JFYWNoKChhYWQpID0+IGFieXRlcyhhYWQpKTtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICBpZiAoIVszMiwgNDgsIDY0XS5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJhZXMga2V5XCIgZXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggMzIvNDgvNjQsIGdvdCBsZW5ndGg9JyArIGtleS5sZW5ndGgpO1xuXG4gICAgLy8gVGhlIGtleSBpcyBzcGxpdCBpbnRvIGVxdWFsIGhhbHZlcywgSzEgPSBsZWZ0bW9zdChLLCBsZW4oSykvMikgYW5kXG4gICAgLy8gSzIgPSByaWdodG1vc3QoSywgbGVuKEspLzIpLiAgSzEgaXMgdXNlZCBmb3IgUzJWIGFuZCBLMiBpcyB1c2VkIGZvciBDVFIuXG4gICAgY29uc3QgazEgPSBrZXkuc3ViYXJyYXkoMCwga2V5Lmxlbmd0aCAvIDIpO1xuICAgIGNvbnN0IGsyID0ga2V5LnN1YmFycmF5KGtleS5sZW5ndGggLyAyKTtcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzUyOTcuaHRtbCNzZWN0aW9uLTIuNlxuICAgICAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgUExBSU5fTElNSVQocGxhaW50ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgdiA9IHMydihrMSwgWy4uLkFBRCwgcGxhaW50ZXh0XSk7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSAzMXN0IGFuZCA2M3JkIChyaWdodG1vc3QpIGJpdDpcbiAgICAgICAgY29uc3QgcSA9IFVpbnQ4QXJyYXkuZnJvbSh2KTtcbiAgICAgICAgcVs4XSAmPSAweDdmO1xuICAgICAgICBxWzEyXSAmPSAweDdmO1xuXG4gICAgICAgIC8vIGVuY3J5cHQ6XG4gICAgICAgIGNvbnN0IGMgPSBjdHIoazIsIHEpLmVuY3J5cHQocGxhaW50ZXh0KTtcblxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXModiwgYyk7XG4gICAgICB9LFxuICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM1Mjk3Lmh0bWwjc2VjdGlvbi0yLjdcbiAgICAgIGRlY3J5cHQoY2lwaGVydGV4dDogVWludDhBcnJheSkge1xuICAgICAgICBDSVBIRVJfTElNSVQoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCB2ID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCBCTE9DS19TSVpFKTtcbiAgICAgICAgY29uc3QgYyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoQkxPQ0tfU0laRSk7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSAzMXN0IGFuZCA2M3JkIChyaWdodG1vc3QpIGJpdDpcbiAgICAgICAgY29uc3QgcSA9IFVpbnQ4QXJyYXkuZnJvbSh2KTtcbiAgICAgICAgcVs4XSAmPSAweDdmO1xuICAgICAgICBxWzEyXSAmPSAweDdmO1xuXG4gICAgICAgIC8vIGRlY3J5cHQ6XG4gICAgICAgIGNvbnN0IHAgPSBjdHIoazIsIHEpLmRlY3J5cHQoYyk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRhZzpcbiAgICAgICAgY29uc3QgdCA9IHMydihrMSwgWy4uLkFBRCwgcF0pO1xuXG4gICAgICAgIGlmIChlcXVhbEJ5dGVzKHQsIHYpKSB7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpdiB0YWcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG4pO1xuLy8jZW5kcmVnaW9uXG5cbi8qKiBVbnNhZmUgbG93LWxldmVsIGludGVybmFsIG1ldGhvZHMuIE1heSBjaGFuZ2UgYXQgYW55IHRpbWUuICovXG5leHBvcnQgY29uc3QgdW5zYWZlOiB7XG4gIGV4cGFuZEtleUxFOiB0eXBlb2YgZXhwYW5kS2V5TEU7XG4gIGV4cGFuZEtleURlY0xFOiB0eXBlb2YgZXhwYW5kS2V5RGVjTEU7XG4gIGVuY3J5cHQ6IHR5cGVvZiBlbmNyeXB0O1xuICBkZWNyeXB0OiB0eXBlb2YgZGVjcnlwdDtcbiAgZW5jcnlwdEJsb2NrOiB0eXBlb2YgZW5jcnlwdEJsb2NrO1xuICBkZWNyeXB0QmxvY2s6IHR5cGVvZiBkZWNyeXB0QmxvY2s7XG4gIGN0ckNvdW50ZXI6IHR5cGVvZiBjdHJDb3VudGVyO1xuICBjdHIzMjogdHlwZW9mIGN0cjMyO1xuICBkYmw6IHR5cGVvZiBkYmw7XG4gIHhvckJsb2NrOiB0eXBlb2YgeG9yQmxvY2s7XG4gIHhvcmVuZDogdHlwZW9mIHhvcmVuZDtcbiAgczJ2OiB0eXBlb2YgczJ2O1xufSA9IHtcbiAgZXhwYW5kS2V5TEUsXG4gIGV4cGFuZEtleURlY0xFLFxuICBlbmNyeXB0LFxuICBkZWNyeXB0LFxuICBlbmNyeXB0QmxvY2ssXG4gIGRlY3J5cHRCbG9jayxcbiAgY3RyQ291bnRlcixcbiAgY3RyMzIsXG4gIGRibCxcbiAgeG9yQmxvY2ssXG4gIHhvcmVuZCxcbiAgczJ2LFxufTtcbiIsICIvKipcbiAqIEJhc2ljIHV0aWxzIGZvciBBUlggKGFkZC1yb3RhdGUteG9yKSBzYWxzYSBhbmQgY2hhY2hhIGNpcGhlcnMuXG5cblJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuYXV0aEtleSBzdGFydHMgd2l0aCBjb3VudGVyOiAwLCBhY3R1YWwgbXNnIHdpdGggY291bnRlcjogMS5cblxuRm9yIHRoaXMsIHdlIG5lZWQgYSB3YXkgdG8gcmUtdXNlIG5vbmNlIC8gY291bnRlcjpcblxuICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAxXG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMlxuXG5UaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG4tIDMyLWJpdCBjb3VudGVycyBhcmUgZW5vdWdoLCBubyBuZWVkIGZvciA2NC1iaXQ6IG1heCBBcnJheUJ1ZmZlciBzaXplIGluIEpTIGlzIDRHQlxuLSBPcmlnaW5hbCBwYXBlcnMgZG9uJ3QgYWxsb3cgbXV0YXRpbmcgY291bnRlcnNcbi0gQ291bnRlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgW14xXVxuLSBJZGVhIEE6IGFsbG93IHByb3ZpZGluZyAobm9uY2UgfCBjb3VudGVyKSBpbnN0ZWFkIG9mIGp1c3Qgbm9uY2UsIHJlLXVzZSBpdFxuLSBDYXZlYXQ6IENhbm5vdCBiZSByZS11c2VkIHRocm91Z2ggYWxsIGNhc2VzOlxuLSAqIGNoYWNoYSBoYXMgKGNvdW50ZXIgfCBub25jZSlcbi0gKiB4Y2hhY2hhIGhhcyAobm9uY2UxNiB8IGNvdW50ZXIgfCBub25jZTE2KVxuLSBJZGVhIEI6IHNlcGFyYXRlIG5vbmNlIC8gY291bnRlciBhbmQgcHJvdmlkZSBzZXBhcmF0ZSBBUEkgZm9yIGNvdW50ZXIgcmUtdXNlXG4tIENhdmVhdDogdGhlcmUgYXJlIGRpZmZlcmVudCBjb3VudGVyIHNpemVzIGRlcGVuZGluZyBvbiBhbiBhbGdvcml0aG0uXG4tIHNhbHNhICYgY2hhY2hhIGFsc28gZGlmZmVyIGluIHN0cnVjdHVyZXMgb2Yga2V5ICYgc2lnbWE6XG4gIHNhbHNhMjA6ICAgICAgc1swXSB8IGsoNCkgfCBzWzFdIHwgbm9uY2UoMikgfCBjbnQoMikgfCBzWzJdIHwgayg0KSB8IHNbM11cbiAgY2hhY2hhOiAgICAgICBzKDQpIHwgayg4KSB8IGNudCgxKSB8IG5vbmNlKDMpXG4gIGNoYWNoYTIwb3JpZzogcyg0KSB8IGsoOCkgfCBjbnQoMikgfCBub25jZSgyKVxuLSBJZGVhIEM6IGhlbHBlciBtZXRob2Qgc3VjaCBhcyBgc2V0U2Fsc2FTdGF0ZShrZXksIG5vbmNlLCBzaWdtYSwgZGF0YSlgXG4tIENhdmVhdDogd2UgY2FuJ3QgcmUtdXNlIGNvdW50ZXIgYXJyYXlcblxueGNoYWNoYSBbXjJdIHVzZXMgdGhlIHN1YmtleSBhbmQgcmVtYWluaW5nIDggYnl0ZSBub25jZSB3aXRoIENoYUNoYTIwIGFzIG5vcm1hbFxuKHByZWZpeGVkIGJ5IDQgTlVMIGJ5dGVzLCBzaW5jZSBbUkZDODQzOV0gc3BlY2lmaWVzIGEgMTItYnl0ZSBub25jZSkuXG5cblteMV06IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvY2ZyZy9nc09uVEp6Y2JnRzZPcUQ4U2MwR081YVJfdFUvXG5bXjJdOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhI2FwcGVuZGl4LUEuMlxuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7XG4gIHR5cGUgUFJHLFxuICB0eXBlIFhvclN0cmVhbSxcbiAgYWJvb2wsXG4gIGFieXRlcyxcbiAgYW51bWJlcixcbiAgY2hlY2tPcHRzLFxuICBjbGVhbixcbiAgY29weUJ5dGVzLFxuICByYW5kb21CeXRlcyxcbiAgdTMyLFxufSBmcm9tICcuL3V0aWxzLnRzJztcblxuLy8gUmVwbGFjZXMgYFRleHRFbmNvZGVyYCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzXG5jb25zdCBlbmNvZGVTdHIgPSAoc3RyOiBzdHJpbmcpID0+IFVpbnQ4QXJyYXkuZnJvbShzdHIuc3BsaXQoJycpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcbmNvbnN0IHNpZ21hMTYgPSBlbmNvZGVTdHIoJ2V4cGFuZCAxNi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMzIgPSBlbmNvZGVTdHIoJ2V4cGFuZCAzMi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMTZfMzIgPSB1MzIoc2lnbWExNik7XG5jb25zdCBzaWdtYTMyXzMyID0gdTMyKHNpZ21hMzIpO1xuXG4vKiogUm90YXRlIGxlZnQuICovXG5leHBvcnQgZnVuY3Rpb24gcm90bChhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG59XG5cbi8qKiBDaXBoZXJzIG11c3QgdXNlIHUzMiBmb3IgZWZmaWNpZW5jeS4gKi9cbmV4cG9ydCB0eXBlIENpcGhlckNvcmVGbiA9IChcbiAgc2lnbWE6IFVpbnQzMkFycmF5LFxuICBrZXk6IFVpbnQzMkFycmF5LFxuICBub25jZTogVWludDMyQXJyYXksXG4gIG91dHB1dDogVWludDMyQXJyYXksXG4gIGNvdW50ZXI6IG51bWJlcixcbiAgcm91bmRzPzogbnVtYmVyXG4pID0+IHZvaWQ7XG5cbi8qKiBNZXRob2Qgd2hpY2ggZXh0ZW5kcyBrZXkgKyBzaG9ydCBub25jZSBpbnRvIGxhcmdlciBub25jZSAvIGRpZmYga2V5LiAqL1xuZXhwb3J0IHR5cGUgRXh0ZW5kTm9uY2VGbiA9IChcbiAgc2lnbWE6IFVpbnQzMkFycmF5LFxuICBrZXk6IFVpbnQzMkFycmF5LFxuICBpbnB1dDogVWludDMyQXJyYXksXG4gIG91dHB1dDogVWludDMyQXJyYXlcbikgPT4gdm9pZDtcblxuLyoqIEFSWCBjaXBoZXIgb3B0aW9ucy5cbiAqICogYGFsbG93U2hvcnRLZXlzYCBmb3IgMTYtYnl0ZSBrZXlzXG4gKiAqIGBjb3VudGVyTGVuZ3RoYCBpbiBieXRlc1xuICogKiBgY291bnRlclJpZ2h0YDogcmlnaHQ6IGBub25jZXxjb3VudGVyYDsgbGVmdDogYGNvdW50ZXJ8bm9uY2VgXG4gKiAqL1xuZXhwb3J0IHR5cGUgQ2lwaGVyT3B0cyA9IHtcbiAgYWxsb3dTaG9ydEtleXM/OiBib29sZWFuOyAvLyBPcmlnaW5hbCBzYWxzYSAvIGNoYWNoYSBhbGxvdyAxNi1ieXRlIGtleXNcbiAgZXh0ZW5kTm9uY2VGbj86IEV4dGVuZE5vbmNlRm47XG4gIGNvdW50ZXJMZW5ndGg/OiBudW1iZXI7XG4gIGNvdW50ZXJSaWdodD86IGJvb2xlYW47XG4gIHJvdW5kcz86IG51bWJlcjtcbn07XG5cbi8vIElzIGJ5dGUgYXJyYXkgYWxpZ25lZCB0byA0IGJ5dGUgb2Zmc2V0ICh1MzIpP1xuZnVuY3Rpb24gaXNBbGlnbmVkMzIoYjogVWludDhBcnJheSkge1xuICByZXR1cm4gYi5ieXRlT2Zmc2V0ICUgNCA9PT0gMDtcbn1cblxuLy8gU2Fsc2EgYW5kIENoYWNoYSBibG9jayBsZW5ndGggaXMgYWx3YXlzIDUxMi1iaXRcbmNvbnN0IEJMT0NLX0xFTiA9IDY0O1xuY29uc3QgQkxPQ0tfTEVOMzIgPSAxNjtcblxuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMl0pICAgLy8gPT4gVWludDMyQXJyYXkoMSkgWyAwIF1cbi8vIG5ldyBVaW50MzJBcnJheShbMioqMzItMV0pIC8vID0+IFVpbnQzMkFycmF5KDEpIFsgNDI5NDk2NzI5NSBdXG5jb25zdCBNQVhfQ09VTlRFUiA9IDIgKiogMzIgLSAxO1xuXG5jb25zdCBVMzJfRU1QVFkgPSBVaW50MzJBcnJheS5vZigpO1xuZnVuY3Rpb24gcnVuQ2lwaGVyKFxuICBjb3JlOiBDaXBoZXJDb3JlRm4sXG4gIHNpZ21hOiBVaW50MzJBcnJheSxcbiAga2V5OiBVaW50MzJBcnJheSxcbiAgbm9uY2U6IFVpbnQzMkFycmF5LFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvdXRwdXQ6IFVpbnQ4QXJyYXksXG4gIGNvdW50ZXI6IG51bWJlcixcbiAgcm91bmRzOiBudW1iZXJcbik6IHZvaWQge1xuICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgY29uc3QgYmxvY2sgPSBuZXcgVWludDhBcnJheShCTE9DS19MRU4pO1xuICBjb25zdCBiMzIgPSB1MzIoYmxvY2spO1xuICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXJzIGFsaWduZWQgdG8gNCBieXRlc1xuICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuICBjb25zdCBkMzIgPSBpc0FsaWduZWQgPyB1MzIoZGF0YSkgOiBVMzJfRU1QVFk7XG4gIGNvbnN0IG8zMiA9IGlzQWxpZ25lZCA/IHUzMihvdXRwdXQpIDogVTMyX0VNUFRZO1xuICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47IGNvdW50ZXIrKykge1xuICAgIGNvcmUoc2lnbWEsIGtleSwgbm9uY2UsIGIzMiwgY291bnRlciwgcm91bmRzKTtcbiAgICBpZiAoY291bnRlciA+PSBNQVhfQ09VTlRFUikgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oQkxPQ0tfTEVOLCBsZW4gLSBwb3MpO1xuICAgIC8vIGFsaWduZWQgdG8gNCBieXRlc1xuICAgIGlmIChpc0FsaWduZWQgJiYgdGFrZSA9PT0gQkxPQ0tfTEVOKSB7XG4gICAgICBjb25zdCBwb3MzMiA9IHBvcyAvIDQ7XG4gICAgICBpZiAocG9zICUgNCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcng6IGludmFsaWQgYmxvY2sgcG9zaXRpb24nKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOiBudW1iZXI7IGogPCBCTE9DS19MRU4zMjsgaisrKSB7XG4gICAgICAgIHBvc2ogPSBwb3MzMiArIGo7XG4gICAgICAgIG8zMltwb3NqXSA9IGQzMltwb3NqXSBeIGIzMltqXTtcbiAgICAgIH1cbiAgICAgIHBvcyArPSBCTE9DS19MRU47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCB0YWtlOyBqKyspIHtcbiAgICAgIHBvc2ogPSBwb3MgKyBqO1xuICAgICAgb3V0cHV0W3Bvc2pdID0gZGF0YVtwb3NqXSBeIGJsb2NrW2pdO1xuICAgIH1cbiAgICBwb3MgKz0gdGFrZTtcbiAgfVxufVxuXG4vKiogQ3JlYXRlcyBBUlgtbGlrZSAoQ2hhQ2hhLCBTYWxzYSkgY2lwaGVyIHN0cmVhbSBmcm9tIGNvcmUgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2lwaGVyKGNvcmU6IENpcGhlckNvcmVGbiwgb3B0czogQ2lwaGVyT3B0cyk6IFhvclN0cmVhbSB7XG4gIGNvbnN0IHsgYWxsb3dTaG9ydEtleXMsIGV4dGVuZE5vbmNlRm4sIGNvdW50ZXJMZW5ndGgsIGNvdW50ZXJSaWdodCwgcm91bmRzIH0gPSBjaGVja09wdHMoXG4gICAgeyBhbGxvd1Nob3J0S2V5czogZmFsc2UsIGNvdW50ZXJMZW5ndGg6IDgsIGNvdW50ZXJSaWdodDogZmFsc2UsIHJvdW5kczogMjAgfSxcbiAgICBvcHRzXG4gICk7XG4gIGlmICh0eXBlb2YgY29yZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdjb3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICBhbnVtYmVyKGNvdW50ZXJMZW5ndGgpO1xuICBhbnVtYmVyKHJvdW5kcyk7XG4gIGFib29sKGNvdW50ZXJSaWdodCk7XG4gIGFib29sKGFsbG93U2hvcnRLZXlzKTtcbiAgcmV0dXJuIChcbiAgICBrZXk6IFVpbnQ4QXJyYXksXG4gICAgbm9uY2U6IFVpbnQ4QXJyYXksXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBvdXRwdXQ/OiBVaW50OEFycmF5LFxuICAgIGNvdW50ZXIgPSAwXG4gICk6IFVpbnQ4QXJyYXkgPT4ge1xuICAgIGFieXRlcyhrZXksIHVuZGVmaW5lZCwgJ2tleScpO1xuICAgIGFieXRlcyhub25jZSwgdW5kZWZpbmVkLCAnbm9uY2UnKTtcbiAgICBhYnl0ZXMoZGF0YSwgdW5kZWZpbmVkLCAnZGF0YScpO1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBhYnl0ZXMob3V0cHV0LCB1bmRlZmluZWQsICdvdXRwdXQnKTtcbiAgICBhbnVtYmVyKGNvdW50ZXIpO1xuICAgIGlmIChjb3VudGVyIDwgMCB8fCBjb3VudGVyID49IE1BWF9DT1VOVEVSKSB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogY291bnRlciBvdmVyZmxvdycpO1xuICAgIGlmIChvdXRwdXQubGVuZ3RoIDwgbGVuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG91dHB1dCAoJHtvdXRwdXQubGVuZ3RofSkgaXMgc2hvcnRlciB0aGFuIGRhdGEgKCR7bGVufSlgKTtcbiAgICBjb25zdCB0b0NsZWFuID0gW107XG5cbiAgICAvLyBLZXkgJiBzaWdtYVxuICAgIC8vIGtleT0xNiAtPiBzaWdtYTE2LCBrPWtleXxrZXlcbiAgICAvLyBrZXk9MzIgLT4gc2lnbWEzMiwgaz1rZXlcbiAgICBsZXQgbCA9IGtleS5sZW5ndGg7XG4gICAgbGV0IGs6IFVpbnQ4QXJyYXk7XG4gICAgbGV0IHNpZ21hOiBVaW50MzJBcnJheTtcbiAgICBpZiAobCA9PT0gMzIpIHtcbiAgICAgIHRvQ2xlYW4ucHVzaCgoayA9IGNvcHlCeXRlcyhrZXkpKSk7XG4gICAgICBzaWdtYSA9IHNpZ21hMzJfMzI7XG4gICAgfSBlbHNlIGlmIChsID09PSAxNiAmJiBhbGxvd1Nob3J0S2V5cykge1xuICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgIGsuc2V0KGtleSk7XG4gICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWJ5dGVzKGtleSwgMzIsICdhcngga2V5Jyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2V5IHNpemUnKTtcbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgXCJhcngga2V5XCIgZXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggMzIsIGdvdCBsZW5ndGg9JHtsfWApO1xuICAgIH1cblxuICAgIC8vIE5vbmNlXG4gICAgLy8gc2Fsc2EyMDogICAgICA4ICAgKDgtYnl0ZSBjb3VudGVyKVxuICAgIC8vIGNoYWNoYTIwb3JpZzogOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAvLyBjaGFjaGEyMDogICAgIDEyICAoNC1ieXRlIGNvdW50ZXIpXG4gICAgLy8geHNhbHNhMjA6ICAgICAyNCAgKDE2IC0+IGhzYWxzYSwgIDggLT4gb2xkIG5vbmNlKVxuICAgIC8vIHhjaGFjaGEyMDogICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcbiAgICAvLyBBbGlnbiBub25jZSB0byA0IGJ5dGVzXG4gICAgaWYgKCFpc0FsaWduZWQzMihub25jZSkpIHRvQ2xlYW4ucHVzaCgobm9uY2UgPSBjb3B5Qnl0ZXMobm9uY2UpKSk7XG5cbiAgICBjb25zdCBrMzIgPSB1MzIoayk7XG4gICAgLy8gaHNhbHNhICYgaGNoYWNoYTogaGFuZGxlIGV4dGVuZGVkIG5vbmNlXG4gICAgaWYgKGV4dGVuZE5vbmNlRm4pIHtcbiAgICAgIGlmIChub25jZS5sZW5ndGggIT09IDI0KSB0aHJvdyBuZXcgRXJyb3IoYGFyeDogZXh0ZW5kZWQgbm9uY2UgbXVzdCBiZSAyNCBieXRlc2ApO1xuICAgICAgZXh0ZW5kTm9uY2VGbihzaWdtYSwgazMyLCB1MzIobm9uY2Uuc3ViYXJyYXkoMCwgMTYpKSwgazMyKTtcbiAgICAgIG5vbmNlID0gbm9uY2Uuc3ViYXJyYXkoMTYpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBub25jZSBjb3VudGVyXG4gICAgY29uc3Qgbm9uY2VOY0xlbiA9IDE2IC0gY291bnRlckxlbmd0aDtcbiAgICBpZiAobm9uY2VOY0xlbiAhPT0gbm9uY2UubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG5vbmNlIG11c3QgYmUgJHtub25jZU5jTGVufSBvciAxNiBieXRlc2ApO1xuXG4gICAgLy8gUGFkIGNvdW50ZXIgd2hlbiBub25jZSBpcyA2NCBiaXRcbiAgICBpZiAobm9uY2VOY0xlbiAhPT0gMTIpIHtcbiAgICAgIGNvbnN0IG5jID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuICAgICAgbmMuc2V0KG5vbmNlLCBjb3VudGVyUmlnaHQgPyAwIDogMTIgLSBub25jZS5sZW5ndGgpO1xuICAgICAgbm9uY2UgPSBuYztcbiAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG4gICAgfVxuICAgIGNvbnN0IG4zMiA9IHUzMihub25jZSk7XG4gICAgcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrMzIsIG4zMiwgZGF0YSwgb3V0cHV0LCBjb3VudGVyLCByb3VuZHMpO1xuICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbi8qKiBJbnRlcm5hbCBjbGFzcyB3aGljaCB3cmFwcyBjaGFjaGEyMCBvciBjaGFjaGE4IHRvIGNyZWF0ZSBDU1BSTkcuICovXG5leHBvcnQgY2xhc3MgX1hvclN0cmVhbVBSRyBpbXBsZW1lbnRzIFBSRyB7XG4gIHJlYWRvbmx5IGJsb2NrTGVuOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtleUxlbjogbnVtYmVyO1xuICByZWFkb25seSBub25jZUxlbjogbnVtYmVyO1xuICBwcml2YXRlIHN0YXRlOiBVaW50OEFycmF5O1xuICBwcml2YXRlIGJ1ZjogVWludDhBcnJheTtcbiAgcHJpdmF0ZSBrZXk6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgbm9uY2U6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgcG9zOiBudW1iZXI7XG4gIHByaXZhdGUgY3RyOiBudW1iZXI7XG4gIHByaXZhdGUgY2lwaGVyOiBYb3JTdHJlYW07XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNpcGhlcjogWG9yU3RyZWFtLFxuICAgIGJsb2NrTGVuOiBudW1iZXIsXG4gICAga2V5TGVuOiBudW1iZXIsXG4gICAgbm9uY2VMZW46IG51bWJlcixcbiAgICBzZWVkOiBVaW50OEFycmF5XG4gICkge1xuICAgIHRoaXMuY2lwaGVyID0gY2lwaGVyO1xuICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICB0aGlzLmtleUxlbiA9IGtleUxlbjtcbiAgICB0aGlzLm5vbmNlTGVuID0gbm9uY2VMZW47XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMua2V5TGVuICsgdGhpcy5ub25jZUxlbik7XG4gICAgdGhpcy5yZXNlZWQoc2VlZCk7XG4gICAgdGhpcy5jdHIgPSAwO1xuICAgIHRoaXMucG9zID0gdGhpcy5ibG9ja0xlbjtcbiAgICB0aGlzLmJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW4pO1xuICAgIHRoaXMua2V5ID0gdGhpcy5zdGF0ZS5zdWJhcnJheSgwLCB0aGlzLmtleUxlbik7XG4gICAgdGhpcy5ub25jZSA9IHRoaXMuc3RhdGUuc3ViYXJyYXkodGhpcy5rZXlMZW4pO1xuICB9XG4gIHByaXZhdGUgcmVzZWVkKHNlZWQ6IFVpbnQ4QXJyYXkpIHtcbiAgICBhYnl0ZXMoc2VlZCk7XG4gICAgaWYgKCFzZWVkIHx8IHNlZWQubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2VudHJvcHkgcmVxdWlyZWQnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHRoaXMuc3RhdGVbaSAlIHRoaXMuc3RhdGUubGVuZ3RoXSBePSBzZWVkW2ldO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgICB0aGlzLnBvcyA9IHRoaXMuYmxvY2tMZW47XG4gIH1cbiAgYWRkRW50cm9weShzZWVkOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgdGhpcy5zdGF0ZS5zZXQodGhpcy5yYW5kb21CeXRlcyh0aGlzLnN0YXRlLmxlbmd0aCkpO1xuICAgIHRoaXMucmVzZWVkKHNlZWQpO1xuICB9XG4gIHJhbmRvbUJ5dGVzKGxlbjogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgYW51bWJlcihsZW4pO1xuICAgIGlmIChsZW4gPT09IDApIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGxldCBvdXRQb3MgPSAwO1xuICAgIC8vIExlZnRvdmVyc1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuYmxvY2tMZW4pIHtcbiAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihsZW4sIHRoaXMuYmxvY2tMZW4gLSB0aGlzLnBvcyk7XG4gICAgICBvdXQuc2V0KHRoaXMuYnVmLnN1YmFycmF5KHRoaXMucG9zLCB0aGlzLnBvcyArIHRha2UpLCAwKTtcbiAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICBvdXRQb3MgKz0gdGFrZTtcbiAgICAgIGlmIChvdXRQb3MgPT09IGxlbikgcmV0dXJuIG91dDsgLy8gZmFzdCBwYXRoXG4gICAgfVxuICAgIC8vIEZ1bGwgYmxvY2tzIGRpcmVjdGx5IHRvIG91dFxuICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoKGxlbiAtIG91dFBvcykgLyB0aGlzLmJsb2NrTGVuKTtcbiAgICBpZiAoYmxvY2tzID4gMCkge1xuICAgICAgY29uc3QgYmxvY2tCeXRlcyA9IGJsb2NrcyAqIHRoaXMuYmxvY2tMZW47XG4gICAgICBjb25zdCBiID0gb3V0LnN1YmFycmF5KG91dFBvcywgb3V0UG9zICsgYmxvY2tCeXRlcyk7XG4gICAgICB0aGlzLmNpcGhlcih0aGlzLmtleSwgdGhpcy5ub25jZSwgYiwgYiwgdGhpcy5jdHIpO1xuICAgICAgdGhpcy5jdHIgKz0gYmxvY2tzO1xuICAgICAgb3V0UG9zICs9IGJsb2NrQnl0ZXM7XG4gICAgfVxuICAgIC8vIFNhdmUgbGVmdG92ZXJzXG4gICAgY29uc3QgbGVmdCA9IGxlbiAtIG91dFBvcztcbiAgICBpZiAobGVmdCA+IDApIHtcbiAgICAgIHRoaXMuYnVmLmZpbGwoMCk7XG4gICAgICAvLyBOT1RFOiBjaXBoZXIgd2lsbCBoYW5kbGUgb3ZlcmZsb3dcbiAgICAgIHRoaXMuY2lwaGVyKHRoaXMua2V5LCB0aGlzLm5vbmNlLCB0aGlzLmJ1ZiwgdGhpcy5idWYsIHRoaXMuY3RyKyspO1xuICAgICAgb3V0LnNldCh0aGlzLmJ1Zi5zdWJhcnJheSgwLCBsZWZ0KSwgb3V0UG9zKTtcbiAgICAgIHRoaXMucG9zID0gbGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBjbG9uZSgpOiBfWG9yU3RyZWFtUFJHIHtcbiAgICByZXR1cm4gbmV3IF9Yb3JTdHJlYW1QUkcoXG4gICAgICB0aGlzLmNpcGhlcixcbiAgICAgIHRoaXMuYmxvY2tMZW4sXG4gICAgICB0aGlzLmtleUxlbixcbiAgICAgIHRoaXMubm9uY2VMZW4sXG4gICAgICB0aGlzLnJhbmRvbUJ5dGVzKHRoaXMuc3RhdGUubGVuZ3RoKVxuICAgICk7XG4gIH1cbiAgY2xlYW4oKTogdm9pZCB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgICB0aGlzLmJ1Zi5maWxsKDApO1xuICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBYb3JQUkcgPSAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IF9Yb3JTdHJlYW1QUkc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQUkcgPSAoXG4gIGNpcGhlcjogWG9yU3RyZWFtLFxuICBibG9ja0xlbjogbnVtYmVyLFxuICBrZXlMZW46IG51bWJlcixcbiAgbm9uY2VMZW46IG51bWJlclxuKTogWG9yUFJHID0+IHtcbiAgcmV0dXJuIChzZWVkOiBVaW50OEFycmF5ID0gcmFuZG9tQnl0ZXMoMzIpKTogX1hvclN0cmVhbVBSRyA9PlxuICAgIG5ldyBfWG9yU3RyZWFtUFJHKGNpcGhlciwgYmxvY2tMZW4sIGtleUxlbiwgbm9uY2VMZW4sIHNlZWQpO1xufTtcbiIsICIvKipcbiAqIFBvbHkxMzA1IChbUERGXShodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGYpLFxuICogW3dpa2ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvbHkxMzA1KSlcbiAqIGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUgc3VpdGFibGUgZm9yXG4gKiBhIHdpZGUgdmFyaWV0eSBvZiBhcHBsaWNhdGlvbnMuIEl0IHdhcyBzdGFuZGFyZGl6ZWQgaW5cbiAqIFtSRkMgODQzOV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzg0MzkpIGFuZCBpcyBub3cgdXNlZCBpbiBUTFMgMS4zLlxuICpcbiAqIFBvbHlub21pYWwgTUFDcyBhcmUgbm90IHBlcmZlY3QgZm9yIGV2ZXJ5IHNpdHVhdGlvbjpcbiAqIHRoZXkgbGFjayBSYW5kb20gS2V5IFJvYnVzdG5lc3M6IHRoZSBNQUMgY2FuIGJlIGZvcmdlZCwgYW5kIGNhbid0IGJlIHVzZWQgaW4gUEFLRSBzY2hlbWVzLlxuICogU2VlIFtpbnZpc2libGUgc2FsYW1hbmRlcnMgYXR0YWNrXShodHRwczovL2tleW1hdGVyaWFsLm5ldC8yMDIwLzA5LzA3L2ludmlzaWJsZS1zYWxhbWFuZGVycy1pbi1hZXMtZ2NtLXNpdi8pLlxuICogVG8gY29tYmF0IGludmlzaWJsZSBzYWxhbWFuZGVycywgYGhhc2goa2V5KWAgY2FuIGJlIGluY2x1ZGVkIGluIGNpcGhlcnRleHQsXG4gKiBob3dldmVyLCB0aGlzIHdvdWxkIHZpb2xhdGUgY2lwaGVydGV4dCBpbmRpc3Rpbmd1aXNoYWJpbGl0eTpcbiAqIGFuIGF0dGFja2VyIHdvdWxkIGtub3cgd2hpY2gga2V5IHdhcyB1c2VkIC0gc28gYEhLREYoa2V5LCBpKWBcbiAqIGNvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiBDaGVjayBvdXQgW29yaWdpbmFsIHdlYnNpdGVdKGh0dHBzOi8vY3IueXAudG8vbWFjLmh0bWwpLlxuICogQmFzZWQgb24gUHVibGljIERvbWFpbiBbcG9seTEzMDUtZG9ubmFdKGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYSkuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHtcbiAgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBieXRlc1RvSGV4LFxuICBjbGVhbiwgY29uY2F0Qnl0ZXMsIGNvcHlCeXRlcywgaGV4VG9OdW1iZXIsIG51bWJlclRvQnl0ZXNCRSxcbiAgdHlwZSBJSGFzaDJcbn0gZnJvbSAnLi91dGlscy50cyc7XG5cbmZ1bmN0aW9uIHU4dG8xNihhOiBVaW50OEFycmF5LCBpOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhW2krK10gJiAweGZmKSB8ICgoYVtpKytdICYgMHhmZikgPDwgOCk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5cbi8qKiBTbWFsbCB2ZXJzaW9uIG9mIGBwb2x5MTMwNWAgd2l0aG91dCBsb29wIHVucm9sbGluZy4gVW51c2VkLCBwcm92aWRlZCBmb3IgYXVkaXRhYmlsaXR5LiAqL1xuZnVuY3Rpb24gcG9seTEzMDVfc21hbGwobXNnOiBVaW50OEFycmF5LCBrZXk6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgYWJ5dGVzKG1zZyk7XG4gIGFieXRlcyhrZXksIDMyLCAna2V5Jyk7XG4gIGNvbnN0IFBPV18yXzEzMF81ID0gQmlnSW50KDIpICoqIEJpZ0ludCgxMzApIC0gQmlnSW50KDUpOyAvLyAyXjEzMC01XG4gIGNvbnN0IFBPV18yXzEyOF8xID0gQmlnSW50KDIpICoqIEJpZ0ludCgxMjgpIC0gQmlnSW50KDEpOyAvLyAyXjEyOC0xXG4gIGNvbnN0IENMQU1QX1IgPSBCaWdJbnQoJzB4MGZmZmZmZmMwZmZmZmZmYzBmZmZmZmZjMGZmZmZmZmYnKTtcbiAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJMRShrZXkuc3ViYXJyYXkoMCwgMTYpKSAmIENMQU1QX1I7XG4gIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyTEUoa2V5LnN1YmFycmF5KDE2KSk7XG4gIC8vIFByb2Nlc3MgYnkgMTYgYnl0ZSBjaHVua3NcbiAgbGV0IGFjYyA9IEJpZ0ludCgwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3QgbSA9IG1zZy5zdWJhcnJheShpLCBpICsgMTYpO1xuICAgIGNvbnN0IG4gPSBieXRlc1RvTnVtYmVyTEUobSkgfCAoQmlnSW50KDEpIDw8IEJpZ0ludCg4ICogbS5sZW5ndGgpKTtcbiAgICBhY2MgPSAoKGFjYyArIG4pICogcikgJSBQT1dfMl8xMzBfNTtcbiAgfVxuICBjb25zdCByZXMgPSAoYWNjICsgcykgJiBQT1dfMl8xMjhfMTtcbiAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShyZXMsIDE2KS5yZXZlcnNlKCk7IC8vIExFXG59XG5cbi8vIENhbiBiZSB1c2VkIHRvIHJlcGxhY2UgYGNvbXB1dGVUYWdgIGluIGNoYWNoYS50cy4gVW51c2VkLCBwcm92aWRlZCBmb3IgYXVkaXRhYmlsaXR5LlxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gcG9seTEzMDVfY29tcHV0ZVRhZ19zbWFsbChcbiAgYXV0aEtleTogVWludDhBcnJheSxcbiAgbGVuZ3RoczogVWludDhBcnJheSxcbiAgY2lwaGVydGV4dDogVWludDhBcnJheSxcbiAgQUFEPzogVWludDhBcnJheVxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCB1cGRhdGVQYWRkZWQyID0gKG1zZzogVWludDhBcnJheSkgPT4ge1xuICAgIHJlcy5wdXNoKG1zZyk7XG4gICAgY29uc3QgbGVmdG92ZXIgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnRvdmVyKSByZXMucHVzaChuZXcgVWludDhBcnJheSgxNikuc2xpY2UobGVmdG92ZXIpKTtcbiAgfTtcbiAgaWYgKEFBRCkgdXBkYXRlUGFkZGVkMihBQUQpO1xuICB1cGRhdGVQYWRkZWQyKGNpcGhlcnRleHQpO1xuICByZXMucHVzaChsZW5ndGhzKTtcbiAgcmV0dXJuIHBvbHkxMzA1X3NtYWxsKGNvbmNhdEJ5dGVzKC4uLnJlcyksIGF1dGhLZXkpO1xufVxuXG4vKiogUG9seTEzMDUgY2xhc3MuIFByZWZlciBwb2x5MTMwNSgpIGZ1bmN0aW9uIGluc3RlYWQuICovXG5leHBvcnQgY2xhc3MgUG9seTEzMDUgaW1wbGVtZW50cyBJSGFzaDIge1xuICByZWFkb25seSBibG9ja0xlbiA9IDE2O1xuICByZWFkb25seSBvdXRwdXRMZW4gPSAxNjtcbiAgcHJpdmF0ZSBidWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHByaXZhdGUgciA9IG5ldyBVaW50MTZBcnJheSgxMCk7IC8vIEFsbG9jYXRpbmcgMSBhcnJheSB3aXRoIC5zdWJhcnJheSgpIGhlcmUgaXMgc2xvd2VyIHRoYW4gM1xuICBwcml2YXRlIGggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICBwcml2YXRlIHBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgcHJpdmF0ZSBwb3MgPSAwO1xuICBwcm90ZWN0ZWQgZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBDYW4gYmUgc3BlZWQtdXAgdXNpbmcgQmlnVWludDY0QXJyYXksIGF0IHRoZSBjb3N0IG9mIGNvbXBsZXhpdHlcbiAgY29uc3RydWN0b3Ioa2V5OiBVaW50OEFycmF5KSB7XG4gICAga2V5ID0gY29weUJ5dGVzKGFieXRlcyhrZXksIDMyLCAna2V5JykpO1xuICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG4gICAgY29uc3QgdDEgPSB1OHRvMTYoa2V5LCAyKTtcbiAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG4gICAgY29uc3QgdDQgPSB1OHRvMTYoa2V5LCA4KTtcbiAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcbiAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcbiAgICBjb25zdCB0NyA9IHU4dG8xNihrZXksIDE0KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYS9ibG9iL2U2YWQ2ZTA5MWQzMGQ3ZjRlYzJkNGY5NzhiZTFmY2ZjYmNlNzI3ODEvcG9seTEzMDUtZG9ubmEtMTYuaCNMNDdcbiAgICB0aGlzLnJbMF0gPSB0MCAmIDB4MWZmZjtcbiAgICB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmO1xuICAgIHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmMDM7XG4gICAgdGhpcy5yWzNdID0gKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmO1xuICAgIHRoaXMucls0XSA9ICgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gICAgdGhpcy5yWzVdID0gKHQ0ID4+PiAxKSAmIDB4MWZmZTtcbiAgICB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmO1xuICAgIHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmODE7XG4gICAgdGhpcy5yWzhdID0gKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmO1xuICAgIHRoaXMucls5XSA9ICh0NyA+Pj4gNSkgJiAweDAwN2Y7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHRoaXMucGFkW2ldID0gdTh0bzE2KGtleSwgMTYgKyAyICogaSk7XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3MoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIsIGlzTGFzdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcbiAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG4gICAgY29uc3QgcjAgPSByWzBdO1xuICAgIGNvbnN0IHIxID0gclsxXTtcbiAgICBjb25zdCByMiA9IHJbMl07XG4gICAgY29uc3QgcjMgPSByWzNdO1xuICAgIGNvbnN0IHI0ID0gcls0XTtcbiAgICBjb25zdCByNSA9IHJbNV07XG4gICAgY29uc3QgcjYgPSByWzZdO1xuICAgIGNvbnN0IHI3ID0gcls3XTtcbiAgICBjb25zdCByOCA9IHJbOF07XG4gICAgY29uc3QgcjkgPSByWzldO1xuXG4gICAgY29uc3QgdDAgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMCk7XG4gICAgY29uc3QgdDEgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMik7XG4gICAgY29uc3QgdDIgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgY29uc3QgdDMgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgY29uc3QgdDQgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgOCk7XG4gICAgY29uc3QgdDUgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTApO1xuICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEyKTtcbiAgICBjb25zdCB0NyA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxNCk7XG5cbiAgICBsZXQgaDAgPSBoWzBdICsgKHQwICYgMHgxZmZmKTtcbiAgICBsZXQgaDEgPSBoWzFdICsgKCgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmYpO1xuICAgIGxldCBoMiA9IGhbMl0gKyAoKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWZmZik7XG4gICAgbGV0IGgzID0gaFszXSArICgoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmYpO1xuICAgIGxldCBoNCA9IGhbNF0gKyAoKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZik7XG4gICAgbGV0IGg1ID0gaFs1XSArICgodDQgPj4+IDEpICYgMHgxZmZmKTtcbiAgICBsZXQgaDYgPSBoWzZdICsgKCgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmYpO1xuICAgIGxldCBoNyA9IGhbN10gKyAoKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWZmZik7XG4gICAgbGV0IGg4ID0gaFs4XSArICgoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmYpO1xuICAgIGxldCBoOSA9IGhbOV0gKyAoKHQ3ID4+PiA1KSB8IGhpYml0KTtcblxuICAgIGxldCBjID0gMDtcblxuICAgIGxldCBkMCA9IGMgKyBoMCAqIHIwICsgaDEgKiAoNSAqIHI5KSArIGgyICogKDUgKiByOCkgKyBoMyAqICg1ICogcjcpICsgaDQgKiAoNSAqIHI2KTtcbiAgICBjID0gZDAgPj4+IDEzO1xuICAgIGQwICY9IDB4MWZmZjtcbiAgICBkMCArPSBoNSAqICg1ICogcjUpICsgaDYgKiAoNSAqIHI0KSArIGg3ICogKDUgKiByMykgKyBoOCAqICg1ICogcjIpICsgaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IGQwID4+PiAxMztcbiAgICBkMCAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDEgPSBjICsgaDAgKiByMSArIGgxICogcjAgKyBoMiAqICg1ICogcjkpICsgaDMgKiAoNSAqIHI4KSArIGg0ICogKDUgKiByNyk7XG4gICAgYyA9IGQxID4+PiAxMztcbiAgICBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KSArIGg2ICogKDUgKiByNSkgKyBoNyAqICg1ICogcjQpICsgaDggKiAoNSAqIHIzKSArIGg5ICogKDUgKiByMik7XG4gICAgYyArPSBkMSA+Pj4gMTM7XG4gICAgZDEgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuICAgIGMgPSBkMiA+Pj4gMTM7XG4gICAgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gZDIgPj4+IDEzO1xuICAgIGQyICY9IDB4MWZmZjtcblxuICAgIGxldCBkMyA9IGMgKyBoMCAqIHIzICsgaDEgKiByMiArIGgyICogcjEgKyBoMyAqIHIwICsgaDQgKiAoNSAqIHI5KTtcbiAgICBjID0gZDMgPj4+IDEzO1xuICAgIGQzICY9IDB4MWZmZjtcbiAgICBkMyArPSBoNSAqICg1ICogcjgpICsgaDYgKiAoNSAqIHI3KSArIGg3ICogKDUgKiByNikgKyBoOCAqICg1ICogcjUpICsgaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IGQzID4+PiAxMztcbiAgICBkMyAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDQgPSBjICsgaDAgKiByNCArIGgxICogcjMgKyBoMiAqIHIyICsgaDMgKiByMSArIGg0ICogcjA7XG4gICAgYyA9IGQ0ID4+PiAxMztcbiAgICBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KSArIGg2ICogKDUgKiByOCkgKyBoNyAqICg1ICogcjcpICsgaDggKiAoNSAqIHI2KSArIGg5ICogKDUgKiByNSk7XG4gICAgYyArPSBkNCA+Pj4gMTM7XG4gICAgZDQgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuICAgIGMgPSBkNSA+Pj4gMTM7XG4gICAgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gZDUgPj4+IDEzO1xuICAgIGQ1ICY9IDB4MWZmZjtcblxuICAgIGxldCBkNiA9IGMgKyBoMCAqIHI2ICsgaDEgKiByNSArIGgyICogcjQgKyBoMyAqIHIzICsgaDQgKiByMjtcbiAgICBjID0gZDYgPj4+IDEzO1xuICAgIGQ2ICY9IDB4MWZmZjtcbiAgICBkNiArPSBoNSAqIHIxICsgaDYgKiByMCArIGg3ICogKDUgKiByOSkgKyBoOCAqICg1ICogcjgpICsgaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IGQ2ID4+PiAxMztcbiAgICBkNiAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDcgPSBjICsgaDAgKiByNyArIGgxICogcjYgKyBoMiAqIHI1ICsgaDMgKiByNCArIGg0ICogcjM7XG4gICAgYyA9IGQ3ID4+PiAxMztcbiAgICBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMiArIGg2ICogcjEgKyBoNyAqIHIwICsgaDggKiAoNSAqIHI5KSArIGg5ICogKDUgKiByOCk7XG4gICAgYyArPSBkNyA+Pj4gMTM7XG4gICAgZDcgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuICAgIGMgPSBkOCA+Pj4gMTM7XG4gICAgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gZDggPj4+IDEzO1xuICAgIGQ4ICY9IDB4MWZmZjtcblxuICAgIGxldCBkOSA9IGMgKyBoMCAqIHI5ICsgaDEgKiByOCArIGgyICogcjcgKyBoMyAqIHI2ICsgaDQgKiByNTtcbiAgICBjID0gZDkgPj4+IDEzO1xuICAgIGQ5ICY9IDB4MWZmZjtcbiAgICBkOSArPSBoNSAqIHI0ICsgaDYgKiByMyArIGg3ICogcjIgKyBoOCAqIHIxICsgaDkgKiByMDtcbiAgICBjICs9IGQ5ID4+PiAxMztcbiAgICBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKChjIDw8IDIpICsgYykgfCAwO1xuICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgZDAgPSBjICYgMHgxZmZmO1xuICAgIGMgPSBjID4+PiAxMztcbiAgICBkMSArPSBjO1xuXG4gICAgaFswXSA9IGQwO1xuICAgIGhbMV0gPSBkMTtcbiAgICBoWzJdID0gZDI7XG4gICAgaFszXSA9IGQzO1xuICAgIGhbNF0gPSBkNDtcbiAgICBoWzVdID0gZDU7XG4gICAgaFs2XSA9IGQ2O1xuICAgIGhbN10gPSBkNztcbiAgICBoWzhdID0gZDg7XG4gICAgaFs5XSA9IGQ5O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5hbGl6ZSgpIHtcbiAgICBjb25zdCB7IGgsIHBhZCB9ID0gdGhpcztcbiAgICBjb25zdCBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgICBsZXQgYyA9IGhbMV0gPj4+IDEzO1xuICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgICAgaFtpXSArPSBjO1xuICAgICAgYyA9IGhbaV0gPj4+IDEzO1xuICAgICAgaFtpXSAmPSAweDFmZmY7XG4gICAgfVxuICAgIGhbMF0gKz0gYyAqIDU7XG4gICAgYyA9IGhbMF0gPj4+IDEzO1xuICAgIGhbMF0gJj0gMHgxZmZmO1xuICAgIGhbMV0gKz0gYztcbiAgICBjID0gaFsxXSA+Pj4gMTM7XG4gICAgaFsxXSAmPSAweDFmZmY7XG4gICAgaFsyXSArPSBjO1xuXG4gICAgZ1swXSA9IGhbMF0gKyA1O1xuICAgIGMgPSBnWzBdID4+PiAxMztcbiAgICBnWzBdICY9IDB4MWZmZjtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGdbaV0gPSBoW2ldICsgYztcbiAgICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICAgIGdbaV0gJj0gMHgxZmZmO1xuICAgIH1cbiAgICBnWzldIC09IDEgPDwgMTM7XG5cbiAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykgZ1tpXSAmPSBtYXNrO1xuICAgIG1hc2sgPSB+bWFzaztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcbiAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuICAgIGhbMV0gPSAoKGhbMV0gPj4+IDMpIHwgKGhbMl0gPDwgMTApKSAmIDB4ZmZmZjtcbiAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcbiAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcbiAgICBoWzRdID0gKChoWzRdID4+PiAxMikgfCAoaFs1XSA8PCAxKSB8IChoWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuICAgIGhbN10gPSAoKGhbOF0gPj4+IDgpIHwgKGhbOV0gPDwgNSkpICYgMHhmZmZmO1xuXG4gICAgbGV0IGYgPSBoWzBdICsgcGFkWzBdO1xuICAgIGhbMF0gPSBmICYgMHhmZmZmO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICAgIGhbaV0gPSBmICYgMHhmZmZmO1xuICAgIH1cbiAgICBjbGVhbihnKTtcbiAgfVxuICB1cGRhdGUoZGF0YTogVWludDhBcnJheSk6IHRoaXMge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIGRhdGEgPSBjb3B5Qnl0ZXMoZGF0YSk7XG4gICAgY29uc3QgeyBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyApIHtcbiAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dFxuICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbikgdGhpcy5wcm9jZXNzKGRhdGEsIHBvcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICBwb3MgKz0gdGFrZTtcbiAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgY2xlYW4odGhpcy5oLCB0aGlzLnIsIHRoaXMuYnVmZmVyLCB0aGlzLnBhZCk7XG4gIH1cbiAgZGlnZXN0SW50byhvdXQ6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICBjb25zdCB7IGJ1ZmZlciwgaCB9ID0gdGhpcztcbiAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgaWYgKHBvcykge1xuICAgICAgYnVmZmVyW3BvcysrXSA9IDE7XG4gICAgICBmb3IgKDsgcG9zIDwgMTY7IHBvcysrKSBidWZmZXJbcG9zXSA9IDA7XG4gICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIGxldCBvcG9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiAwO1xuICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGRpZ2VzdCgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ0hhc2ggPSBSZXR1cm5UeXBlPHR5cGVvZiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5PjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5PEggZXh0ZW5kcyBJSGFzaDI+KFxuICBoYXNoQ29uczogKGtleTogVWludDhBcnJheSkgPT4gSFxuKToge1xuICAobXNnOiBVaW50OEFycmF5LCBrZXk6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgYmxvY2tMZW46IG51bWJlcjtcbiAgY3JlYXRlKGtleTogVWludDhBcnJheSk6IEg7XG59IHtcbiAgY29uc3QgaGFzaEMgPSAobXNnOiBVaW50OEFycmF5LCBrZXk6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5ID0+XG4gICAgaGFzaENvbnMoa2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTsgLy8gdG1wIGFycmF5LCB1c2VkIGp1c3Qgb25jZSBiZWxvd1xuICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgaGFzaEMuY3JlYXRlID0gKGtleTogVWludDhBcnJheSkgPT4gaGFzaENvbnMoa2V5KTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG4vKiogUG9seTEzMDUgTUFDIGZyb20gUkZDIDg0MzkuICovXG5leHBvcnQgY29uc3QgcG9seTEzMDU6IENIYXNoID0gLyoqIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgd3JhcENvbnN0cnVjdG9yV2l0aEtleSgoa2V5KSA9PiBuZXcgUG9seTEzMDUoa2V5KSkpKCk7XG4iLCAiLyoqXG4gKiBDaGFDaGEgc3RyZWFtIGNpcGhlciwgcmVsZWFzZWRcbiAqIGluIDIwMDguIERldmVsb3BlZCBhZnRlciBTYWxzYTIwLCBDaGFDaGEgYWltcyB0byBpbmNyZWFzZSBkaWZmdXNpb24gcGVyIHJvdW5kLlxuICogSXQgd2FzIHN0YW5kYXJkaXplZCBpbiBbUkZDIDg0MzldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4NDM5KSBhbmRcbiAqIGlzIG5vdyB1c2VkIGluIFRMUyAxLjMuXG4gKlxuICogW1hDaGFDaGEyMF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSlcbiAqIGV4dGVuZGVkLW5vbmNlIHZhcmlhbnQgaXMgYWxzbyBwcm92aWRlZC4gU2ltaWxhciB0byBYU2Fsc2EsIGl0J3Mgc2FmZSB0byB1c2Ugd2l0aFxuICogcmFuZG9tbHktZ2VuZXJhdGVkIG5vbmNlcy5cbiAqXG4gKiBDaGVjayBvdXQgW1BERl0oaHR0cDovL2NyLnlwLnRvL2NoYWNoYS9jaGFjaGEtMjAwODAxMjgucGRmKSBhbmRcbiAqIFt3aWtpXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWxzYTIwKSBhbmRcbiAqIFt3ZWJzaXRlXShodHRwczovL2NyLnlwLnRvL2NoYWNoYS5odG1sKS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHR5cGUgWG9yUFJHLCBjcmVhdGVDaXBoZXIsIGNyZWF0ZVBSRywgcm90bCB9IGZyb20gJy4vX2FyeC50cyc7XG5pbXBvcnQgeyBwb2x5MTMwNSB9IGZyb20gJy4vX3BvbHkxMzA1LnRzJztcbmltcG9ydCB7XG4gIHR5cGUgQVJYQ2lwaGVyLFxuICB0eXBlIENpcGhlcldpdGhPdXRwdXQsXG4gIHR5cGUgWG9yU3RyZWFtLFxuICBhYnl0ZXMsXG4gIGNsZWFuLFxuICBlcXVhbEJ5dGVzLFxuICBnZXRPdXRwdXQsXG4gIHU2NExlbmd0aHMsXG4gIHdyYXBDaXBoZXIsXG59IGZyb20gJy4vdXRpbHMudHMnO1xuXG4vKipcbiAqIENoYUNoYSBjb3JlIGZ1bmN0aW9uLiBJdCBpcyBpbXBsZW1lbnRlZCB0d2ljZTpcbiAqIDEuIFNpbXBsZSBsb29wIChjaGFjaGFDb3JlX3NtYWxsLCBoY2hhY2hhX3NtYWxsKVxuICogMi4gVW5yb2xsZWQgbG9vcCAoY2hhY2hhQ29yZSwgaGNoYWNoYSkgLSA0eCBmYXN0ZXIsIGJ1dCBsYXJnZXIgJiBoYXJkZXIgdG8gcmVhZFxuICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGlzIHNlbGVjdGVkIGluIGBjcmVhdGVDaXBoZXJgIGJlbG93LlxuICovXG5cbi8qKiBxdWFydGVyLXJvdW5kICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIGNoYWNoYVFSKHg6IFVpbnQzMkFycmF5LCBhOiBudW1iZXIsIGI6IG51bWJlciwgYzogbnVtYmVyLCBkOiBudW1iZXIpIHtcbiAgeFthXSA9ICh4W2FdICsgeFtiXSkgfCAwOyB4W2RdID0gcm90bCh4W2RdIF4geFthXSwgMTYpO1xuICB4W2NdID0gKHhbY10gKyB4W2RdKSB8IDA7IHhbYl0gPSByb3RsKHhbYl0gXiB4W2NdLCAxMik7XG4gIHhbYV0gPSAoeFthXSArIHhbYl0pIHwgMDsgeFtkXSA9IHJvdGwoeFtkXSBeIHhbYV0sIDgpO1xuICB4W2NdID0gKHhbY10gKyB4W2RdKSB8IDA7IHhbYl0gPSByb3RsKHhbYl0gXiB4W2NdLCA3KTtcbn1cblxuLyoqIHNpbmdsZSByb3VuZCAqL1xuZnVuY3Rpb24gY2hhY2hhUm91bmQoeDogVWludDMyQXJyYXksIHJvdW5kcyA9IDIwKSB7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgcm91bmRzOyByICs9IDIpIHtcbiAgICBjaGFjaGFRUih4LCAwLCA0LCA4LCAxMik7XG4gICAgY2hhY2hhUVIoeCwgMSwgNSwgOSwgMTMpO1xuICAgIGNoYWNoYVFSKHgsIDIsIDYsIDEwLCAxNCk7XG4gICAgY2hhY2hhUVIoeCwgMywgNywgMTEsIDE1KTtcbiAgICBjaGFjaGFRUih4LCAwLCA1LCAxMCwgMTUpO1xuICAgIGNoYWNoYVFSKHgsIDEsIDYsIDExLCAxMik7XG4gICAgY2hhY2hhUVIoeCwgMiwgNywgOCwgMTMpO1xuICAgIGNoYWNoYVFSKHgsIDMsIDQsIDksIDE0KTtcbiAgfVxufVxuXG5jb25zdCBjdG1wID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgxNik7XG5cbi8qKiBTbWFsbCB2ZXJzaW9uIG9mIGNoYWNoYSB3aXRob3V0IGxvb3AgdW5yb2xsaW5nLiBVbnVzZWQsIHByb3ZpZGVkIGZvciBhdWRpdGFiaWxpdHkuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIGNoYWNoYShcbiAgczogVWludDMyQXJyYXksIGs6IFVpbnQzMkFycmF5LCBpOiBVaW50MzJBcnJheSwgb3V0OiBVaW50MzJBcnJheSxcbiAgaXNIQ2hhY2hhOiBib29sZWFuID0gdHJ1ZSwgcm91bmRzOiBudW1iZXIgPSAyMFxuKTogdm9pZCB7XG4gIC8vIENyZWF0ZSBpbml0aWFsIGFycmF5IHVzaW5nIGNvbW1vbiBwYXR0ZXJuXG4gIGNvbnN0IHkgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICBzWzBdLCBzWzFdLCBzWzJdLCBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICBrWzBdLCBrWzFdLCBrWzJdLCBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAga1s0XSwga1s1XSwga1s2XSwga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIGlbMF0sIGlbMV0sIGlbMl0sIGlbM10sIC8vIENvdW50ZXIgIENvdW50ZXIgTm9uY2UgICBOb25jZVxuICBdKTtcbiAgY29uc3QgeCA9IGN0bXA7XG4gIHguc2V0KHkpO1xuICBjaGFjaGFSb3VuZCh4LCByb3VuZHMpO1xuXG4gIC8vIGhjaGFjaGEgZXh0cmFjdHMgOCBzcGVjaWZpYyBieXRlcywgY2hhY2hhIGFkZHMgb3JpZyB0byByZXN1bHRcbiAgaWYgKGlzSENoYWNoYSkge1xuICAgIGNvbnN0IHhpbmRleGVzID0gWzAsIDEsIDIsIDMsIDEyLCAxMywgMTQsIDE1XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykgb3V0W2ldID0geFt4aW5kZXhlc1tpXV07XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSBvdXRbaV0gPSAoeVtpXSArIHhbaV0pIHwgMDtcbiAgfVxufVxuXG4vKiogSWRlbnRpY2FsIHRvIGBjaGFjaGFDb3JlYC4gVW51c2VkLiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY2hhY2hhQ29yZV9zbWFsbDogdHlwZW9mIGNoYWNoYUNvcmUgPSAocywgaywgbiwgb3V0LCBjbnQsIHJvdW5kcykgPT5cbiAgY2hhY2hhKHMsIGssIFVpbnQzMkFycmF5LmZyb20oW25bMF0sIG5bMV0sIGNudCwgMF0pLCBvdXQsIGZhbHNlLCByb3VuZHMpO1xuLyoqIElkZW50aWNhbCB0byBgaGNoYWNoYWAuIFVudXNlZC4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGhjaGFjaGFfc21hbGw6IHR5cGVvZiBoY2hhY2hhID0gY2hhY2hhO1xuXG4vKiogSWRlbnRpY2FsIHRvIGBjaGFjaGFDb3JlX3NtYWxsYC4gVW51c2VkLiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKFxuICBzOiBVaW50MzJBcnJheSwgazogVWludDMyQXJyYXksIG46IFVpbnQzMkFycmF5LCBvdXQ6IFVpbnQzMkFycmF5LCBjbnQ6IG51bWJlciwgcm91bmRzID0gMjBcbik6IHZvaWQge1xuICBsZXQgeTAwID0gc1swXSwgeTAxID0gc1sxXSwgeTAyID0gc1syXSwgeTAzID0gc1szXSwgLy8gXCJleHBhXCIgICBcIm5kIDNcIiAgXCIyLWJ5XCIgIFwidGUga1wiXG4gICAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgICB5MDggPSBrWzRdLCB5MDkgPSBrWzVdLCB5MTAgPSBrWzZdLCB5MTEgPSBrWzddLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgICB5MTIgPSBjbnQsICB5MTMgPSBuWzBdLCB5MTQgPSBuWzFdLCB5MTUgPSBuWzJdOyAgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXNcbiAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMyxcbiAgICAgIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNyxcbiAgICAgIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSxcbiAgICAgIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDAsIDE2KTtcbiAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7IHgwNCA9IHJvdGwoeDA0IF4geDA4LCAxMik7XG4gICAgeDAwID0gKHgwMCArIHgwNCkgfCAwOyB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgeDA4ID0gKHgwOCArIHgxMikgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOCwgNyk7XG5cbiAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgeDA5ID0gKHgwOSArIHgxMykgfCAwOyB4MDUgPSByb3RsKHgwNSBeIHgwOSwgMTIpO1xuICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDsgeDEzID0gcm90bCh4MTMgXiB4MDEsIDgpO1xuICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuXG4gICAgeDAyID0gKHgwMiArIHgwNikgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMiwgMTYpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7IHgxNCA9IHJvdGwoeDE0IF4geDAyLCA4KTtcbiAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDEwLCA3KTtcblxuICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDE2KTtcbiAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7IHgwNyA9IHJvdGwoeDA3IF4geDExLCAxMik7XG4gICAgeDAzID0gKHgwMyArIHgwNykgfCAwOyB4MTUgPSByb3RsKHgxNSBeIHgwMywgOClcbiAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7IHgwNyA9IHJvdGwoeDA3IF4geDExLCA3KTtcblxuICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDE2KTtcbiAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7IHgwNSA9IHJvdGwoeDA1IF4geDEwLCAxMik7XG4gICAgeDAwID0gKHgwMCArIHgwNSkgfCAwOyB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgeDEwID0gKHgxMCArIHgxNSkgfCAwOyB4MDUgPSByb3RsKHgwNSBeIHgxMCwgNyk7XG5cbiAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7IHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgeDExID0gKHgxMSArIHgxMikgfCAwOyB4MDYgPSByb3RsKHgwNiBeIHgxMSwgMTIpO1xuICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDEsIDgpO1xuICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuXG4gICAgeDAyID0gKHgwMiArIHgwNykgfCAwOyB4MTMgPSByb3RsKHgxMyBeIHgwMiwgMTYpO1xuICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDsgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAyLCA4KTtcbiAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7IHgwNyA9IHJvdGwoeDA3IF4geDA4LCA3KTtcblxuICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDsgeDE0ID0gcm90bCh4MTQgXiB4MDMsIDE2KVxuICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDsgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7IHgxNCA9IHJvdGwoeDE0IF4geDAzLCA4KTtcbiAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7IHgwNCA9IHJvdGwoeDA0IF4geDA5LCA3KTtcbiAgfVxuICAvLyBXcml0ZSBvdXRwdXRcbiAgbGV0IG9pID0gMDtcbiAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwOyBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDsgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7IG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcbiAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwOyBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDsgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7IG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcbiAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwOyBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDsgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuLyoqXG4gKiBoY2hhY2hhIGhhc2hlcyBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnIGZvciB4Y2hhY2hhMjAuXG4gKiBJZGVudGljYWwgdG8gYGhjaGFjaGFfc21hbGxgLlxuICogTmVlZCB0byBmaW5kIGEgd2F5IHRvIG1lcmdlIGl0IHdpdGggYGNoYWNoYUNvcmVgIHdpdGhvdXQgMjUlIHBlcmZvcm1hbmNlIGhpdC5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgZnVuY3Rpb24gaGNoYWNoYShcbiAgczogVWludDMyQXJyYXksIGs6IFVpbnQzMkFycmF5LCBpOiBVaW50MzJBcnJheSwgb3V0OiBVaW50MzJBcnJheVxuKTogdm9pZCB7XG4gIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLFxuICAgICAgeDA0ID0ga1swXSwgeDA1ID0ga1sxXSwgeDA2ID0ga1syXSwgeDA3ID0ga1szXSxcbiAgICAgIHgwOCA9IGtbNF0sIHgwOSA9IGtbNV0sIHgxMCA9IGtbNl0sIHgxMSA9IGtbN10sXG4gICAgICB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICBmb3IgKGxldCByID0gMDsgciA8IDIwOyByICs9IDIpIHtcbiAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7IHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgeDA4ID0gKHgwOCArIHgxMikgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOCwgMTIpO1xuICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDAsIDgpO1xuICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDsgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuXG4gICAgeDAxID0gKHgwMSArIHgwNSkgfCAwOyB4MTMgPSByb3RsKHgxMyBeIHgwMSwgMTYpO1xuICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAxLCA4KTtcbiAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7IHgwNSA9IHJvdGwoeDA1IF4geDA5LCA3KTtcblxuICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDsgeDE0ID0gcm90bCh4MTQgXiB4MDIsIDE2KTtcbiAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDEwLCAxMik7XG4gICAgeDAyID0gKHgwMiArIHgwNikgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgeDEwID0gKHgxMCArIHgxNCkgfCAwOyB4MDYgPSByb3RsKHgwNiBeIHgxMCwgNyk7XG5cbiAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgeDExID0gKHgxMSArIHgxNSkgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgxMSwgMTIpO1xuICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDgpXG4gICAgeDExID0gKHgxMSArIHgxNSkgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgxMSwgNyk7XG5cbiAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgeDEwID0gKHgxMCArIHgxNSkgfCAwOyB4MDUgPSByb3RsKHgwNSBeIHgxMCwgMTIpO1xuICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDgpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuXG4gICAgeDAxID0gKHgwMSArIHgwNikgfCAwOyB4MTIgPSByb3RsKHgxMiBeIHgwMSwgMTYpO1xuICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7IHgxMiA9IHJvdGwoeDEyIF4geDAxLCA4KTtcbiAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDExLCA3KTtcblxuICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDsgeDEzID0gcm90bCh4MTMgXiB4MDIsIDE2KTtcbiAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7IHgwNyA9IHJvdGwoeDA3IF4geDA4LCAxMik7XG4gICAgeDAyID0gKHgwMiArIHgwNykgfCAwOyB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgeDA4ID0gKHgwOCArIHgxMykgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgwOCwgNyk7XG5cbiAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7IHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNilcbiAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7IHgwNCA9IHJvdGwoeDA0IF4geDA5LCAxMik7XG4gICAgeDAzID0gKHgwMyArIHgwNCkgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOSwgNyk7XG4gIH1cbiAgbGV0IG9pID0gMDtcbiAgb3V0W29pKytdID0geDAwOyBvdXRbb2krK10gPSB4MDE7XG4gIG91dFtvaSsrXSA9IHgwMjsgb3V0W29pKytdID0geDAzO1xuICBvdXRbb2krK10gPSB4MTI7IG91dFtvaSsrXSA9IHgxMztcbiAgb3V0W29pKytdID0geDE0OyBvdXRbb2krK10gPSB4MTU7XG59XG5cbi8qKiBPcmlnaW5hbCwgbm9uLVJGQyBjaGFjaGEyMCBmcm9tIERKQi4gOC1ieXRlIG5vbmNlLCA4LWJ5dGUgY291bnRlci4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGEyMG9yaWc6IFhvclN0cmVhbSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICBjb3VudGVyTGVuZ3RoOiA4LFxuICBhbGxvd1Nob3J0S2V5czogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBDaGFDaGEgc3RyZWFtIGNpcGhlci4gQ29uZm9ybXMgdG8gUkZDIDg0MzkgKElFVEYsIFRMUykuIDEyLWJ5dGUgbm9uY2UsIDQtYnl0ZSBjb3VudGVyLlxuICogV2l0aCBzbWFsbGVyIG5vbmNlLCBpdCdzIG5vdCBzYWZlIHRvIG1ha2UgaXQgcmFuZG9tIChDU1BSTkcpLCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwOiBYb3JTdHJlYW0gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgY291bnRlckxlbmd0aDogNCxcbiAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG5cbi8qKlxuICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIFdpdGggMjQtYnl0ZSBub25jZSwgaXQncyBzYWZlIHRvIG1ha2UgaXQgcmFuZG9tIChDU1BSTkcpLlxuICogU2VlIFtJUlRGIGRyYWZ0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHhjaGFjaGEyMDogWG9yU3RyZWFtID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gIGNvdW50ZXJMZW5ndGg6IDgsXG4gIGV4dGVuZE5vbmNlRm46IGhjaGFjaGEsXG4gIGFsbG93U2hvcnRLZXlzOiBmYWxzZSxcbn0pO1xuXG4vKiogUmVkdWNlZCA4LXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTg6IFhvclN0cmVhbSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICBjb3VudGVyTGVuZ3RoOiA0LFxuICByb3VuZHM6IDgsXG59KTtcblxuLyoqIFJlZHVjZWQgMTItcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMTI6IFhvclN0cmVhbSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICBjb3VudGVyTGVuZ3RoOiA0LFxuICByb3VuZHM6IDEyLFxufSk7XG5cbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoOiBSZXR1cm5UeXBlPHR5cGVvZiBwb2x5MTMwNS5jcmVhdGU+LCBtc2c6IFVpbnQ4QXJyYXkpID0+IHtcbiAgaC51cGRhdGUobXNnKTtcbiAgY29uc3QgbGVmdG92ZXIgPSBtc2cubGVuZ3RoICUgMTY7XG4gIGlmIChsZWZ0b3ZlcikgaC51cGRhdGUoWkVST1MxNi5zdWJhcnJheShsZWZ0b3ZlcikpO1xufTtcblxuY29uc3QgWkVST1MzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgzMik7XG5mdW5jdGlvbiBjb21wdXRlVGFnKFxuICBmbjogWG9yU3RyZWFtLFxuICBrZXk6IFVpbnQ4QXJyYXksXG4gIG5vbmNlOiBVaW50OEFycmF5LFxuICBjaXBoZXJ0ZXh0OiBVaW50OEFycmF5LFxuICBBQUQ/OiBVaW50OEFycmF5XG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKEFBRCAhPT0gdW5kZWZpbmVkKSBhYnl0ZXMoQUFELCB1bmRlZmluZWQsICdBQUQnKTtcbiAgY29uc3QgYXV0aEtleSA9IGZuKGtleSwgbm9uY2UsIFpFUk9TMzIpO1xuICBjb25zdCBsZW5ndGhzID0gdTY0TGVuZ3RocyhjaXBoZXJ0ZXh0Lmxlbmd0aCwgQUFEID8gQUFELmxlbmd0aCA6IDAsIHRydWUpO1xuXG4gIC8vIE1ldGhvZHMgYmVsb3cgY2FuIGJlIHJlcGxhY2VkIHdpdGhcbiAgLy8gcmV0dXJuIHBvbHkxMzA1X2NvbXB1dGVUYWdfc21hbGwoYXV0aEtleSwgbGVuZ3RocywgY2lwaGVydGV4dCwgQUFEKVxuICBjb25zdCBoID0gcG9seTEzMDUuY3JlYXRlKGF1dGhLZXkpO1xuICBpZiAoQUFEKSB1cGRhdGVQYWRkZWQoaCwgQUFEKTtcbiAgdXBkYXRlUGFkZGVkKGgsIGNpcGhlcnRleHQpO1xuICBoLnVwZGF0ZShsZW5ndGhzKTtcbiAgY29uc3QgcmVzID0gaC5kaWdlc3QoKTtcbiAgY2xlYW4oYXV0aEtleSwgbGVuZ3Rocyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cbiAqIFNhbHNhMjAgYW5kIGNoYWNoYSAoUkZDIDg0MzkpIHVzZSBwb2x5MTMwNSBkaWZmZXJlbnRseS5cbiAqIFdlIGNvdWxkIGhhdmUgY29tcG9zZWQgdGhlbSwgYnV0IGl0J3MgaGFyZCBiZWNhdXNlIG9mIGF1dGhLZXk6XG4gKiBJbiBzYWxzYTIwLCBhdXRoS2V5IGNoYW5nZXMgcG9zaXRpb24gaW4gc2Fsc2Egc3RyZWFtLlxuICogSW4gY2hhY2hhLCBhdXRoS2V5IGNhbid0IGJlIGNvbXB1dGVkIGluc2lkZSBjb21wdXRlVGFnLCBpdCBtb2RpZmllcyB0aGUgY291bnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IF9wb2x5MTMwNV9hZWFkID1cbiAgKHhvclN0cmVhbTogWG9yU3RyZWFtKSA9PlxuICAoa2V5OiBVaW50OEFycmF5LCBub25jZTogVWludDhBcnJheSwgQUFEPzogVWludDhBcnJheSk6IENpcGhlcldpdGhPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuICAgIHJldHVybiB7XG4gICAgICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSwgb3V0cHV0PzogVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBwbGVuZ3RoID0gcGxhaW50ZXh0Lmxlbmd0aDtcbiAgICAgICAgb3V0cHV0ID0gZ2V0T3V0cHV0KHBsZW5ndGggKyB0YWdMZW5ndGgsIG91dHB1dCwgZmFsc2UpO1xuICAgICAgICBvdXRwdXQuc2V0KHBsYWludGV4dCk7XG4gICAgICAgIGNvbnN0IG9QbGFpbiA9IG91dHB1dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgLy8gQWN0dWFsIGVuY3J5cHRpb25cbiAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIG9QbGFpbiwgb1BsYWluLCAxKTtcbiAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyh4b3JTdHJlYW0sIGtleSwgbm9uY2UsIG9QbGFpbiwgQUFEKTtcbiAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgIGNsZWFuKHRhZyk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0OiBVaW50OEFycmF5LCBvdXRwdXQ/OiBVaW50OEFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IGdldE91dHB1dChjaXBoZXJ0ZXh0Lmxlbmd0aCAtIHRhZ0xlbmd0aCwgb3V0cHV0LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgZGF0YSwgQUFEKTtcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKHBhc3NlZFRhZywgdGFnKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZycpO1xuICAgICAgICBvdXRwdXQuc2V0KGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCkpO1xuICAgICAgICAvLyBBY3R1YWwgZGVjcnlwdGlvblxuICAgICAgICB4b3JTdHJlYW0oa2V5LCBub25jZSwgb3V0cHV0LCBvdXRwdXQsIDEpOyAvLyBzdGFydCBzdHJlYW0gd2l0aCBpPTFcbiAgICAgICAgY2xlYW4odGFnKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuICpcbiAqIFVuc2FmZSB0byB1c2UgcmFuZG9tIG5vbmNlcyB1bmRlciB0aGUgc2FtZSBrZXksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICogUHJlZmVyIFhDaGFDaGEgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwcG9seTEzMDU6IEFSWENpcGhlciA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LFxuICBfcG9seTEzMDVfYWVhZChjaGFjaGEyMClcbik7XG4vKipcbiAqIFhDaGFDaGEyMC1Qb2x5MTMwNSBleHRlbmRlZC1ub25jZSBjaGFjaGEuXG4gKlxuICogQ2FuIGJlIHNhZmVseSB1c2VkIHdpdGggcmFuZG9tIG5vbmNlcyAoQ1NQUk5HKS5cbiAqIFNlZSBbSVJURiBkcmFmdF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSkuXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjBwb2x5MTMwNTogQVJYQ2lwaGVyID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDI0LCB0YWdMZW5ndGg6IDE2IH0sXG4gIF9wb2x5MTMwNV9hZWFkKHhjaGFjaGEyMClcbik7XG5cbi8qKlxuICogQ2hhY2hhMjAgQ1NQUk5HIChjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLlxuICogSXQncyBiZXN0IHRvIGxpbWl0IHVzYWdlIHRvIG5vbi1wcm9kdWN0aW9uLCBub24tY3JpdGljYWwgY2FzZXM6IGZvciBleGFtcGxlLCB0ZXN0LW9ubHkuXG4gKiBDb21wYXRpYmxlIHdpdGggbGlidG9tY3J5cHQuIEl0IGRvZXMgbm90IGhhdmUgYSBzcGVjaWZpY2F0aW9uLCBzbyB1bmNsZWFyIGhvdyBzZWN1cmUgaXQgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBybmdDaGFjaGEyMDogWG9yUFJHID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVBSRyhjaGFjaGEyMG9yaWcsIDY0LCAzMiwgOCk7XG4vKipcbiAqIENoYWNoYTIwLzggQ1NQUk5HIChjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLlxuICogSXQncyBiZXN0IHRvIGxpbWl0IHVzYWdlIHRvIG5vbi1wcm9kdWN0aW9uLCBub24tY3JpdGljYWwgY2FzZXM6IGZvciBleGFtcGxlLCB0ZXN0LW9ubHkuXG4gKiBGYXN0ZXIgdGhhbiBgcm5nQ2hhY2hhMjBgLlxuICovXG5leHBvcnQgY29uc3Qgcm5nQ2hhY2hhODogWG9yUFJHID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVBSRyhjaGFjaGE4LCA2NCwgMzIsIDEyKTtcbiIsICIvKipcbiAqIEhLREYgKFJGQyA1ODY5KTogZXh0cmFjdCArIGV4cGFuZCBpbiBvbmUgc3RlcC5cbiAqIFNlZSBodHRwczovL3NvYXRvay5ibG9nLzIwMjEvMTEvMTcvdW5kZXJzdGFuZGluZy1oa2RmLy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJy4vaG1hYy50cyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGFoYXNoLCBhbnVtYmVyLCB0eXBlIENIYXNoLCBjbGVhbiB9IGZyb20gJy4vdXRpbHMudHMnO1xuXG4vKipcbiAqIEhLREYtZXh0cmFjdCBmcm9tIHNwZWMuIExlc3MgaW1wb3J0YW50IHBhcnQuIGBIS0RGLUV4dHJhY3QoSUtNLCBzYWx0KSAtPiBQUktgXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KGhhc2g6IENIYXNoLCBpa206IFVpbnQ4QXJyYXksIHNhbHQ/OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIGFoYXNoKGhhc2gpO1xuICAvLyBOT1RFOiBzb21lIGxpYnJhcmllcyB0cmVhdCB6ZXJvLWxlbmd0aCBhcnJheSBhcyAnbm90IHByb3ZpZGVkJztcbiAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gIGlmIChzYWx0ID09PSB1bmRlZmluZWQpIHNhbHQgPSBuZXcgVWludDhBcnJheShoYXNoLm91dHB1dExlbik7XG4gIHJldHVybiBobWFjKGhhc2gsIHNhbHQsIGlrbSk7XG59XG5cbmNvbnN0IEhLREZfQ09VTlRFUiA9IC8qIEBfX1BVUkVfXyAqLyBVaW50OEFycmF5Lm9mKDApO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkub2YoKTtcblxuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLiBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydC4gYEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNYFxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gcHJrIC0gYSBwc2V1ZG9yYW5kb20ga2V5IG9mIGF0IGxlYXN0IEhhc2hMZW4gb2N0ZXRzICh1c3VhbGx5LCB0aGUgb3V0cHV0IGZyb20gdGhlIGV4dHJhY3Qgc3RlcClcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKFxuICBoYXNoOiBDSGFzaCxcbiAgcHJrOiBVaW50OEFycmF5LFxuICBpbmZvPzogVWludDhBcnJheSxcbiAgbGVuZ3RoOiBudW1iZXIgPSAzMlxuKTogVWludDhBcnJheSB7XG4gIGFoYXNoKGhhc2gpO1xuICBhbnVtYmVyKGxlbmd0aCwgJ2xlbmd0aCcpO1xuICBjb25zdCBvbGVuID0gaGFzaC5vdXRwdXRMZW47XG4gIGlmIChsZW5ndGggPiAyNTUgKiBvbGVuKSB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBtdXN0IGJlIDw9IDI1NSpIYXNoTGVuJyk7XG4gIGNvbnN0IGJsb2NrcyA9IE1hdGguY2VpbChsZW5ndGggLyBvbGVuKTtcbiAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkgaW5mbyA9IEVNUFRZX0JVRkZFUjtcbiAgZWxzZSBhYnl0ZXMoaW5mbywgdW5kZWZpbmVkLCAnaW5mbycpO1xuICAvLyBmaXJzdCBMKGVuZ3RoKSBvY3RldHMgb2YgVFxuICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBvbGVuKTtcbiAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgY29uc3QgSE1BQyA9IGhtYWMuY3JlYXRlKGhhc2gsIHByayk7XG4gIGNvbnN0IEhNQUNUbXAgPSBITUFDLl9jbG9uZUludG8oKTtcbiAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgZm9yIChsZXQgY291bnRlciA9IDA7IGNvdW50ZXIgPCBibG9ja3M7IGNvdW50ZXIrKykge1xuICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgIC8vIFQoMCkgPSBlbXB0eSBzdHJpbmcgKHplcm8gbGVuZ3RoKVxuICAgIC8vIFQoTikgPSBITUFDLUhhc2goUFJLLCBUKE4tMSkgfCBpbmZvIHwgTilcbiAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgb2ttLnNldChULCBvbGVuICogY291bnRlcik7XG4gICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICB9XG4gIEhNQUMuZGVzdHJveSgpO1xuICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgY2xlYW4oVCwgSEtERl9DT1VOVEVSKTtcbiAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIEhLREYgKFJGQyA1ODY5KTogZGVyaXZlIGtleXMgZnJvbSBhbiBpbml0aWFsIGlucHV0LlxuICogQ29tYmluZXMgaGtkZl9leHRyYWN0ICsgaGtkZl9leHBhbmQgaW4gb25lIHN0ZXBcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uIChjYW4gYmUgYSB6ZXJvLWxlbmd0aCBzdHJpbmcpXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gYnl0ZXNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBoa2RmIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9oa2RmJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBpbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuICogY29uc3QgaW5wdXRLZXkgPSByYW5kb21CeXRlcygzMik7XG4gKiBjb25zdCBzYWx0ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICogY29uc3QgaW5mbyA9ICdhcHBsaWNhdGlvbi1rZXknO1xuICogY29uc3QgaGsxID0gaGtkZihzaGEyNTYsIGlucHV0S2V5LCBzYWx0LCBpbmZvLCAzMik7XG4gKi9cbmV4cG9ydCBjb25zdCBoa2RmID0gKFxuICBoYXNoOiBDSGFzaCxcbiAgaWttOiBVaW50OEFycmF5LFxuICBzYWx0OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICBpbmZvOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICBsZW5ndGg6IG51bWJlclxuKTogVWludDhBcnJheSA9PiBleHBhbmQoaGFzaCwgZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpLCBpbmZvLCBsZW5ndGgpO1xuIiwgInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanNcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlscy5qc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNvcnRFdmVudHMoZXZlbnRzKSB7XG4gIHJldHVybiBldmVudHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmNyZWF0ZWRfYXQgIT09IGIuY3JlYXRlZF9hdCkge1xuICAgICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKTtcbiAgfSk7XG59XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTIuanNcIjtcblxuLy8gdXRpbHMudHNcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIGJpbmFyeVNlYXJjaDogKCkgPT4gYmluYXJ5U2VhcmNoLFxuICBieXRlc1RvSGV4OiAoKSA9PiBieXRlc1RvSGV4LFxuICBoZXhUb0J5dGVzOiAoKSA9PiBoZXhUb0J5dGVzLFxuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0LFxuICBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3QsXG4gIG1lcmdlUmV2ZXJzZVNvcnRlZExpc3RzOiAoKSA9PiBtZXJnZVJldmVyc2VTb3J0ZWRMaXN0cyxcbiAgbm9ybWFsaXplVVJMOiAoKSA9PiBub3JtYWxpemVVUkwsXG4gIHV0ZjhEZWNvZGVyOiAoKSA9PiB1dGY4RGVjb2RlcixcbiAgdXRmOEVuY29kZXI6ICgpID0+IHV0ZjhFbmNvZGVyXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGhleFRvQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlscy5qc1wiO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPT09IC0xKVxuICAgICAgdXJsID0gXCJ3c3M6Ly9cIiArIHVybDtcbiAgICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKVxuICAgICAgcC5wcm90b2NvbCA9IFwid3M6XCI7XG4gICAgZWxzZSBpZiAocC5wcm90b2NvbCA9PT0gXCJodHRwczpcIilcbiAgICAgIHAucHJvdG9jb2wgPSBcIndzczpcIjtcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gICAgaWYgKHAucG9ydCA9PT0gXCI4MFwiICYmIHAucHJvdG9jb2wgPT09IFwid3M6XCIgfHwgcC5wb3J0ID09PSBcIjQ0M1wiICYmIHAucHJvdG9jb2wgPT09IFwid3NzOlwiKVxuICAgICAgcC5wb3J0ID0gXCJcIjtcbiAgICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gICAgcC5oYXNoID0gXCJcIjtcbiAgICByZXR1cm4gcC50b1N0cmluZygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmx9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBjb25zdCBbaWR4LCBmb3VuZF0gPSBiaW5hcnlTZWFyY2goc29ydGVkQXJyYXksIChiKSA9PiB7XG4gICAgaWYgKGV2ZW50LmlkID09PSBiLmlkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPT09IGIuY3JlYXRlZF9hdClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICBzb3J0ZWRBcnJheS5zcGxpY2UoaWR4LCAwLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGV2ZW50LmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnIsIGNvbXBhcmUpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgY29uc3QgY21wID0gY29tcGFyZShhcnJbbWlkXSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFttaWQsIHRydWVdO1xuICAgIH1cbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBmYWxzZV07XG59XG5mdW5jdGlvbiBtZXJnZVJldmVyc2VTb3J0ZWRMaXN0cyhsaXN0MSwgbGlzdDIpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxpc3QxLmxlbmd0aCArIGxpc3QyLmxlbmd0aCk7XG4gIHJlc3VsdC5sZW5ndGggPSAwO1xuICBsZXQgaTEgPSAwO1xuICBsZXQgaTIgPSAwO1xuICBsZXQgc2FtZVRpbWVzdGFtcElkcyA9IFtdO1xuICB3aGlsZSAoaTEgPCBsaXN0MS5sZW5ndGggJiYgaTIgPCBsaXN0Mi5sZW5ndGgpIHtcbiAgICBsZXQgbmV4dDtcbiAgICBpZiAobGlzdDFbaTFdPy5jcmVhdGVkX2F0ID4gbGlzdDJbaTJdPy5jcmVhdGVkX2F0KSB7XG4gICAgICBuZXh0ID0gbGlzdDFbaTFdO1xuICAgICAgaTErKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCA9IGxpc3QyW2kyXTtcbiAgICAgIGkyKys7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLmNyZWF0ZWRfYXQgPT09IG5leHQuY3JlYXRlZF9hdCkge1xuICAgICAgaWYgKHNhbWVUaW1lc3RhbXBJZHMuaW5jbHVkZXMobmV4dC5pZCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYW1lVGltZXN0YW1wSWRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG5leHQpO1xuICAgIHNhbWVUaW1lc3RhbXBJZHMucHVzaChuZXh0LmlkKTtcbiAgfVxuICB3aGlsZSAoaTEgPCBsaXN0MS5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXh0ID0gbGlzdDFbaTFdO1xuICAgIGkxKys7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0uY3JlYXRlZF9hdCA9PT0gbmV4dC5jcmVhdGVkX2F0KSB7XG4gICAgICBpZiAoc2FtZVRpbWVzdGFtcElkcy5pbmNsdWRlcyhuZXh0LmlkKSlcbiAgICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbWVUaW1lc3RhbXBJZHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobmV4dCk7XG4gICAgc2FtZVRpbWVzdGFtcElkcy5wdXNoKG5leHQuaWQpO1xuICB9XG4gIHdoaWxlIChpMiA8IGxpc3QyLmxlbmd0aCkge1xuICAgIGNvbnN0IG5leHQgPSBsaXN0MltpMl07XG4gICAgaTIrKztcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5jcmVhdGVkX2F0ID09PSBuZXh0LmNyZWF0ZWRfYXQpIHtcbiAgICAgIGlmIChzYW1lVGltZXN0YW1wSWRzLmluY2x1ZGVzKG5leHQuaWQpKVxuICAgICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FtZVRpbWVzdGFtcElkcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChuZXh0KTtcbiAgICBzYW1lVGltZXN0YW1wSWRzLnB1c2gobmV4dC5pZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcHVyZS50c1xudmFyIEpTID0gY2xhc3Mge1xuICBnZW5lcmF0ZVNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gc2Nobm9yci51dGlscy5yYW5kb21TZWNyZXRLZXkoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgyKHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICB9XG4gIGZpbmFsaXplRXZlbnQodCwgc2VjcmV0S2V5KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0O1xuICAgIGV2ZW50LnB1YmtleSA9IGJ5dGVzVG9IZXgyKHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4MihzY2hub3JyLnNpZ24oaGV4VG9CeXRlczIoZ2V0RXZlbnRIYXNoKGV2ZW50KSksIHNlY3JldEtleSkpO1xuICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHZlcmlmeUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudFt2ZXJpZmllZFN5bWJvbF0gPT09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXTtcbiAgICBjb25zdCBoYXNoID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoaGFzaCAhPT0gZXZlbnQuaWQpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsaWQgPSBzY2hub3JyLnZlcmlmeShoZXhUb0J5dGVzMihldmVudC5zaWcpLCBoZXhUb0J5dGVzMihoYXNoKSwgaGV4VG9CeXRlczIoZXZlbnQucHVia2V5KSk7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB2YWxpZDtcbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUV2ZW50KGV2dCkge1xuICBpZiAoIXZhbGlkYXRlRXZlbnQoZXZ0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgZXZlbnQgd2l0aCB3cm9uZyBvciBtaXNzaW5nIHByb3BlcnRpZXNcIik7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShbMCwgZXZ0LnB1YmtleSwgZXZ0LmNyZWF0ZWRfYXQsIGV2dC5raW5kLCBldnQudGFncywgZXZ0LmNvbnRlbnRdKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaChldmVudCkge1xuICBsZXQgZXZlbnRIYXNoID0gc2hhMjU2KHV0ZjhFbmNvZGVyLmVuY29kZShzZXJpYWxpemVFdmVudChldmVudCkpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgyKGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBraW5kc19leHBvcnRzID0ge307XG5fX2V4cG9ydChraW5kc19leHBvcnRzLCB7XG4gIEFwcGxpY2F0aW9uOiAoKSA9PiBBcHBsaWNhdGlvbixcbiAgQmFkZ2VBd2FyZDogKCkgPT4gQmFkZ2VBd2FyZCxcbiAgQmFkZ2VEZWZpbml0aW9uOiAoKSA9PiBCYWRnZURlZmluaXRpb24sXG4gIEJsb2NrZWRSZWxheXNMaXN0OiAoKSA9PiBCbG9ja2VkUmVsYXlzTGlzdCxcbiAgQmxvc3NvbVNlcnZlckxpc3Q6ICgpID0+IEJsb3Nzb21TZXJ2ZXJMaXN0LFxuICBCb29rbWFya0xpc3Q6ICgpID0+IEJvb2ttYXJrTGlzdCxcbiAgQm9va21hcmtzZXRzOiAoKSA9PiBCb29rbWFya3NldHMsXG4gIENhbGVuZGFyOiAoKSA9PiBDYWxlbmRhcixcbiAgQ2FsZW5kYXJFdmVudFJTVlA6ICgpID0+IENhbGVuZGFyRXZlbnRSU1ZQLFxuICBDaGFubmVsQ3JlYXRpb246ICgpID0+IENoYW5uZWxDcmVhdGlvbixcbiAgQ2hhbm5lbEhpZGVNZXNzYWdlOiAoKSA9PiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gIENoYW5uZWxNZXNzYWdlOiAoKSA9PiBDaGFubmVsTWVzc2FnZSxcbiAgQ2hhbm5lbE1ldGFkYXRhOiAoKSA9PiBDaGFubmVsTWV0YWRhdGEsXG4gIENoYW5uZWxNdXRlVXNlcjogKCkgPT4gQ2hhbm5lbE11dGVVc2VyLFxuICBDaGF0TWVzc2FnZTogKCkgPT4gQ2hhdE1lc3NhZ2UsXG4gIENsYXNzaWZpZWRMaXN0aW5nOiAoKSA9PiBDbGFzc2lmaWVkTGlzdGluZyxcbiAgQ2xpZW50QXV0aDogKCkgPT4gQ2xpZW50QXV0aCxcbiAgQ29tbWVudDogKCkgPT4gQ29tbWVudCxcbiAgQ29tbXVuaXRpZXNMaXN0OiAoKSA9PiBDb21tdW5pdGllc0xpc3QsXG4gIENvbW11bml0eURlZmluaXRpb246ICgpID0+IENvbW11bml0eURlZmluaXRpb24sXG4gIENvbW11bml0eVBvc3RBcHByb3ZhbDogKCkgPT4gQ29tbXVuaXR5UG9zdEFwcHJvdmFsLFxuICBDb250YWN0czogKCkgPT4gQ29udGFjdHMsXG4gIENyZWF0ZU9yVXBkYXRlUHJvZHVjdDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVQcm9kdWN0LFxuICBDcmVhdGVPclVwZGF0ZVN0YWxsOiAoKSA9PiBDcmVhdGVPclVwZGF0ZVN0YWxsLFxuICBDdXJhdGlvbnNldHM6ICgpID0+IEN1cmF0aW9uc2V0cyxcbiAgRGF0ZTogKCkgPT4gRGF0ZTIsXG4gIERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0OiAoKSA9PiBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCxcbiAgRHJhZnRDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gRHJhZnRDbGFzc2lmaWVkTGlzdGluZyxcbiAgRHJhZnRMb25nOiAoKSA9PiBEcmFmdExvbmcsXG4gIEVtb2ppc2V0czogKCkgPT4gRW1vamlzZXRzLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlOiAoKSA9PiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlLFxuICBFdmVudERlbGV0aW9uOiAoKSA9PiBFdmVudERlbGV0aW9uLFxuICBGYXZvcml0ZVJlbGF5czogKCkgPT4gRmF2b3JpdGVSZWxheXMsXG4gIEZpbGVNZXNzYWdlOiAoKSA9PiBGaWxlTWVzc2FnZSxcbiAgRmlsZU1ldGFkYXRhOiAoKSA9PiBGaWxlTWV0YWRhdGEsXG4gIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlOiAoKSA9PiBGaWxlU2VydmVyUHJlZmVyZW5jZSxcbiAgRm9sbG93c2V0czogKCkgPT4gRm9sbG93c2V0cyxcbiAgRm9ydW1UaHJlYWQ6ICgpID0+IEZvcnVtVGhyZWFkLFxuICBHZW5lcmljUmVwb3N0OiAoKSA9PiBHZW5lcmljUmVwb3N0LFxuICBHZW5lcmljbGlzdHM6ICgpID0+IEdlbmVyaWNsaXN0cyxcbiAgR2lmdFdyYXA6ICgpID0+IEdpZnRXcmFwLFxuICBHcm91cE1ldGFkYXRhOiAoKSA9PiBHcm91cE1ldGFkYXRhLFxuICBIVFRQQXV0aDogKCkgPT4gSFRUUEF1dGgsXG4gIEhhbmRsZXJpbmZvcm1hdGlvbjogKCkgPT4gSGFuZGxlcmluZm9ybWF0aW9uLFxuICBIYW5kbGVycmVjb21tZW5kYXRpb246ICgpID0+IEhhbmRsZXJyZWNvbW1lbmRhdGlvbixcbiAgSGlnaGxpZ2h0czogKCkgPT4gSGlnaGxpZ2h0cyxcbiAgSW50ZXJlc3RzTGlzdDogKCkgPT4gSW50ZXJlc3RzTGlzdCxcbiAgSW50ZXJlc3RzZXRzOiAoKSA9PiBJbnRlcmVzdHNldHMsXG4gIEpvYkZlZWRiYWNrOiAoKSA9PiBKb2JGZWVkYmFjayxcbiAgSm9iUmVxdWVzdDogKCkgPT4gSm9iUmVxdWVzdCxcbiAgSm9iUmVzdWx0OiAoKSA9PiBKb2JSZXN1bHQsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGlnaHRuaW5nUHViUlBDOiAoKSA9PiBMaWdodG5pbmdQdWJSUEMsXG4gIExpdmVDaGF0TWVzc2FnZTogKCkgPT4gTGl2ZUNoYXRNZXNzYWdlLFxuICBMaXZlRXZlbnQ6ICgpID0+IExpdmVFdmVudCxcbiAgTG9uZ0Zvcm1BcnRpY2xlOiAoKSA9PiBMb25nRm9ybUFydGljbGUsXG4gIE1ldGFkYXRhOiAoKSA9PiBNZXRhZGF0YSxcbiAgTXV0ZWxpc3Q6ICgpID0+IE11dGVsaXN0LFxuICBOV0NXYWxsZXRJbmZvOiAoKSA9PiBOV0NXYWxsZXRJbmZvLFxuICBOV0NXYWxsZXRSZXF1ZXN0OiAoKSA9PiBOV0NXYWxsZXRSZXF1ZXN0LFxuICBOV0NXYWxsZXRSZXNwb25zZTogKCkgPT4gTldDV2FsbGV0UmVzcG9uc2UsXG4gIE5vcm1hbFZpZGVvOiAoKSA9PiBOb3JtYWxWaWRlbyxcbiAgTm9zdHJDb25uZWN0OiAoKSA9PiBOb3N0ckNvbm5lY3QsXG4gIE9wZW5UaW1lc3RhbXBzOiAoKSA9PiBPcGVuVGltZXN0YW1wcyxcbiAgUGhvdG86ICgpID0+IFBob3RvLFxuICBQaW5saXN0OiAoKSA9PiBQaW5saXN0LFxuICBQb2xsOiAoKSA9PiBQb2xsLFxuICBQb2xsUmVzcG9uc2U6ICgpID0+IFBvbGxSZXNwb25zZSxcbiAgUHJpdmF0ZURpcmVjdE1lc3NhZ2U6ICgpID0+IFByaXZhdGVEaXJlY3RNZXNzYWdlLFxuICBQcm9ibGVtVHJhY2tlcjogKCkgPT4gUHJvYmxlbVRyYWNrZXIsXG4gIFByb2ZpbGVCYWRnZXM6ICgpID0+IFByb2ZpbGVCYWRnZXMsXG4gIFB1YmxpY0NoYXRzTGlzdDogKCkgPT4gUHVibGljQ2hhdHNMaXN0LFxuICBSZWFjdGlvbjogKCkgPT4gUmVhY3Rpb24sXG4gIFJlY29tbWVuZFJlbGF5OiAoKSA9PiBSZWNvbW1lbmRSZWxheSxcbiAgUmVsYXlMaXN0OiAoKSA9PiBSZWxheUxpc3QsXG4gIFJlbGF5UmV2aWV3OiAoKSA9PiBSZWxheVJldmlldyxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYWw6ICgpID0+IFNlYWwsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFNob3J0VmlkZW86ICgpID0+IFNob3J0VmlkZW8sXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBWb2ljZTogKCkgPT4gVm9pY2UsXG4gIFZvaWNlQ29tbWVudDogKCkgPT4gVm9pY2VDb21tZW50LFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzQWRkcmVzc2FibGVLaW5kOiAoKSA9PiBpc0FkZHJlc3NhYmxlS2luZCxcbiAgaXNFcGhlbWVyYWxLaW5kOiAoKSA9PiBpc0VwaGVtZXJhbEtpbmQsXG4gIGlzS2luZDogKCkgPT4gaXNLaW5kLFxuICBpc1JlZ3VsYXJLaW5kOiAoKSA9PiBpc1JlZ3VsYXJLaW5kLFxuICBpc1JlcGxhY2VhYmxlS2luZDogKCkgPT4gaXNSZXBsYWNlYWJsZUtpbmRcbn0pO1xuZnVuY3Rpb24gaXNSZWd1bGFyS2luZChraW5kKSB7XG4gIHJldHVybiBraW5kIDwgMWU0ICYmIGtpbmQgIT09IDAgJiYga2luZCAhPT0gMztcbn1cbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIGtpbmQgPT09IDAgfHwga2luZCA9PT0gMyB8fCAxZTQgPD0ga2luZCAmJiBraW5kIDwgMmU0O1xufVxuZnVuY3Rpb24gaXNFcGhlbWVyYWxLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDJlNCA8PSBraW5kICYmIGtpbmQgPCAzZTQ7XG59XG5mdW5jdGlvbiBpc0FkZHJlc3NhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiAzZTQgPD0ga2luZCAmJiBraW5kIDwgNGU0O1xufVxuZnVuY3Rpb24gY2xhc3NpZnlLaW5kKGtpbmQpIHtcbiAgaWYgKGlzUmVndWxhcktpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVndWxhclwiO1xuICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVwbGFjZWFibGVcIjtcbiAgaWYgKGlzRXBoZW1lcmFsS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJlcGhlbWVyYWxcIjtcbiAgaWYgKGlzQWRkcmVzc2FibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInBhcmFtZXRlcml6ZWRcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNLaW5kKGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IGtpbmRBc0FycmF5ID0ga2luZCBpbnN0YW5jZW9mIEFycmF5ID8ga2luZCA6IFtraW5kXTtcbiAgcmV0dXJuIHZhbGlkYXRlRXZlbnQoZXZlbnQpICYmIGtpbmRBc0FycmF5LmluY2x1ZGVzKGV2ZW50LmtpbmQpIHx8IGZhbHNlO1xufVxudmFyIE1ldGFkYXRhID0gMDtcbnZhciBTaG9ydFRleHROb3RlID0gMTtcbnZhciBSZWNvbW1lbmRSZWxheSA9IDI7XG52YXIgQ29udGFjdHMgPSAzO1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgPSA0O1xudmFyIEV2ZW50RGVsZXRpb24gPSA1O1xudmFyIFJlcG9zdCA9IDY7XG52YXIgUmVhY3Rpb24gPSA3O1xudmFyIEJhZGdlQXdhcmQgPSA4O1xudmFyIENoYXRNZXNzYWdlID0gOTtcbnZhciBGb3J1bVRocmVhZCA9IDExO1xudmFyIFNlYWwgPSAxMztcbnZhciBQcml2YXRlRGlyZWN0TWVzc2FnZSA9IDE0O1xudmFyIEZpbGVNZXNzYWdlID0gMTU7XG52YXIgR2VuZXJpY1JlcG9zdCA9IDE2O1xudmFyIFBob3RvID0gMjA7XG52YXIgTm9ybWFsVmlkZW8gPSAyMTtcbnZhciBTaG9ydFZpZGVvID0gMjI7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgR2lmdFdyYXAgPSAxMDU5O1xudmFyIFBvbGwgPSAxMDY4O1xudmFyIEZpbGVNZXRhZGF0YSA9IDEwNjM7XG52YXIgQ29tbWVudCA9IDExMTE7XG52YXIgTGl2ZUNoYXRNZXNzYWdlID0gMTMxMTtcbnZhciBWb2ljZSA9IDEyMjI7XG52YXIgVm9pY2VDb21tZW50ID0gMTI0NDtcbnZhciBQcm9ibGVtVHJhY2tlciA9IDE5NzE7XG52YXIgUmVwb3J0ID0gMTk4NDtcbnZhciBSZXBvcnRpbmcgPSAxOTg0O1xudmFyIExhYmVsID0gMTk4NTtcbnZhciBDb21tdW5pdHlQb3N0QXBwcm92YWwgPSA0NTUwO1xudmFyIEpvYlJlcXVlc3QgPSA1OTk5O1xudmFyIEpvYlJlc3VsdCA9IDY5OTk7XG52YXIgSm9iRmVlZGJhY2sgPSA3ZTM7XG52YXIgWmFwR29hbCA9IDkwNDE7XG52YXIgWmFwUmVxdWVzdCA9IDk3MzQ7XG52YXIgWmFwID0gOTczNTtcbnZhciBIaWdobGlnaHRzID0gOTgwMjtcbnZhciBQb2xsUmVzcG9uc2UgPSAxMDE4O1xudmFyIE11dGVsaXN0ID0gMWU0O1xudmFyIFBpbmxpc3QgPSAxMDAwMTtcbnZhciBSZWxheUxpc3QgPSAxMDAwMjtcbnZhciBCb29rbWFya0xpc3QgPSAxMDAwMztcbnZhciBDb21tdW5pdGllc0xpc3QgPSAxMDAwNDtcbnZhciBQdWJsaWNDaGF0c0xpc3QgPSAxMDAwNTtcbnZhciBCbG9ja2VkUmVsYXlzTGlzdCA9IDEwMDA2O1xudmFyIFNlYXJjaFJlbGF5c0xpc3QgPSAxMDAwNztcbnZhciBGYXZvcml0ZVJlbGF5cyA9IDEwMDEyO1xudmFyIEludGVyZXN0c0xpc3QgPSAxMDAxNTtcbnZhciBVc2VyRW1vamlMaXN0ID0gMTAwMzA7XG52YXIgRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3QgPSAxMDA1MDtcbnZhciBGaWxlU2VydmVyUHJlZmVyZW5jZSA9IDEwMDk2O1xudmFyIEJsb3Nzb21TZXJ2ZXJMaXN0ID0gMTAwNjM7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIFJlbGF5UmV2aWV3ID0gMzE5ODc7XG52YXIgSGFuZGxlcnJlY29tbWVuZGF0aW9uID0gMzE5ODk7XG52YXIgSGFuZGxlcmluZm9ybWF0aW9uID0gMzE5OTA7XG52YXIgQ29tbXVuaXR5RGVmaW5pdGlvbiA9IDM0NTUwO1xudmFyIEdyb3VwTWV0YWRhdGEgPSAzOWUzO1xuXG4vLyBmaWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgZiBpbiBmaWx0ZXIpIHtcbiAgICBpZiAoZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgIGxldCB0YWdOYW1lID0gZi5zbGljZSgxKTtcbiAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gZi5zbGljZSgxKSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIudW50aWwgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IGZpbHRlci51bnRpbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hGaWx0ZXJzKGZpbHRlcnMsIGV2ZW50KSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaWx0ZXJzLmxlbmd0aDsgaTIrKykge1xuICAgIGlmIChtYXRjaEZpbHRlcihmaWx0ZXJzW2kyXSwgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzKC4uLmZpbHRlcnMpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyc1tpMl07XG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJraW5kc1wiIHx8IHByb3BlcnR5ID09PSBcImlkc1wiIHx8IHByb3BlcnR5ID09PSBcImF1dGhvcnNcIiB8fCBwcm9wZXJ0eVswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHJlc3VsdFtwcm9wZXJ0eV0gfHwgW107XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdmFsdWVzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW3ZdO1xuICAgICAgICAgIGlmICghcmVzdWx0W3Byb3BlcnR5XS5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZpbHRlci5saW1pdCAmJiAoIXJlc3VsdC5saW1pdCB8fCBmaWx0ZXIubGltaXQgPiByZXN1bHQubGltaXQpKVxuICAgICAgcmVzdWx0LmxpbWl0ID0gZmlsdGVyLmxpbWl0O1xuICAgIGlmIChmaWx0ZXIudW50aWwgJiYgKCFyZXN1bHQudW50aWwgfHwgZmlsdGVyLnVudGlsID4gcmVzdWx0LnVudGlsKSlcbiAgICAgIHJlc3VsdC51bnRpbCA9IGZpbHRlci51bnRpbDtcbiAgICBpZiAoZmlsdGVyLnNpbmNlICYmICghcmVzdWx0LnNpbmNlIHx8IGZpbHRlci5zaW5jZSA8IHJlc3VsdC5zaW5jZSkpXG4gICAgICByZXN1bHQuc2luY2UgPSBmaWx0ZXIuc2luY2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEZpbHRlckxpbWl0KGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmlkcyAmJiAhZmlsdGVyLmlkcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgIWZpbHRlci5raW5kcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiAhZmlsdGVyLmF1dGhvcnMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCIjXCIgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBNYXRoLm1heCgwLCBmaWx0ZXIubGltaXQgPz8gSW5maW5pdHkpLFxuICAgIGZpbHRlci5pZHM/Lmxlbmd0aCA/PyBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpKSA/IGZpbHRlci5hdXRob3JzLmxlbmd0aCAqIGZpbHRlci5raW5kcy5sZW5ndGggOiBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzQWRkcmVzc2FibGVLaW5kKGtpbmQpKSAmJiBmaWx0ZXJbXCIjZFwiXT8ubGVuZ3RoID8gZmlsdGVyLmF1dGhvcnMubGVuZ3RoICogZmlsdGVyLmtpbmRzLmxlbmd0aCAqIGZpbHRlcltcIiNkXCJdLmxlbmd0aCA6IEluZmluaXR5XG4gICk7XG59XG5cbi8vIGZha2Vqc29uLnRzXG52YXIgZmFrZWpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFrZWpzb25fZXhwb3J0cywge1xuICBnZXRIZXg2NDogKCkgPT4gZ2V0SGV4NjQsXG4gIGdldEludDogKCkgPT4gZ2V0SW50LFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gZ2V0U3Vic2NyaXB0aW9uSWQsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4gbWF0Y2hFdmVudElkLFxuICBtYXRjaEV2ZW50S2luZDogKCkgPT4gbWF0Y2hFdmVudEtpbmQsXG4gIG1hdGNoRXZlbnRQdWJrZXk6ICgpID0+IG1hdGNoRXZlbnRQdWJrZXlcbn0pO1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRJbnQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aDtcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuICsgMztcbiAgbGV0IHNsaWNlZCA9IGpzb24uc2xpY2UoaWR4KTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNsaWNlZC5pbmRleE9mKFwiLFwiKSwgc2xpY2VkLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KHNsaWNlZC5zbGljZSgwLCBlbmQpLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50SWQoanNvbiwgaWQpIHtcbiAgcmV0dXJuIGlkID09PSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudFB1YmtleShqc29uLCBwdWJrZXkpIHtcbiAgcmV0dXJuIHB1YmtleSA9PT0gZ2V0SGV4NjQoanNvbiwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50S2luZChqc29uLCBraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBnZXRJbnQoanNvbiwgXCJraW5kXCIpO1xufVxuXG4vLyBuaXA0Mi50c1xudmFyIG5pcDQyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQyX2V4cG9ydHMsIHtcbiAgbWFrZUF1dGhFdmVudDogKCkgPT4gbWFrZUF1dGhFdmVudFxufSk7XG5mdW5jdGlvbiBtYWtlQXV0aEV2ZW50KHJlbGF5VVJMLCBjaGFsbGVuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBDbGllbnRBdXRoLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXlVUkxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gYWJzdHJhY3QtcmVsYXkudHNcbnZhciBTZW5kaW5nT25DbG9zZWRDb25uZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlbGF5KSB7XG4gICAgc3VwZXIoYFRyaWVkIHRvIHNlbmQgbWVzc2FnZSAnJHttZXNzYWdlfSBvbiBhIGNsb3NlZCBjb25uZWN0aW9uIHRvICR7cmVsYXl9LmApO1xuICAgIHRoaXMubmFtZSA9IFwiU2VuZGluZ09uQ2xvc2VkQ29ubmVjdGlvblwiO1xuICB9XG59O1xudmFyIEFic3RyYWN0UmVsYXkgPSBjbGFzcyB7XG4gIHVybDtcbiAgX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICBvbmNsb3NlID0gbnVsbDtcbiAgb25ub3RpY2UgPSAobXNnKSA9PiBjb25zb2xlLmRlYnVnKGBOT1RJQ0UgZnJvbSAke3RoaXMudXJsfTogJHttc2d9YCk7XG4gIG9uYXV0aDtcbiAgYmFzZUVvc2VUaW1lb3V0ID0gNDQwMDtcbiAgcHVibGlzaFRpbWVvdXQgPSA0NDAwO1xuICBwaW5nRnJlcXVlbmN5ID0gMjllMztcbiAgcGluZ1RpbWVvdXQgPSAyZTQ7XG4gIHJlc3Vic2NyaWJlQmFja29mZiA9IFsxZTQsIDFlNCwgMWU0LCAyZTQsIDJlNCwgM2U0LCA2ZTRdO1xuICBvcGVuU3VicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGVuYWJsZVBpbmc7XG4gIGVuYWJsZVJlY29ubmVjdDtcbiAgaWRsZVNpbmNlID0gRGF0ZS5ub3coKTtcbiAgb25nb2luZ09wZXJhdGlvbnMgPSAwO1xuICByZWNvbm5lY3RUaW1lb3V0SGFuZGxlO1xuICBwaW5nSW50ZXJ2YWxIYW5kbGU7XG4gIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgc2tpcFJlY29ubmVjdGlvbiA9IGZhbHNlO1xuICBjb25uZWN0aW9uUHJvbWlzZTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB3cztcbiAgY2hhbGxlbmdlO1xuICBhdXRoUHJvbWlzZTtcbiAgc2VyaWFsID0gMDtcbiAgdmVyaWZ5RXZlbnQ7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbiB8fCBXZWJTb2NrZXQ7XG4gICAgdGhpcy5lbmFibGVQaW5nID0gb3B0cy5lbmFibGVQaW5nO1xuICAgIHRoaXMuZW5hYmxlUmVjb25uZWN0ID0gb3B0cy5lbmFibGVSZWNvbm5lY3QgfHwgZmFsc2U7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIG9wdHMpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3Qob3B0cyk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlQWxsU3Vic2NyaXB0aW9ucyhyZWFzb24pIHtcbiAgICBmb3IgKGxldCBbXywgc3ViXSBvZiB0aGlzLm9wZW5TdWJzKSB7XG4gICAgICBzdWIuY2xvc2UocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuU3Vicy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBlcF0gb2YgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMpIHtcbiAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGNyXSBvZiB0aGlzLm9wZW5Db3VudFJlcXVlc3RzKSB7XG4gICAgICBjci5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmNsZWFyKCk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG4gIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5yZXN1YnNjcmliZUJhY2tvZmZbTWF0aC5taW4odGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgdGhpcy5yZXN1YnNjcmliZUJhY2tvZmYubGVuZ3RoIC0gMSldO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfSwgYmFja29mZik7XG4gIH1cbiAgaGFuZGxlSGFyZENsb3NlKHJlYXNvbikge1xuICAgIGlmICh0aGlzLnBpbmdJbnRlcnZhbEhhbmRsZSkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBpbmdJbnRlcnZhbEhhbmRsZSk7XG4gICAgICB0aGlzLnBpbmdJbnRlcnZhbEhhbmRsZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkbGVTaW5jZSA9IHZvaWQgMDtcbiAgICBpZiAodGhpcy5lbmFibGVSZWNvbm5lY3QgJiYgIXRoaXMuc2tpcFJlY29ubmVjdGlvbikge1xuICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKHJlYXNvbik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbm5lY3Qob3B0cykge1xuICAgIGxldCBjb25uZWN0aW9uVGltZW91dEhhbmRsZTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY2hhbGxlbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aFByb21pc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5za2lwUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChvcHRzPy50aW1lb3V0KSB7XG4gICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLnNraXBSZWNvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVIYXJkQ2xvc2UoXCJyZWxheSBjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzPy5hYm9ydCkge1xuICAgICAgICBvcHRzLmFib3J0Lm9uYWJvcnQgPSByZWplY3Q7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzID0gbmV3IHRoaXMuX1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0SGFuZGxlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0SGFuZGxlID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzUmVjb25uZWN0aW9uID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLm9wZW5TdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgc3ViLmVvc2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGlzUmVjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IHN1Yi5maWx0ZXJzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgIGlmIChzdWIubGFzdEVtaXR0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuZmlsdGVyc1tmXS5zaW5jZSA9IHN1Yi5sYXN0RW1pdHRlZCArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3ViLmZpcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmFibGVQaW5nKSB7XG4gICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnBpbmdwb25nKCksIHRoaXMucGluZ0ZyZXF1ZW5jeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSGFyZENsb3NlKFwicmVsYXkgY29ubmVjdGlvbiBmYWlsZWRcIik7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGV2KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHJlamVjdChldi5tZXNzYWdlIHx8IFwid2Vic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgdGhpcy5oYW5kbGVIYXJkQ2xvc2UoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuX29ubWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICB9XG4gIHdhaXRGb3JQaW5nUG9uZygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIDtcbiAgICAgIHRoaXMud3Mub25jZShcInBvbmdcIiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSk7XG4gICAgICB0aGlzLndzLnBpbmcoKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yRHVtbXlSZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYG5vIGNvbm5lY3Rpb24gdG8gJHt0aGlzLnVybH0sIGNhbid0IHBpbmdgKSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgICBbeyBpZHM6IFtcImFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFcIl0sIGxpbWl0OiAwIH1dLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBcIjxmb3JjZWQtcGluZz5cIixcbiAgICAgICAgICAgIG9uZW9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVvc2VUaW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0ICsgMWUzXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHBpbmdwb25nKCkge1xuICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFueShbXG4gICAgICAgIHRoaXMud3MgJiYgdGhpcy53cy5waW5nICYmIHRoaXMud3Mub25jZSA/IHRoaXMud2FpdEZvclBpbmdQb25nKCkgOiB0aGlzLndhaXRGb3JEdW1teVJlcSgpLFxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlcyhmYWxzZSksIHRoaXMucGluZ1RpbWVvdXQpKVxuICAgICAgXSk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gdGhpcy5fV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHRocm93IG5ldyBTZW5kaW5nT25DbG9zZWRDb25uZWN0aW9uKG1lc3NhZ2UsIHRoaXMudXJsKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhdXRoKHNpZ25BdXRoRXZlbnQpIHtcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSB0aGlzLmNoYWxsZW5nZTtcbiAgICBpZiAoIWNoYWxsZW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBlcmZvcm0gYXV0aCwgbm8gY2hhbGxlbmdlIHdhcyByZWNlaXZlZFwiKTtcbiAgICBpZiAodGhpcy5hdXRoUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmF1dGhQcm9taXNlO1xuICAgIHRoaXMuYXV0aFByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZXZ0ID0gYXdhaXQgc2lnbkF1dGhFdmVudChtYWtlQXV0aEV2ZW50KHRoaXMudXJsLCBjaGFsbGVuZ2UpKTtcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBsZXQgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZ0LmlkKTtcbiAgICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJhdXRoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoZXZ0LmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMucHVibGlzaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZ0LmlkLCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dCB9KTtcbiAgICAgICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2dCkgKyBcIl1cIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwic3Vic2NyaWJlIGF1dGggZnVuY3Rpb24gZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmF1dGhQcm9taXNlO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICB0aGlzLmlkbGVTaW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9uZ29pbmdPcGVyYXRpb25zKys7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCk7XG4gICAgICAgIGlmIChlcCkge1xuICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJwdWJsaXNoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGV2ZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0LCB0aW1lb3V0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHRoaXMub25nb2luZ09wZXJhdGlvbnMtLTtcbiAgICBpZiAodGhpcy5vbmdvaW5nT3BlcmF0aW9ucyA9PT0gMClcbiAgICAgIHRoaXMuaWRsZVNpbmNlID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMubGFiZWwgIT09IFwiPGZvcmNlZC1waW5nPlwiKSB7XG4gICAgICB0aGlzLmlkbGVTaW5jZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMub25nb2luZ09wZXJhdGlvbnMrKztcbiAgICB9XG4gICAgY29uc3Qgc3ViID0gdGhpcy5wcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgc3ViLmZpcmUoKTtcbiAgICBpZiAocGFyYW1zLmFib3J0KSB7XG4gICAgICBwYXJhbXMuYWJvcnQub25hYm9ydCA9ICgpID0+IHN1Yi5jbG9zZShTdHJpbmcocGFyYW1zLmFib3J0LnJlYXNvbiB8fCBcIjxhYm9ydGVkPlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG4gIH1cbiAgcHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkIHx8IChwYXJhbXMubGFiZWwgPyBwYXJhbXMubGFiZWwgKyBcIjpcIiA6IFwic3ViOlwiKSArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHN1YiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcywgaWQsIGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgdGhpcy5vcGVuU3Vicy5zZXQoaWQsIHN1Yik7XG4gICAgcmV0dXJuIHN1YjtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLnNraXBSZWNvbm5lY3Rpb24gPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXRIYW5kbGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXRIYW5kbGUpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0SGFuZGxlID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5waW5nSW50ZXJ2YWxIYW5kbGUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5waW5nSW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgdGhpcy5waW5nSW50ZXJ2YWxIYW5kbGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWQgYnkgdXNcIik7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pZGxlU2luY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gdGhpcy5fV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICBjb25zdCBqc29uID0gZXYuZGF0YTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzby5sYXN0RW1pdHRlZCB8fCBzby5sYXN0RW1pdHRlZCA8IGV2ZW50LmNyZWF0ZWRfYXQpXG4gICAgICAgICAgICBzby5sYXN0RW1pdHRlZCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlcC50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgICAgZXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgc28uY2xvc2UoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjoge1xuICAgICAgICAgIHRoaXMub25ub3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IGRhdGFbMV07XG4gICAgICAgICAgaWYgKHRoaXMub25hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGgodGhpcy5vbmF1dGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgc28/Lm9uY3VzdG9tPy4oZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBbXywgX18sIGV2ZW50XSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICB3aW5kb3cucHJpbnRlci5tYXliZShldmVudC5wdWJrZXksIFwiOjogY2F1Z2h0IGVyclwiLCBldmVudCwgdGhpcy51cmwsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xudmFyIFN1YnNjcmlwdGlvbiA9IGNsYXNzIHtcbiAgcmVsYXk7XG4gIGlkO1xuICBsYXN0RW1pdHRlZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgb25jdXN0b207XG4gIGVvc2VUaW1lb3V0O1xuICBlb3NlVGltZW91dEhhbmRsZTtcbiAgY29uc3RydWN0b3IocmVsYXksIGlkLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJzY3JpcHRpb24gY2FuJ3QgYmUgY3JlYXRlZCB3aXRoIHplcm8gZmlsdGVyc1wiKTtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hbHJlYWR5SGF2ZUV2ZW50ID0gcGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ7XG4gICAgdGhpcy5yZWNlaXZlZEV2ZW50ID0gcGFyYW1zLnJlY2VpdmVkRXZlbnQ7XG4gICAgdGhpcy5lb3NlVGltZW91dCA9IHBhcmFtcy5lb3NlVGltZW91dCB8fCByZWxheS5iYXNlRW9zZVRpbWVvdXQ7XG4gICAgdGhpcy5vbmVvc2UgPSBwYXJhbXMub25lb3NlO1xuICAgIHRoaXMub25jbG9zZSA9IHBhcmFtcy5vbmNsb3NlO1xuICAgIHRoaXMub25ldmVudCA9IHBhcmFtcy5vbmV2ZW50IHx8ICgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG9uZXZlbnQoKSBjYWxsYmFjayBub3QgZGVmaW5lZCBmb3Igc3Vic2NyaXB0aW9uICcke3RoaXMuaWR9JyBpbiByZWxheSAke3RoaXMucmVsYXkudXJsfS4gZXZlbnQgcmVjZWl2ZWQ6YCxcbiAgICAgICAgZXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZmlyZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIlJFUVwiLFwiJyArIHRoaXMuaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICB0aGlzLmVvc2VUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLnJlY2VpdmVkRW9zZS5iaW5kKHRoaXMpLCB0aGlzLmVvc2VUaW1lb3V0KTtcbiAgfVxuICByZWNlaXZlZEVvc2UoKSB7XG4gICAgaWYgKHRoaXMuZW9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25lb3NlPy4oKTtcbiAgfVxuICBjbG9zZShyZWFzb24gPSBcImNsb3NlZCBieSBjYWxsZXJcIikge1xuICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiQ0xPU0VcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pZCkgKyBcIl1cIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFNlbmRpbmdPbkNsb3NlZENvbm5lY3Rpb24pIHtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5yZWxheS5vbmdvaW5nT3BlcmF0aW9ucy0tO1xuICAgIGlmICh0aGlzLnJlbGF5Lm9uZ29pbmdPcGVyYXRpb25zID09PSAwKVxuICAgICAgdGhpcy5yZWxheS5pZGxlU2luY2UgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMub25jbG9zZT8uKHJlYXNvbik7XG4gIH1cbn07XG5cbi8vIHJlbGF5LnRzXG52YXIgX1dlYlNvY2tldDtcbnRyeSB7XG4gIF9XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBSZWxheSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RSZWxheSB7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHVybCwgeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXkodXJsLCBvcHRpb25zKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG59O1xuXG4vLyBoZWxwZXJzLnRzXG52YXIgYWx3YXlzVHJ1ZSA9ICh0KSA9PiB7XG4gIHRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBhYnN0cmFjdC1wb29sLnRzXG52YXIgQWJzdHJhY3RTaW1wbGVQb29sID0gY2xhc3Mge1xuICByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZWVuT24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0cmFja1JlbGF5cyA9IGZhbHNlO1xuICB2ZXJpZnlFdmVudDtcbiAgZW5hYmxlUGluZztcbiAgZW5hYmxlUmVjb25uZWN0O1xuICBhdXRvbWF0aWNhbGx5QXV0aDtcbiAgdHJ1c3RlZFJlbGF5VVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIG9uUmVsYXlDb25uZWN0aW9uRmFpbHVyZTtcbiAgb25SZWxheUNvbm5lY3Rpb25TdWNjZXNzO1xuICBhbGxvd0Nvbm5lY3RpbmdUb1JlbGF5O1xuICBtYXhXYWl0Rm9yQ29ubmVjdGlvbjtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICAgIHRoaXMuX1dlYlNvY2tldCA9IG9wdHMud2Vic29ja2V0SW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5lbmFibGVQaW5nID0gb3B0cy5lbmFibGVQaW5nO1xuICAgIHRoaXMuZW5hYmxlUmVjb25uZWN0ID0gb3B0cy5lbmFibGVSZWNvbm5lY3QgfHwgZmFsc2U7XG4gICAgdGhpcy5hdXRvbWF0aWNhbGx5QXV0aCA9IG9wdHMuYXV0b21hdGljYWxseUF1dGg7XG4gICAgdGhpcy5vblJlbGF5Q29ubmVjdGlvbkZhaWx1cmUgPSBvcHRzLm9uUmVsYXlDb25uZWN0aW9uRmFpbHVyZTtcbiAgICB0aGlzLm9uUmVsYXlDb25uZWN0aW9uU3VjY2VzcyA9IG9wdHMub25SZWxheUNvbm5lY3Rpb25TdWNjZXNzO1xuICAgIHRoaXMuYWxsb3dDb25uZWN0aW5nVG9SZWxheSA9IG9wdHMuYWxsb3dDb25uZWN0aW5nVG9SZWxheTtcbiAgICB0aGlzLm1heFdhaXRGb3JDb25uZWN0aW9uID0gb3B0cy5tYXhXYWl0Rm9yQ29ubmVjdGlvbiB8fCAzZTM7XG4gIH1cbiAgYXN5bmMgZW5zdXJlUmVsYXkodXJsLCBwYXJhbXMpIHtcbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwge1xuICAgICAgICB2ZXJpZnlFdmVudDogdGhpcy50cnVzdGVkUmVsYXlVUkxzLmhhcyh1cmwpID8gYWx3YXlzVHJ1ZSA6IHRoaXMudmVyaWZ5RXZlbnQsXG4gICAgICAgIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiB0aGlzLl9XZWJTb2NrZXQsXG4gICAgICAgIGVuYWJsZVBpbmc6IHRoaXMuZW5hYmxlUGluZyxcbiAgICAgICAgZW5hYmxlUmVjb25uZWN0OiB0aGlzLmVuYWJsZVJlY29ubmVjdFxuICAgICAgfSk7XG4gICAgICByZWxheS5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbGF5cy5kZWxldGUodXJsKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlbGF5cy5zZXQodXJsLCByZWxheSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9tYXRpY2FsbHlBdXRoKSB7XG4gICAgICBjb25zdCBhdXRoU2lnbmVyRm4gPSB0aGlzLmF1dG9tYXRpY2FsbHlBdXRoKHVybCk7XG4gICAgICBpZiAoYXV0aFNpZ25lckZuKSB7XG4gICAgICAgIHJlbGF5Lm9uYXV0aCA9IGF1dGhTaWduZXJGbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJlbGF5LmNvbm5lY3Qoe1xuICAgICAgICB0aW1lb3V0OiBwYXJhbXM/LmNvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBhYm9ydDogcGFyYW1zPy5hYm9ydFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnJlbGF5cy5kZWxldGUodXJsKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRoaXMucmVsYXlzLmdldCh1cmwpPy5jbG9zZSgpO1xuICAgICAgdGhpcy5yZWxheXMuZGVsZXRlKHVybCk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gW107XG4gICAgY29uc3QgdW5pcVVybHMgPSBbXTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcmVsYXlzLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3QgdXJsID0gbm9ybWFsaXplVVJMKHJlbGF5c1tpMl0pO1xuICAgICAgaWYgKCFyZXF1ZXN0LmZpbmQoKHIpID0+IHIudXJsID09PSB1cmwpKSB7XG4gICAgICAgIGlmICh1bmlxVXJscy5pbmRleE9mKHVybCkgPT09IC0xKSB7XG4gICAgICAgICAgdW5pcVVybHMucHVzaCh1cmwpO1xuICAgICAgICAgIHJlcXVlc3QucHVzaCh7IHVybCwgZmlsdGVyIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZU1hcChyZXF1ZXN0LCBwYXJhbXMpO1xuICB9XG4gIHN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZShyZWxheXMsIGZpbHRlciwgcGFyYW1zKTtcbiAgfVxuICBzdWJzY3JpYmVNYXAocmVxdWVzdHMsIHBhcmFtcykge1xuICAgIGNvbnN0IGdyb3VwZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgcmVxIG9mIHJlcXVlc3RzKSB7XG4gICAgICBjb25zdCB7IHVybCwgZmlsdGVyIH0gPSByZXE7XG4gICAgICBpZiAoIWdyb3VwZWQuaGFzKHVybCkpXG4gICAgICAgIGdyb3VwZWQuc2V0KHVybCwgW10pO1xuICAgICAgZ3JvdXBlZC5nZXQodXJsKS5wdXNoKGZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwZWRSZXF1ZXN0cyA9IEFycmF5LmZyb20oZ3JvdXBlZC5lbnRyaWVzKCkpLm1hcCgoW3VybCwgZmlsdGVyc10pID0+ICh7IHVybCwgZmlsdGVycyB9KSk7XG4gICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgIHBhcmFtcy5yZWNlaXZlZEV2ZW50ID0gKHJlbGF5LCBpZCkgPT4ge1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChpZCwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKHJlbGF5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9rbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3VicyA9IFtdO1xuICAgIGNvbnN0IGVvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlRW9zZSA9IChpMikgPT4ge1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWRbaTJdKVxuICAgICAgICByZXR1cm47XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gZ3JvdXBlZFJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZFtpMl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSBncm91cGVkUmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmNsb3NlPy4oY2xvc2VzUmVjZWl2ZWQpO1xuICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIgPSAoaWQpID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYWxyZWFkeUhhdmVFdmVudD8uKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhdmUgPSBfa25vd25JZHMuaGFzKGlkKTtcbiAgICAgIF9rbm93bklkcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIGhhdmU7XG4gICAgfTtcbiAgICBjb25zdCBhbGxPcGVuZWQgPSBQcm9taXNlLmFsbChcbiAgICAgIGdyb3VwZWRSZXF1ZXN0cy5tYXAoYXN5bmMgKHsgdXJsLCBmaWx0ZXJzIH0sIGkyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93Q29ubmVjdGluZ1RvUmVsYXk/Lih1cmwsIFtcInJlYWRcIiwgZmlsdGVyc10pID09PSBmYWxzZSkge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBcImNvbm5lY3Rpb24gc2tpcHBlZCBieSBhbGxvd0Nvbm5lY3RpbmdUb1JlbGF5XCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVsYXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVsYXkgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCwge1xuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHRoaXMubWF4V2FpdEZvckNvbm5lY3Rpb24gPCAocGFyYW1zLm1heFdhaXQgfHwgMCkgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdGhpcy5tYXhXYWl0Rm9yQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGFib3J0OiBwYXJhbXMuYWJvcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5vblJlbGF5Q29ubmVjdGlvbkZhaWx1cmU/Lih1cmwpO1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUmVsYXlDb25uZWN0aW9uU3VjY2Vzcz8uKHVybCk7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSByZWxheS5zdWJzY3JpYmUoZmlsdGVycywge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmIChyZWFzb24uc3RhcnRzV2l0aChcImF1dGgtcmVxdWlyZWQ6IFwiKSAmJiBwYXJhbXMub25hdXRoKSB7XG4gICAgICAgICAgICAgIHJlbGF5LmF1dGgocGFyYW1zLm9uYXV0aCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgICAgICAgICBvbmNsb3NlOiAocmVhc29uMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uMik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdCxcbiAgICAgICAgICAgICAgICAgIGFib3J0OiBwYXJhbXMuYWJvcnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBgYXV0aCB3YXMgcmVxdWlyZWQgYW5kIGF0dGVtcHRlZCwgYnV0IGZhaWxlZCB3aXRoOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0LFxuICAgICAgICAgIGFib3J0OiBwYXJhbXMuYWJvcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBjbG9zZShyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgYWxsT3BlbmVkO1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICAgIHN1Yi5jbG9zZShyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN1YnNjcmliZUVvc2UocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGxldCBzdWJjbG9zZXI7XG4gICAgc3ViY2xvc2VyID0gdGhpcy5zdWJzY3JpYmUocmVsYXlzLCBmaWx0ZXIsIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG9uZW9zZSgpIHtcbiAgICAgICAgY29uc3QgcmVhc29uID0gXCJjbG9zZWQgYXV0b21hdGljYWxseSBvbiBlb3NlXCI7XG4gICAgICAgIGlmIChzdWJjbG9zZXIpXG4gICAgICAgICAgc3ViY2xvc2VyLmNsb3NlKHJlYXNvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJhbXMub25jbG9zZT8uKHJlbGF5cy5tYXAoKF8pID0+IHJlYXNvbikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZUVvc2UocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpYmVFb3NlKHJlbGF5cywgZmlsdGVyLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgb25ldmVudChldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbG9zZShfKSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGZpbHRlci5saW1pdCA9IDE7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5xdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgcmV0dXJuIGV2ZW50c1swXSB8fCBudWxsO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5tYXAoYXN5bmMgKHVybCwgaTIsIGFycikgPT4ge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHVybCkgIT09IGkyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hbGxvd0Nvbm5lY3RpbmdUb1JlbGF5Py4odXJsLCBbXCJ3cml0ZVwiLCBldmVudF0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJjb25uZWN0aW9uIHNraXBwZWQgYnkgYWxsb3dDb25uZWN0aW5nVG9SZWxheVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHRoaXMubWF4V2FpdEZvckNvbm5lY3Rpb24gPCAocGFyYW1zPy5tYXhXYWl0IHx8IDApID8gTWF0aC5tYXgocGFyYW1zLm1heFdhaXQgKiAwLjgsIHBhcmFtcy5tYXhXYWl0IC0gMWUzKSA6IHRoaXMubWF4V2FpdEZvckNvbm5lY3Rpb24sXG4gICAgICAgICAgYWJvcnQ6IHBhcmFtcz8uYWJvcnRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5vblJlbGF5Q29ubmVjdGlvbkZhaWx1cmU/Lih1cmwpO1xuICAgICAgICByZXR1cm4gU3RyaW5nKFwiY29ubmVjdGlvbiBmYWlsdXJlOiBcIiArIFN0cmluZyhlcnIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLnB1Ymxpc2goZXZlbnQpLmNhdGNoKGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJhdXRoLXJlcXVpcmVkOiBcIikgJiYgcGFyYW1zPy5vbmF1dGgpIHtcbiAgICAgICAgICBhd2FpdCByLmF1dGgocGFyYW1zLm9uYXV0aCk7XG4gICAgICAgICAgcmV0dXJuIHIucHVibGlzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSkudGhlbigocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChldmVudC5pZCk7XG4gICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoZXZlbnQuaWQsIHNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldC5hZGQocik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYXNvbjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGxpc3RDb25uZWN0aW9uU3RhdHVzKCkge1xuICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWxheXMuZm9yRWFjaCgocmVsYXksIHVybCkgPT4gbWFwLnNldCh1cmwsIHJlbGF5LmNvbm5lY3RlZCkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbGF5cy5mb3JFYWNoKChjb25uKSA9PiBjb25uLmNsb3NlKCkpO1xuICAgIHRoaXMucmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBwcnVuZUlkbGVSZWxheXMoaWRsZVRocmVzaG9sZE1zID0gMWU0KSB7XG4gICAgY29uc3QgcHJ1bmVkVXJscyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3VybCwgcmVsYXldIG9mIHRoaXMucmVsYXlzKSB7XG4gICAgICBpZiAocmVsYXkuaWRsZVNpbmNlICYmIERhdGUubm93KCkgLSByZWxheS5pZGxlU2luY2UgPj0gaWRsZVRocmVzaG9sZE1zKSB7XG4gICAgICAgIHRoaXMucmVsYXlzLmRlbGV0ZSh1cmwpO1xuICAgICAgICBwcnVuZWRVcmxzLnB1c2godXJsKTtcbiAgICAgICAgcmVsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBydW5lZFVybHM7XG4gIH1cbn07XG5cbi8vIHBvb2wudHNcbnZhciBfV2ViU29ja2V0MjtcbnRyeSB7XG4gIF9XZWJTb2NrZXQyID0gV2ViU29ja2V0O1xufSBjYXRjaCB7XG59XG52YXIgU2ltcGxlUG9vbCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTaW1wbGVQb29sIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0MiwgbWF4V2FpdEZvckNvbm5lY3Rpb246IDNlMywgLi4ub3B0aW9ucyB9KTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBCZWNoMzJNYXhTaXplOiAoKSA9PiBCZWNoMzJNYXhTaXplLFxuICBOb3N0clR5cGVHdWFyZDogKCkgPT4gTm9zdHJUeXBlR3VhcmQsXG4gIGRlY29kZTogKCkgPT4gZGVjb2RlLFxuICBkZWNvZGVOb3N0clVSSTogKCkgPT4gZGVjb2RlTm9zdHJVUkksXG4gIGVuY29kZUJ5dGVzOiAoKSA9PiBlbmNvZGVCeXRlcyxcbiAgbmFkZHJFbmNvZGU6ICgpID0+IG5hZGRyRW5jb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBuc2VjRW5jb2RlXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDMsIGNvbmNhdEJ5dGVzLCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXMzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIE5vc3RyVHlwZUd1YXJkID0ge1xuICBpc05Qcm9maWxlOiAodmFsdWUpID0+IC9ebnByb2ZpbGUxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNORXZlbnQ6ICh2YWx1ZSkgPT4gL15uZXZlbnQxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOQWRkcjogKHZhbHVlKSA9PiAvXm5hZGRyMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlNlYzogKHZhbHVlKSA9PiAvXm5zZWMxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOUHViOiAodmFsdWUpID0+IC9ebnB1YjFbYS16XFxkXXs1OH0kLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05vdGU6ICh2YWx1ZSkgPT4gL15ub3RlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTmNyeXB0c2VjOiAodmFsdWUpID0+IC9ebmNyeXB0c2VjMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIilcbn07XG52YXIgQmVjaDMyTWF4U2l6ZSA9IDVlMztcbnZhciBCRUNIMzJfUkVHRVggPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBpbnRlZ2VyVG9VaW50OEFycmF5KG51bWJlcikge1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIHVpbnQ4QXJyYXlbMF0gPSBudW1iZXIgPj4gMjQgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMV0gPSBudW1iZXIgPj4gMTYgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMl0gPSBudW1iZXIgPj4gOCAmIDI1NTtcbiAgdWludDhBcnJheVszXSA9IG51bWJlciAmIDI1NTtcbiAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBkZWNvZGVOb3N0clVSSShuaXAxOWNvZGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmlwMTljb2RlLnN0YXJ0c1dpdGgoXCJub3N0cjpcIikpXG4gICAgICBuaXAxOWNvZGUgPSBuaXAxOWNvZGUuc3Vic3RyaW5nKDYpO1xuICAgIHJldHVybiBkZWNvZGUobmlwMTljb2RlKTtcbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW52YWxpZFwiLCBkYXRhOiBudWxsIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZShjb2RlKSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUoY29kZSwgQmVjaDMyTWF4U2l6ZSk7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYmVjaDMyLmZyb21Xb3Jkcyh3b3JkcykpO1xuICBzd2l0Y2ggKHByZWZpeCkge1xuICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBucHJvZmlsZVwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucHJvZmlsZVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHVia2V5OiBieXRlc1RvSGV4Myh0bHZbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmV2ZW50XCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzJdICYmIHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzNdICYmIHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuZXZlbnRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBieXRlc1RvSGV4Myh0bHZbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdLFxuICAgICAgICAgIGF1dGhvcjogdGx2WzJdPy5bMF0gPyBieXRlc1RvSGV4Myh0bHZbMl1bMF0pIDogdm9pZCAwLFxuICAgICAgICAgIGtpbmQ6IHRsdlszXT8uWzBdID8gcGFyc2VJbnQoYnl0ZXNUb0hleDModGx2WzNdWzBdKSwgMTYpIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICghdGx2WzJdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDIgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAoIXRsdlszXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAzIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmFkZHJcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aWZpZXI6IHV0ZjhEZWNvZGVyLmRlY29kZSh0bHZbMF1bMF0pLFxuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDModGx2WzJdWzBdKSxcbiAgICAgICAgICBraW5kOiBwYXJzZUludChieXRlc1RvSGV4Myh0bHZbM11bMF0pLCAxNiksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5zZWNcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IHByZWZpeCwgZGF0YSB9O1xuICAgIGNhc2UgXCJucHViXCI6XG4gICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IHByZWZpeCwgZGF0YTogYnl0ZXNUb0hleDMoZGF0YSkgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByZWZpeCAke3ByZWZpeH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUTFYoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCByZXN0ID0gZGF0YTtcbiAgd2hpbGUgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIGxldCB0ID0gcmVzdFswXTtcbiAgICBsZXQgbCA9IHJlc3RbMV07XG4gICAgbGV0IHYgPSByZXN0LnNsaWNlKDIsIDIgKyBsKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgyICsgbCk7XG4gICAgaWYgKHYubGVuZ3RoIDwgbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IGVub3VnaCBkYXRhIHRvIHJlYWQgb24gVExWICR7dH1gKTtcbiAgICByZXN1bHRbdF0gPSByZXN1bHRbdF0gfHwgW107XG4gICAgcmVzdWx0W3RdLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5zZWNFbmNvZGUoa2V5KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5zZWNcIiwga2V5KTtcbn1cbmZ1bmN0aW9uIG5wdWJFbmNvZGUoaGV4KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5wdWJcIiwgaGV4VG9CeXRlczMoaGV4KSk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleFRvQnl0ZXMzKGhleCkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQmVjaDMyKHByZWZpeCwgZGF0YSkge1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIocHJlZml4LCBieXRlcyk7XG59XG5mdW5jdGlvbiBucHJvZmlsZUVuY29kZShwcm9maWxlKSB7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlczMocHJvZmlsZS5wdWJrZXkpXSxcbiAgICAxOiAocHJvZmlsZS5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSlcbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJucHJvZmlsZVwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5ldmVudEVuY29kZShldmVudCkge1xuICBsZXQga2luZEFycmF5O1xuICBpZiAoZXZlbnQua2luZCAhPT0gdm9pZCAwKSB7XG4gICAga2luZEFycmF5ID0gaW50ZWdlclRvVWludDhBcnJheShldmVudC5raW5kKTtcbiAgfVxuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW2hleFRvQnl0ZXMzKGV2ZW50LmlkKV0sXG4gICAgMTogKGV2ZW50LnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBldmVudC5hdXRob3IgPyBbaGV4VG9CeXRlczMoZXZlbnQuYXV0aG9yKV0gOiBbXSxcbiAgICAzOiBraW5kQXJyYXkgPyBbbmV3IFVpbnQ4QXJyYXkoa2luZEFycmF5KV0gOiBbXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5ldmVudFwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5hZGRyRW5jb2RlKGFkZHIpIHtcbiAgbGV0IGtpbmQgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIG5ldyBEYXRhVmlldyhraW5kKS5zZXRVaW50MzIoMCwgYWRkci5raW5kLCBmYWxzZSk7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbdXRmOEVuY29kZXIuZW5jb2RlKGFkZHIuaWRlbnRpZmllcildLFxuICAgIDE6IChhZGRyLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBbaGV4VG9CeXRlczMoYWRkci5wdWJrZXkpXSxcbiAgICAzOiBbbmV3IFVpbnQ4QXJyYXkoa2luZCldXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmFkZHJcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGVUTFYodGx2KSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIE9iamVjdC5lbnRyaWVzKHRsdikucmV2ZXJzZSgpLmZvckVhY2goKFt0LCB2c10pID0+IHtcbiAgICB2cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSBuZXcgVWludDhBcnJheSh2Lmxlbmd0aCArIDIpO1xuICAgICAgZW50cnkuc2V0KFtwYXJzZUludCh0KV0sIDApO1xuICAgICAgZW50cnkuc2V0KFt2Lmxlbmd0aF0sIDEpO1xuICAgICAgZW50cnkuc2V0KHYsIDIpO1xuICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBjb25jYXRCeXRlcyguLi5lbnRyaWVzKTtcbn1cblxuLy8gcmVmZXJlbmNlcy50c1xudmFyIG1lbnRpb25SZWdleCA9IC9cXGJub3N0cjooKG5vdGV8bnB1YnxuYWRkcnxuZXZlbnR8bnByb2ZpbGUpMVxcdyspXFxifCNcXFsoXFxkKylcXF0vZztcbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlcyhldnQpIHtcbiAgbGV0IHJlZmVyZW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGV2dC5jb250ZW50Lm1hdGNoQWxsKG1lbnRpb25SZWdleCkpIHtcbiAgICBpZiAocmVmWzJdKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyB0eXBlLCBkYXRhIH0gPSBkZWNvZGUocmVmWzFdKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibm90ZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiB7IGlkOiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmWzNdKSB7XG4gICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocmVmWzNdLCAxMCk7XG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZ3NbaWR4XTtcbiAgICAgIGlmICghdGFnKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgIGNhc2UgXCJwXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZVwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIGV2ZW50OiB7IGlkOiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAga2luZDogcGFyc2VJbnQoa2luZCwgMTApLFxuICAgICAgICAgICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbi8vIG5pcDA0LnRzXG52YXIgbmlwMDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0LFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0XG59KTtcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczQsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qc1wiO1xuaW1wb3J0IHsgY2JjIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL2Flcy5qc1wiO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5mdW5jdGlvbiBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCB0ZXh0KSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gc2VjcmV0S2V5IDogaGV4VG9CeXRlczQoc2VjcmV0S2V5KTtcbiAgY29uc3Qga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBoZXhUb0J5dGVzNChcIjAyXCIgKyBwdWJrZXkpKTtcbiAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcygxNikpO1xuICBsZXQgcGxhaW50ZXh0ID0gdXRmOEVuY29kZXIuZW5jb2RlKHRleHQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZW5jcnlwdChwbGFpbnRleHQpO1xuICBsZXQgY3RiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShpdi5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2N0YjY0fT9pdj0ke2l2YjY0fWA7XG59XG5mdW5jdGlvbiBkZWNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBkYXRhKSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gc2VjcmV0S2V5IDogaGV4VG9CeXRlczQoc2VjcmV0S2V5KTtcbiAgbGV0IFtjdGI2NCwgaXZiNjRdID0gZGF0YS5zcGxpdChcIj9pdj1cIik7XG4gIGxldCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIGhleFRvQnl0ZXM0KFwiMDJcIiArIHB1YmtleSkpO1xuICBsZXQgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IGJhc2U2NC5kZWNvZGUoaXZiNjQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGJhc2U2NC5kZWNvZGUoY3RiNjQpO1xuICBsZXQgcGxhaW50ZXh0ID0gY2JjKG5vcm1hbGl6ZWRLZXksIGl2KS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHBsYWludGV4dCk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkWChrZXkpIHtcbiAgcmV0dXJuIGtleS5zbGljZSgxLCAzMyk7XG59XG5cbi8vIG5pcDA1LnRzXG52YXIgbmlwMDVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDVfZXhwb3J0cywge1xuICBOSVAwNV9SRUdFWDogKCkgPT4gTklQMDVfUkVHRVgsXG4gIGlzTmlwMDU6ICgpID0+IGlzTmlwMDUsXG4gIGlzVmFsaWQ6ICgpID0+IGlzVmFsaWQsXG4gIHF1ZXJ5UHJvZmlsZTogKCkgPT4gcXVlcnlQcm9maWxlLFxuICBzZWFyY2hEb21haW46ICgpID0+IHNlYXJjaERvbWFpbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvblxufSk7XG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHdfLV0rKFxcLltcXHdfLV0rKSspJC87XG52YXIgaXNOaXAwNSA9ICh2YWx1ZSkgPT4gTklQMDVfUkVHRVgudGVzdCh2YWx1ZSB8fCBcIlwiKTtcbnZhciBfZmV0Y2g7XG50cnkge1xuICBfZmV0Y2ggPSBmZXRjaDtcbn0gY2F0Y2ggKF8pIHtcbiAgbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24oZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2ggPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VhcmNoRG9tYWluKGRvbWFpbiwgcXVlcnkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke3F1ZXJ5fWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBqc29uLm5hbWVzO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeVByb2ZpbGUoZnVsbG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBmdWxsbmFtZS5tYXRjaChOSVAwNV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFssIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGpzb24ubmFtZXNbbmFtZV07XG4gICAgcmV0dXJuIHB1YmtleSA/IHsgcHVia2V5LCByZWxheXM6IGpzb24ucmVsYXlzPy5bcHVia2V5XSB9IDogbnVsbDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZChwdWJrZXksIG5pcDA1KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHF1ZXJ5UHJvZmlsZShuaXAwNSk7XG4gIHJldHVybiByZXMgPyByZXMucHVia2V5ID09PSBwdWJrZXkgOiBmYWxzZTtcbn1cblxuLy8gbmlwMTAudHNcbnZhciBuaXAxMF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMF9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZVxufSk7XG5mdW5jdGlvbiBwYXJzZShldmVudCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmVwbHk6IHZvaWQgMCxcbiAgICByb290OiB2b2lkIDAsXG4gICAgbWVudGlvbnM6IFtdLFxuICAgIHByb2ZpbGVzOiBbXSxcbiAgICBxdW90ZXM6IFtdXG4gIH07XG4gIGxldCBtYXliZVBhcmVudDtcbiAgbGV0IG1heWJlUm9vdDtcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsLCBlVGFnTWFya2VyLCBlVGFnQXV0aG9yXSA9IHRhZztcbiAgICAgIGNvbnN0IGV2ZW50UG9pbnRlciA9IHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW10sXG4gICAgICAgIGF1dGhvcjogZVRhZ0F1dGhvclxuICAgICAgfTtcbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJvb3RcIikge1xuICAgICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyZXBseVwiKSB7XG4gICAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJtZW50aW9uXCIpIHtcbiAgICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1heWJlUGFyZW50KSB7XG4gICAgICAgIG1heWJlUGFyZW50ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5YmVSb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInFcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsXSA9IHRhZztcbiAgICAgIHJlc3VsdC5xdW90ZXMucHVzaCh7XG4gICAgICAgIGlkOiBlVGFnRXZlbnRJZCxcbiAgICAgICAgcmVsYXlzOiBlVGFnUmVsYXlVcmwgPyBbZVRhZ1JlbGF5VXJsXSA6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgdGFnWzFdKSB7XG4gICAgICByZXN1bHQucHJvZmlsZXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogdGFnWzFdLFxuICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmICghcmVzdWx0LnJvb3QpIHtcbiAgICByZXN1bHQucm9vdCA9IG1heWJlUm9vdCB8fCBtYXliZVBhcmVudCB8fCByZXN1bHQucmVwbHk7XG4gIH1cbiAgaWYgKCFyZXN1bHQucmVwbHkpIHtcbiAgICByZXN1bHQucmVwbHkgPSBtYXliZVBhcmVudCB8fCByZXN1bHQucm9vdDtcbiAgfVxuICA7XG4gIFtyZXN1bHQucmVwbHksIHJlc3VsdC5yb290XS5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgaWR4ID0gcmVzdWx0Lm1lbnRpb25zLmluZGV4T2YocmVmKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgcmVzdWx0Lm1lbnRpb25zLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXM/LmluZGV4T2YodXJsKSA9PT0gLTEpXG4gICAgICAgICAgICByZWYucmVsYXlzLnB1c2godXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF1dGhvci5yZWxheXMgPSByZWYucmVsYXlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5tZW50aW9ucy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXMuaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gbmlwMTEudHNcbnZhciBuaXAxMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMV9leHBvcnRzLCB7XG4gIGZldGNoUmVsYXlJbmZvcm1hdGlvbjogKCkgPT4gZmV0Y2hSZWxheUluZm9ybWF0aW9uLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMlxufSk7XG52YXIgX2ZldGNoMjtcbnRyeSB7XG4gIF9mZXRjaDIgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gyID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVsYXlJbmZvcm1hdGlvbih1cmwpIHtcbiAgcmV0dXJuIGF3YWl0IChhd2FpdCBmZXRjaCh1cmwucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIiksIHtcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9ub3N0citqc29uXCIgfVxuICB9KSkuanNvbigpO1xufVxuXG4vLyBuaXAxMy50c1xudmFyIG5pcDEzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEzX2V4cG9ydHMsIHtcbiAgZ2V0UG93OiAoKSA9PiBnZXRQb3csXG4gIG1pbmVQb3c6ICgpID0+IG1pbmVQb3dcbn0pO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTIuanNcIjtcbmZ1bmN0aW9uIGdldFBvdyhoZXgpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IDY0OyBpMiArPSA4KSB7XG4gICAgY29uc3QgbmliYmxlID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpMiwgaTIgKyA4KSwgMTYpO1xuICAgIGlmIChuaWJibGUgPT09IDApIHtcbiAgICAgIGNvdW50ICs9IDMyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBNYXRoLmNsejMyKG5pYmJsZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0UG93RnJvbUJ5dGVzKGhhc2gpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGhhc2gubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3QgYnl0ZSA9IGhhc2hbaTJdO1xuICAgIGlmIChieXRlID09PSAwKSB7XG4gICAgICBjb3VudCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBNYXRoLmNsejMyKGJ5dGUpIC0gMjQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gbWluZVBvdyh1bnNpZ25lZCwgZGlmZmljdWx0eSkge1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBldmVudCA9IHVuc2lnbmVkO1xuICBjb25zdCB0YWcgPSBbXCJub25jZVwiLCBjb3VudC50b1N0cmluZygpLCBkaWZmaWN1bHR5LnRvU3RyaW5nKCldO1xuICBldmVudC50YWdzLnB1c2godGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBub3cyID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMyk7XG4gICAgaWYgKG5vdzIgIT09IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIGV2ZW50LmNyZWF0ZWRfYXQgPSBub3cyO1xuICAgIH1cbiAgICB0YWdbMV0gPSAoKytjb3VudCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBoYXNoID0gc2hhMjU2MihcbiAgICAgIHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShbMCwgZXZlbnQucHVia2V5LCBldmVudC5jcmVhdGVkX2F0LCBldmVudC5raW5kLCBldmVudC50YWdzLCBldmVudC5jb250ZW50XSkpXG4gICAgKTtcbiAgICBpZiAoZ2V0UG93RnJvbUJ5dGVzKGhhc2gpID49IGRpZmZpY3VsdHkpIHtcbiAgICAgIGV2ZW50LmlkID0gYnl0ZXNUb0hleDQoaGFzaCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBuaXAxNy50c1xudmFyIG5pcDE3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE3X2V4cG9ydHMsIHtcbiAgdW53cmFwRXZlbnQ6ICgpID0+IHVud3JhcEV2ZW50MixcbiAgdW53cmFwTWFueUV2ZW50czogKCkgPT4gdW53cmFwTWFueUV2ZW50czIsXG4gIHdyYXBFdmVudDogKCkgPT4gd3JhcEV2ZW50MixcbiAgd3JhcE1hbnlFdmVudHM6ICgpID0+IHdyYXBNYW55RXZlbnRzMlxufSk7XG5cbi8vIG5pcDU5LnRzXG52YXIgbmlwNTlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTlfZXhwb3J0cywge1xuICBjcmVhdGVSdW1vcjogKCkgPT4gY3JlYXRlUnVtb3IsXG4gIGNyZWF0ZVNlYWw6ICgpID0+IGNyZWF0ZVNlYWwsXG4gIGNyZWF0ZVdyYXA6ICgpID0+IGNyZWF0ZVdyYXAsXG4gIHVud3JhcEV2ZW50OiAoKSA9PiB1bndyYXBFdmVudCxcbiAgdW53cmFwTWFueUV2ZW50czogKCkgPT4gdW53cmFwTWFueUV2ZW50cyxcbiAgd3JhcEV2ZW50OiAoKSA9PiB3cmFwRXZlbnQsXG4gIHdyYXBNYW55RXZlbnRzOiAoKSA9PiB3cmFwTWFueUV2ZW50c1xufSk7XG5cbi8vIG5pcDQ0LnRzXG52YXIgbmlwNDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0MixcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdDIsXG4gIGdldENvbnZlcnNhdGlvbktleTogKCkgPT4gZ2V0Q29udmVyc2F0aW9uS2V5LFxuICB2MjogKCkgPT4gdjJcbn0pO1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhLmpzXCI7XG5pbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcDI1NmsxMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qc1wiO1xuaW1wb3J0IHsgZXh0cmFjdCBhcyBoa2RmX2V4dHJhY3QsIGV4cGFuZCBhcyBoa2RmX2V4cGFuZCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2hrZGYuanNcIjtcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjLmpzXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTIuanNcIjtcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEJ5dGVzMiwgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzNSwgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgbWluUGxhaW50ZXh0U2l6ZSA9IDE7XG52YXIgbWF4UGxhaW50ZXh0U2l6ZSA9IDY1NTM1O1xuZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uS2V5KHByaXZrZXlBLCBwdWJrZXlCKSB7XG4gIGNvbnN0IHNoYXJlZFggPSBzZWNwMjU2azEyLmdldFNoYXJlZFNlY3JldChwcml2a2V5QSwgaGV4VG9CeXRlczUoXCIwMlwiICsgcHVia2V5QikpLnN1YmFycmF5KDEsIDMzKTtcbiAgcmV0dXJuIGhrZGZfZXh0cmFjdChzaGEyNTYzLCBzaGFyZWRYLCB1dGY4RW5jb2Rlci5lbmNvZGUoXCJuaXA0NC12MlwiKSk7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKSB7XG4gIGNvbnN0IGtleXMgPSBoa2RmX2V4cGFuZChzaGEyNTYzLCBjb252ZXJzYXRpb25LZXksIG5vbmNlLCA3Nik7XG4gIHJldHVybiB7XG4gICAgY2hhY2hhX2tleToga2V5cy5zdWJhcnJheSgwLCAzMiksXG4gICAgY2hhY2hhX25vbmNlOiBrZXlzLnN1YmFycmF5KDMyLCA0NCksXG4gICAgaG1hY19rZXk6IGtleXMuc3ViYXJyYXkoNDQsIDc2KVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1BhZGRlZExlbihsZW4pIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihsZW4pIHx8IGxlbiA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKGxlbiA8PSAzMilcbiAgICByZXR1cm4gMzI7XG4gIGNvbnN0IG5leHRQb3dlciA9IDEgPDwgTWF0aC5mbG9vcihNYXRoLmxvZzIobGVuIC0gMSkpICsgMTtcbiAgY29uc3QgY2h1bmsgPSBuZXh0UG93ZXIgPD0gMjU2ID8gMzIgOiBuZXh0UG93ZXIgLyA4O1xuICByZXR1cm4gY2h1bmsgKiAoTWF0aC5mbG9vcigobGVuIC0gMSkgLyBjaHVuaykgKyAxKTtcbn1cbmZ1bmN0aW9uIHdyaXRlVTE2QkUobnVtKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSB8fCBudW0gPCBtaW5QbGFpbnRleHRTaXplIHx8IG51bSA+IG1heFBsYWludGV4dFNpemUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZTogbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDY1NTM1IGJ5dGVzXCIpO1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgbmV3IERhdGFWaWV3KGFyci5idWZmZXIpLnNldFVpbnQxNigwLCBudW0sIGZhbHNlKTtcbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHBhZChwbGFpbnRleHQpIHtcbiAgY29uc3QgdW5wYWRkZWQgPSB1dGY4RW5jb2Rlci5lbmNvZGUocGxhaW50ZXh0KTtcbiAgY29uc3QgdW5wYWRkZWRMZW4gPSB1bnBhZGRlZC5sZW5ndGg7XG4gIGNvbnN0IHByZWZpeCA9IHdyaXRlVTE2QkUodW5wYWRkZWRMZW4pO1xuICBjb25zdCBzdWZmaXggPSBuZXcgVWludDhBcnJheShjYWxjUGFkZGVkTGVuKHVucGFkZGVkTGVuKSAtIHVucGFkZGVkTGVuKTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzMihwcmVmaXgsIHVucGFkZGVkLCBzdWZmaXgpO1xufVxuZnVuY3Rpb24gdW5wYWQocGFkZGVkKSB7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gbmV3IERhdGFWaWV3KHBhZGRlZC5idWZmZXIpLmdldFVpbnQxNigwKTtcbiAgY29uc3QgdW5wYWRkZWQgPSBwYWRkZWQuc3ViYXJyYXkoMiwgMiArIHVucGFkZGVkTGVuKTtcbiAgaWYgKHVucGFkZGVkTGVuIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZExlbiA+IG1heFBsYWludGV4dFNpemUgfHwgdW5wYWRkZWQubGVuZ3RoICE9PSB1bnBhZGRlZExlbiB8fCBwYWRkZWQubGVuZ3RoICE9PSAyICsgY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYWRkaW5nXCIpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHVucGFkZGVkKTtcbn1cbmZ1bmN0aW9uIGhtYWNBYWQoa2V5LCBtZXNzYWdlLCBhYWQpIHtcbiAgaWYgKGFhZC5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFBRCBhc3NvY2lhdGVkIGRhdGEgbXVzdCBiZSAzMiBieXRlc1wiKTtcbiAgY29uc3QgY29tYmluZWQgPSBjb25jYXRCeXRlczIoYWFkLCBtZXNzYWdlKTtcbiAgcmV0dXJuIGhtYWMoc2hhMjU2Mywga2V5LCBjb21iaW5lZCk7XG59XG5mdW5jdGlvbiBkZWNvZGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkICE9PSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBheWxvYWQgbXVzdCBiZSBhIHZhbGlkIHN0cmluZ1wiKTtcbiAgY29uc3QgcGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBpZiAocGxlbiA8IDEzMiB8fCBwbGVuID4gODc0NzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXlsb2FkIGxlbmd0aDogXCIgKyBwbGVuKTtcbiAgaWYgKHBheWxvYWRbMF0gPT09IFwiI1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uXCIpO1xuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYmFzZTY0Mi5kZWNvZGUocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiYXNlNjQ6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgZGxlbiA9IGRhdGEubGVuZ3RoO1xuICBpZiAoZGxlbiA8IDk5IHx8IGRsZW4gPiA2NTYwMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoOiBcIiArIGRsZW4pO1xuICBjb25zdCB2ZXJzID0gZGF0YVswXTtcbiAgaWYgKHZlcnMgIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb24gXCIgKyB2ZXJzKTtcbiAgcmV0dXJuIHtcbiAgICBub25jZTogZGF0YS5zdWJhcnJheSgxLCAzMyksXG4gICAgY2lwaGVydGV4dDogZGF0YS5zdWJhcnJheSgzMywgLTMyKSxcbiAgICBtYWM6IGRhdGEuc3ViYXJyYXkoLTMyKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jcnlwdDIocGxhaW50ZXh0LCBjb252ZXJzYXRpb25LZXksIG5vbmNlID0gcmFuZG9tQnl0ZXMyKDMyKSkge1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBwYWRkZWQgPSBwYWQocGxhaW50ZXh0KTtcbiAgY29uc3QgY2lwaGVydGV4dCA9IGNoYWNoYTIwKGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgcGFkZGVkKTtcbiAgY29uc3QgbWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICByZXR1cm4gYmFzZTY0Mi5lbmNvZGUoY29uY2F0Qnl0ZXMyKG5ldyBVaW50OEFycmF5KFsyXSksIG5vbmNlLCBjaXBoZXJ0ZXh0LCBtYWMpKTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHQyKHBheWxvYWQsIGNvbnZlcnNhdGlvbktleSkge1xuICBjb25zdCB7IG5vbmNlLCBjaXBoZXJ0ZXh0LCBtYWMgfSA9IGRlY29kZVBheWxvYWQocGF5bG9hZCk7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSk7XG4gIGNvbnN0IGNhbGN1bGF0ZWRNYWMgPSBobWFjQWFkKGhtYWNfa2V5LCBjaXBoZXJ0ZXh0LCBub25jZSk7XG4gIGlmICghZXF1YWxCeXRlcyhjYWxjdWxhdGVkTWFjLCBtYWMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTUFDXCIpO1xuICBjb25zdCBwYWRkZWQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGNpcGhlcnRleHQpO1xuICByZXR1cm4gdW5wYWQocGFkZGVkKTtcbn1cbnZhciB2MiA9IHtcbiAgdXRpbHM6IHtcbiAgICBnZXRDb252ZXJzYXRpb25LZXksXG4gICAgY2FsY1BhZGRlZExlblxuICB9LFxuICBlbmNyeXB0OiBlbmNyeXB0MixcbiAgZGVjcnlwdDogZGVjcnlwdDJcbn07XG5cbi8vIG5pcDU5LnRzXG52YXIgVFdPX0RBWVMgPSAyICogMjQgKiA2MCAqIDYwO1xudmFyIG5vdyA9ICgpID0+IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG52YXIgcmFuZG9tTm93ID0gKCkgPT4gTWF0aC5yb3VuZChub3coKSAtIE1hdGgucmFuZG9tKCkgKiBUV09fREFZUyk7XG52YXIgbmlwNDRDb252ZXJzYXRpb25LZXkgPSAocHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcbnZhciBuaXA0NEVuY3J5cHQgPSAoZGF0YSwgcHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBlbmNyeXB0MihKU09OLnN0cmluZ2lmeShkYXRhKSwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KSk7XG52YXIgbmlwNDREZWNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXkpID0+IEpTT04ucGFyc2UoZGVjcnlwdDIoZGF0YS5jb250ZW50LCBuaXA0NENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBkYXRhLnB1YmtleSkpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bW9yKGV2ZW50LCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0ge1xuICAgIGNyZWF0ZWRfYXQ6IG5vdygpLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgLi4uZXZlbnQsXG4gICAgcHVia2V5OiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSlcbiAgfTtcbiAgcnVtb3IuaWQgPSBnZXRFdmVudEhhc2gocnVtb3IpO1xuICByZXR1cm4gcnVtb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWFsKHJ1bW9yLCBwcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogU2VhbCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW11cbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJhbmRvbUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IEdpZnRXcmFwLFxuICAgICAgY29udGVudDogbmlwNDRFbmNyeXB0KHNlYWwsIHJhbmRvbUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVjaXBpZW50UHVibGljS2V5XV1cbiAgICB9LFxuICAgIHJhbmRvbUtleVxuICApO1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgY29uc3QgcnVtb3IgPSBjcmVhdGVSdW1vcihldmVudCwgc2VuZGVyUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHNlYWwgPSBjcmVhdGVTZWFsKHJ1bW9yLCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpO1xuICByZXR1cm4gY3JlYXRlV3JhcChzZWFsLCByZWNpcGllbnRQdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHNQdWJsaWNLZXlzKSB7XG4gIGlmICghcmVjaXBpZW50c1B1YmxpY0tleXMgfHwgcmVjaXBpZW50c1B1YmxpY0tleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCB3cmFwcGVkcyA9IFt3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHNlbmRlclB1YmxpY0tleSldO1xuICByZWNpcGllbnRzUHVibGljS2V5cy5mb3JFYWNoKChyZWNpcGllbnRQdWJsaWNLZXkpID0+IHtcbiAgICB3cmFwcGVkcy5wdXNoKHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSk7XG4gIH0pO1xuICByZXR1cm4gd3JhcHBlZHM7XG59XG5mdW5jdGlvbiB1bndyYXBFdmVudCh3cmFwLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGNvbnN0IHVud3JhcHBlZFNlYWwgPSBuaXA0NERlY3J5cHQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG4gIHJldHVybiBuaXA0NERlY3J5cHQodW53cmFwcGVkU2VhbCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiB1bndyYXBNYW55RXZlbnRzKHdyYXBwZWRFdmVudHMsIHJlY2lwaWVudFByaXZhdGVLZXkpIHtcbiAgbGV0IHVud3JhcHBlZEV2ZW50cyA9IFtdO1xuICB3cmFwcGVkRXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICB1bndyYXBwZWRFdmVudHMucHVzaCh1bndyYXBFdmVudChlLCByZWNpcGllbnRQcml2YXRlS2V5KSk7XG4gIH0pO1xuICB1bndyYXBwZWRFdmVudHMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KTtcbiAgcmV0dXJuIHVud3JhcHBlZEV2ZW50cztcbn1cblxuLy8gbmlwMTcudHNcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHJlY2lwaWVudHMsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGNvbnN0IGJhc2VFdmVudCA9IHtcbiAgICBjcmVhdGVkX2F0OiBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAga2luZDogUHJpdmF0ZURpcmVjdE1lc3NhZ2UsXG4gICAgdGFnczogW10sXG4gICAgY29udGVudDogbWVzc2FnZVxuICB9O1xuICBjb25zdCByZWNpcGllbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpID8gcmVjaXBpZW50cyA6IFtyZWNpcGllbnRzXTtcbiAgcmVjaXBpZW50c0FycmF5LmZvckVhY2goKHsgcHVibGljS2V5LCByZWxheVVybCB9KSA9PiB7XG4gICAgYmFzZUV2ZW50LnRhZ3MucHVzaChyZWxheVVybCA/IFtcInBcIiwgcHVibGljS2V5LCByZWxheVVybF0gOiBbXCJwXCIsIHB1YmxpY0tleV0pO1xuICB9KTtcbiAgaWYgKHJlcGx5VG8pIHtcbiAgICBiYXNlRXZlbnQudGFncy5wdXNoKFtcImVcIiwgcmVwbHlUby5ldmVudElkLCByZXBseVRvLnJlbGF5VXJsIHx8IFwiXCIsIFwicmVwbHlcIl0pO1xuICB9XG4gIGlmIChjb252ZXJzYXRpb25UaXRsZSkge1xuICAgIGJhc2VFdmVudC50YWdzLnB1c2goW1wic3ViamVjdFwiLCBjb252ZXJzYXRpb25UaXRsZV0pO1xuICB9XG4gIHJldHVybiBiYXNlRXZlbnQ7XG59XG5mdW5jdGlvbiB3cmFwRXZlbnQyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudCwgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pIHtcbiAgY29uc3QgZXZlbnQgPSBjcmVhdGVFdmVudChyZWNpcGllbnQsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKTtcbiAgcmV0dXJuIHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50LnB1YmxpY0tleSk7XG59XG5mdW5jdGlvbiB3cmFwTWFueUV2ZW50czIoc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50cywgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pIHtcbiAgaWYgKCFyZWNpcGllbnRzIHx8IHJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICByZXR1cm4gW3sgcHVibGljS2V5OiBzZW5kZXJQdWJsaWNLZXkgfSwgLi4ucmVjaXBpZW50c10ubWFwKFxuICAgIChyZWNpcGllbnQpID0+IHdyYXBFdmVudDIoc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50LCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbylcbiAgKTtcbn1cbnZhciB1bndyYXBFdmVudDIgPSB1bndyYXBFdmVudDtcbnZhciB1bndyYXBNYW55RXZlbnRzMiA9IHVud3JhcE1hbnlFdmVudHM7XG5cbi8vIG5pcDE4LnRzXG52YXIgbmlwMThfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMThfZXhwb3J0cywge1xuICBmaW5pc2hSZXBvc3RFdmVudDogKCkgPT4gZmluaXNoUmVwb3N0RXZlbnQsXG4gIGdldFJlcG9zdGVkRXZlbnQ6ICgpID0+IGdldFJlcG9zdGVkRXZlbnQsXG4gIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyOiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlclxufSk7XG5mdW5jdGlvbiBmaW5pc2hSZXBvc3RFdmVudCh0LCByZXBvc3RlZCwgcmVsYXlVcmwsIHByaXZhdGVLZXkpIHtcbiAgbGV0IGtpbmQ7XG4gIGNvbnN0IHRhZ3MgPSBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV07XG4gIGlmIChyZXBvc3RlZC5raW5kID09PSBTaG9ydFRleHROb3RlKSB7XG4gICAga2luZCA9IFJlcG9zdDtcbiAgfSBlbHNlIHtcbiAgICBraW5kID0gR2VuZXJpY1JlcG9zdDtcbiAgICB0YWdzLnB1c2goW1wia1wiLCBTdHJpbmcocmVwb3N0ZWQua2luZCldKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kLFxuICAgICAgdGFncyxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA9PT0gXCJcIiB8fCByZXBvc3RlZC50YWdzPy5maW5kKCh0YWcpID0+IHRhZ1swXSA9PT0gXCItXCIpID8gXCJcIiA6IEpTT04uc3RyaW5naWZ5KHJlcG9zdGVkKSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXIoZXZlbnQpIHtcbiAgaWYgKCFbUmVwb3N0LCBHZW5lcmljUmVwb3N0XS5pbmNsdWRlcyhldmVudC5raW5kKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGxhc3RFVGFnO1xuICBsZXQgbGFzdFBUYWc7XG4gIGZvciAobGV0IGkyID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpMiA+PSAwICYmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApOyBpMi0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKHRhZy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgbGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0RVRhZyA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInBcIiAmJiBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RQVGFnID0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnPy5bMl1dLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIpLFxuICAgIGF1dGhvcjogbGFzdFBUYWc/LlsxXVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVwb3N0ZWRFdmVudChldmVudCwgeyBza2lwVmVyaWZpY2F0aW9uIH0gPSB7fSkge1xuICBjb25zdCBwb2ludGVyID0gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXIoZXZlbnQpO1xuICBpZiAocG9pbnRlciA9PT0gdm9pZCAwIHx8IGV2ZW50LmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCByZXBvc3RlZEV2ZW50O1xuICB0cnkge1xuICAgIHJlcG9zdGVkRXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlcG9zdGVkRXZlbnQuaWQgIT09IHBvaW50ZXIuaWQpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICghc2tpcFZlcmlmaWNhdGlvbiAmJiAhdmVyaWZ5RXZlbnQocmVwb3N0ZWRFdmVudCkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiByZXBvc3RlZEV2ZW50O1xufVxuXG4vLyBuaXAyMS50c1xudmFyIG5pcDIxX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDIxX2V4cG9ydHMsIHtcbiAgTk9TVFJfVVJJX1JFR0VYOiAoKSA9PiBOT1NUUl9VUklfUkVHRVgsXG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHRlc3Q6ICgpID0+IHRlc3Rcbn0pO1xudmFyIE5PU1RSX1VSSV9SRUdFWCA9IG5ldyBSZWdFeHAoYG5vc3RyOigke0JFQ0gzMl9SRUdFWC5zb3VyY2V9KWApO1xuZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIG5ldyBSZWdFeHAoYF4ke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9JGApLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2UyKHVyaSkge1xuICBjb25zdCBtYXRjaCA9IHVyaS5tYXRjaChuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKSk7XG4gIGlmICghbWF0Y2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE5vc3RyIFVSSTogJHt1cml9YCk7XG4gIHJldHVybiB7XG4gICAgdXJpOiBtYXRjaFswXSxcbiAgICB2YWx1ZTogbWF0Y2hbMV0sXG4gICAgZGVjb2RlZDogZGVjb2RlKG1hdGNoWzFdKVxuICB9O1xufVxuXG4vLyBuaXAyNS50c1xudmFyIG5pcDI1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI1X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVhY3Rpb25FdmVudDogKCkgPT4gZmluaXNoUmVhY3Rpb25FdmVudCxcbiAgZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlclxufSk7XG5mdW5jdGlvbiBmaW5pc2hSZWFjdGlvbkV2ZW50KHQsIHJlYWN0ZWQsIHByaXZhdGVLZXkpIHtcbiAgY29uc3QgaW5oZXJpdGVkVGFncyA9IHJlYWN0ZWQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnLmxlbmd0aCA+PSAyICYmICh0YWdbMF0gPT09IFwiZVwiIHx8IHRhZ1swXSA9PT0gXCJwXCIpKTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAgLi4udCxcbiAgICAgIGtpbmQ6IFJlYWN0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXSwgLi4uaW5oZXJpdGVkVGFncywgW1wiZVwiLCByZWFjdGVkLmlkXSwgW1wicFwiLCByZWFjdGVkLnB1YmtleV1dLFxuICAgICAgY29udGVudDogdC5jb250ZW50ID8/IFwiK1wiXG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZWFjdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmIChldmVudC5raW5kICE9PSBSZWFjdGlvbikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGxhc3RFVGFnO1xuICBsZXQgbGFzdFBUYWc7XG4gIGZvciAobGV0IGkyID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpMiA+PSAwICYmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApOyBpMi0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKHRhZy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgbGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0RVRhZyA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInBcIiAmJiBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RQVGFnID0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBsYXN0RVRhZ1sxXSxcbiAgICByZWxheXM6IFtsYXN0RVRhZ1syXSwgbGFzdFBUYWdbMl1dLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnWzFdXG4gIH07XG59XG5cbi8vIG5pcDI3LnRzXG52YXIgbmlwMjdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjdfZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2UzXG59KTtcbnZhciBub0NoYXJhY3RlciA9IC9cXFcvbTtcbnZhciBub1VSTENoYXJhY3RlciA9IC9bXlxcd1xcL10gfFteXFx3XFwvXSR8JHwsfCAvbTtcbnZhciBNQVhfSEFTSFRBR19MRU5HVEggPSA0MjtcbmZ1bmN0aW9uKiBwYXJzZTMoY29udGVudCkge1xuICBsZXQgZW1vamlzID0gW107XG4gIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjb250ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgICBjb25zdCB0YWcgPSBjb250ZW50LnRhZ3NbaTJdO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlbW9qaVwiICYmIHRhZy5sZW5ndGggPj0gMykge1xuICAgICAgICBlbW9qaXMucHVzaCh7IHR5cGU6IFwiZW1vamlcIiwgc2hvcnRjb2RlOiB0YWdbMV0sIHVybDogdGFnWzJdIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZW50ID0gY29udGVudC5jb250ZW50O1xuICB9XG4gIGNvbnN0IG1heCA9IGNvbnRlbnQubGVuZ3RoO1xuICBsZXQgcHJldkluZGV4ID0gMDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbWFpbmxvb3A6XG4gICAgd2hpbGUgKGluZGV4IDwgbWF4KSB7XG4gICAgICBjb25zdCB1ID0gY29udGVudC5pbmRleE9mKFwiOlwiLCBpbmRleCk7XG4gICAgICBjb25zdCBoID0gY29udGVudC5pbmRleE9mKFwiI1wiLCBpbmRleCk7XG4gICAgICBpZiAodSA9PT0gLTEgJiYgaCA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWsgbWFpbmxvb3A7XG4gICAgICB9XG4gICAgICBpZiAodSA9PT0gLTEgfHwgaCA+PSAwICYmIGggPCB1KSB7XG4gICAgICAgIGlmIChoID09PSAwIHx8IGNvbnRlbnRbaCAtIDFdLm1hdGNoKG5vQ2hhcmFjdGVyKSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBjb250ZW50LnNsaWNlKGggKyAxLCBoICsgTUFYX0hBU0hUQUdfTEVOR1RIKS5tYXRjaChub0NoYXJhY3Rlcik7XG4gICAgICAgICAgY29uc3QgZW5kID0gbSA/IGggKyAxICsgbS5pbmRleCA6IG1heDtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnNsaWNlKHByZXZJbmRleCwgaCkgfTtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwiaGFzaHRhZ1wiLCB2YWx1ZTogY29udGVudC5zbGljZShoICsgMSwgZW5kKSB9O1xuICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlIG1haW5sb29wO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gaCArIDE7XG4gICAgICAgIGNvbnRpbnVlIG1haW5sb29wO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnQuc2xpY2UodSAtIDUsIHUpID09PSBcIm5vc3RyXCIpIHtcbiAgICAgICAgY29uc3QgbSA9IGNvbnRlbnQuc2xpY2UodSArIDYwKS5tYXRjaChub0NoYXJhY3Rlcik7XG4gICAgICAgIGNvbnN0IGVuZCA9IG0gPyB1ICsgNjAgKyBtLmluZGV4IDogbWF4O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBwb2ludGVyO1xuICAgICAgICAgIGxldCB7IGRhdGEsIHR5cGUgfSA9IGRlY29kZShjb250ZW50LnNsaWNlKHUgKyAxLCBlbmQpKTtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgICAgICAgIHBvaW50ZXIgPSB7IHB1YmtleTogZGF0YSB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgICAgIHBvaW50ZXIgPSB7IGlkOiBkYXRhIH07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5zZWNcIjpcbiAgICAgICAgICAgICAgaW5kZXggPSBlbmQgKyAxO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHBvaW50ZXIgPSBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSB1IC0gNSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zbGljZShwcmV2SW5kZXgsIHUgLSA1KSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwicmVmZXJlbmNlXCIsIHBvaW50ZXIgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIGluZGV4ID0gdSArIDE7XG4gICAgICAgICAgY29udGludWUgbWFpbmxvb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udGVudC5zbGljZSh1IC0gNSwgdSkgPT09IFwiaHR0cHNcIiB8fCBjb250ZW50LnNsaWNlKHUgLSA0LCB1KSA9PT0gXCJodHRwXCIpIHtcbiAgICAgICAgY29uc3QgbSA9IGNvbnRlbnQuc2xpY2UodSArIDQpLm1hdGNoKG5vVVJMQ2hhcmFjdGVyKTtcbiAgICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA0ICsgbS5pbmRleCA6IG1heDtcbiAgICAgICAgY29uc3QgcHJlZml4TGVuID0gY29udGVudFt1IC0gMV0gPT09IFwic1wiID8gNSA6IDQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwoY29udGVudC5zbGljZSh1IC0gcHJlZml4TGVuLCBlbmQpKTtcbiAgICAgICAgICBpZiAodXJsLmhvc3RuYW1lLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1cmxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUgLSBwcmVmaXhMZW4pIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc2xpY2UocHJldkluZGV4LCB1IC0gcHJlZml4TGVuKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoL1xcLihwbmd8anBlP2d8Z2lmfHdlYnB8aGVpY3xzdmcpJC9pLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcImltYWdlXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC9cXC4obXA0fGF2aXx3ZWJtfG1rdnxtb3YpJC9pLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcInZpZGVvXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC9cXC4obXAzfGFhY3xvZ2d8b3B1c3x3YXZ8ZmxhYykkL2kudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwiYXVkaW9cIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnRpbnVlIG1haW5sb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidXJsXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIGluZGV4ID0gZW5kICsgMTtcbiAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250ZW50LnNsaWNlKHUgLSAzLCB1KSA9PT0gXCJ3c3NcIiB8fCBjb250ZW50LnNsaWNlKHUgLSAyLCB1KSA9PT0gXCJ3c1wiKSB7XG4gICAgICAgIGNvbnN0IG0gPSBjb250ZW50LnNsaWNlKHUgKyA0KS5tYXRjaChub1VSTENoYXJhY3Rlcik7XG4gICAgICAgIGNvbnN0IGVuZCA9IG0gPyB1ICsgNCArIG0uaW5kZXggOiBtYXg7XG4gICAgICAgIGNvbnN0IHByZWZpeExlbiA9IGNvbnRlbnRbdSAtIDFdID09PSBcInNcIiA/IDMgOiAyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKGNvbnRlbnQuc2xpY2UodSAtIHByZWZpeExlbiwgZW5kKSk7XG4gICAgICAgICAgaWYgKHVybC5ob3N0bmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgd3MgdXJsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSB1IC0gcHJlZml4TGVuKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnNsaWNlKHByZXZJbmRleCwgdSAtIHByZWZpeExlbikgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInJlbGF5XCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIGluZGV4ID0gZW5kICsgMTtcbiAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlbW9qaXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICBjb25zdCBlbW9qaSA9IGVtb2ppc1tlXTtcbiAgICAgICAgICBpZiAoY29udGVudFt1ICsgZW1vamkuc2hvcnRjb2RlLmxlbmd0aCArIDFdID09PSBcIjpcIiAmJiBjb250ZW50LnNsaWNlKHUgKyAxLCB1ICsgZW1vamkuc2hvcnRjb2RlLmxlbmd0aCArIDEpID09PSBlbW9qaS5zaG9ydGNvZGUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUpIHtcbiAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zbGljZShwcmV2SW5kZXgsIHUpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBlbW9qaTtcbiAgICAgICAgICAgIGluZGV4ID0gdSArIGVtb2ppLnNob3J0Y29kZS5sZW5ndGggKyAyO1xuICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZSBtYWlubG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB1ICsgMTtcbiAgICAgICAgY29udGludWUgbWFpbmxvb3A7XG4gICAgICB9XG4gICAgfVxuICBpZiAocHJldkluZGV4ICE9PSBtYXgpIHtcbiAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnNsaWNlKHByZXZJbmRleCkgfTtcbiAgfVxufVxuXG4vLyBuaXAyOC50c1xudmFyIG5pcDI4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI4X2V4cG9ydHMsIHtcbiAgY2hhbm5lbENyZWF0ZUV2ZW50OiAoKSA9PiBjaGFubmVsQ3JlYXRlRXZlbnQsXG4gIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbE1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1ldGFkYXRhRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXRhZGF0YUV2ZW50LFxuICBjaGFubmVsTXV0ZVVzZXJFdmVudDogKCkgPT4gY2hhbm5lbE11dGVVc2VyRXZlbnRcbn0pO1xudmFyIGNoYW5uZWxDcmVhdGVFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbENyZWF0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWV0YWRhdGEsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyb290XCJdXTtcbiAgaWYgKHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkKSB7XG4gICAgdGFncy5wdXNoKFtcImVcIiwgdC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJlcGx5XCJdKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFsuLi50YWdzLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudDogdC5jb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTXV0ZVVzZXIsXG4gICAgICB0YWdzOiBbW1wicFwiLCB0LnB1YmtleV90b19tdXRlXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG5cbi8vIG5pcDMwLnRzXG52YXIgbmlwMzBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzBfZXhwb3J0cywge1xuICBFTU9KSV9TSE9SVENPREVfUkVHRVg6ICgpID0+IEVNT0pJX1NIT1JUQ09ERV9SRUdFWCxcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsLFxuICByZWdleDogKCkgPT4gcmVnZXgsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGxcbn0pO1xudmFyIEVNT0pJX1NIT1JUQ09ERV9SRUdFWCA9IC86KFxcdyspOi87XG52YXIgcmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcQiR7RU1PSklfU0hPUlRDT0RFX1JFR0VYLnNvdXJjZX1cXFxcQmAsIFwiZ1wiKTtcbmZ1bmN0aW9uKiBtYXRjaEFsbChjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4KCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Nob3J0Y29kZSwgbmFtZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgc2hvcnRjb2RlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBzaG9ydGNvZGUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGNvbnRlbnQsIHJlcGxhY2VyKSB7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwocmVnZXgoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ3LnRzXG52YXIgbmlwNDdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDdfZXhwb3J0cywge1xuICBtYWtlTndjUmVxdWVzdEV2ZW50OiAoKSA9PiBtYWtlTndjUmVxdWVzdEV2ZW50LFxuICBwYXJzZUNvbm5lY3Rpb25TdHJpbmc6ICgpID0+IHBhcnNlQ29ubmVjdGlvblN0cmluZ1xufSk7XG5mdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZykge1xuICBjb25zdCB7IGhvc3QsIHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwoY29ubmVjdGlvblN0cmluZyk7XG4gIGNvbnN0IHB1YmtleSA9IHBhdGhuYW1lIHx8IGhvc3Q7XG4gIGNvbnN0IHJlbGF5ID0gc2VhcmNoUGFyYW1zLmdldChcInJlbGF5XCIpO1xuICBjb25zdCBzZWNyZXQgPSBzZWFyY2hQYXJhbXMuZ2V0KFwic2VjcmV0XCIpO1xuICBpZiAoIXB1YmtleSB8fCAhcmVsYXkgfHwgIXNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29ubmVjdGlvbiBzdHJpbmdcIik7XG4gIH1cbiAgcmV0dXJuIHsgcHVia2V5LCByZWxheSwgc2VjcmV0IH07XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlTndjUmVxdWVzdEV2ZW50KHB1YmtleSwgc2VjcmV0S2V5LCBpbnZvaWNlKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgbWV0aG9kOiBcInBheV9pbnZvaWNlXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBpbnZvaWNlXG4gICAgfVxuICB9O1xuICBjb25zdCBlbmNyeXB0ZWRDb250ZW50ID0gZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xuICBjb25zdCBldmVudFRlbXBsYXRlID0ge1xuICAgIGtpbmQ6IE5XQ1dhbGxldFJlcXVlc3QsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBlbmNyeXB0ZWRDb250ZW50LFxuICAgIHRhZ3M6IFtbXCJwXCIsIHB1YmtleV1dXG4gIH07XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50VGVtcGxhdGUsIHNlY3JldEtleSk7XG59XG5cbi8vIG5pcDU0LnRzXG52YXIgbmlwNTRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTRfZXhwb3J0cywge1xuICBub3JtYWxpemVJZGVudGlmaWVyOiAoKSA9PiBub3JtYWxpemVJZGVudGlmaWVyXG59KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICBuYW1lID0gbmFtZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IG5hbWUubm9ybWFsaXplKFwiTkZLQ1wiKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obmFtZSkubWFwKChjaGFyKSA9PiB7XG4gICAgaWYgKC9cXHB7TGV0dGVyfS91LnRlc3QoY2hhcikgfHwgL1xccHtOdW1iZXJ9L3UudGVzdChjaGFyKSkge1xuICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxuICAgIHJldHVybiBcIi1cIjtcbiAgfSkuam9pbihcIlwiKTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFNhdG9zaGlzQW1vdW50RnJvbUJvbHQxMTogKCkgPT4gZ2V0U2F0b3NoaXNBbW91bnRGcm9tQm9sdDExLFxuICBnZXRaYXBFbmRwb2ludDogKCkgPT4gZ2V0WmFwRW5kcG9pbnQsXG4gIG1ha2VaYXBSZWNlaXB0OiAoKSA9PiBtYWtlWmFwUmVjZWlwdCxcbiAgbWFrZVphcFJlcXVlc3Q6ICgpID0+IG1ha2VaYXBSZXF1ZXN0LFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNCxcbiAgdmFsaWRhdGVaYXBSZXF1ZXN0OiAoKSA9PiB2YWxpZGF0ZVphcFJlcXVlc3Rcbn0pO1xuaW1wb3J0IHsgYmVjaDMyIGFzIGJlY2gzMjIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBfZmV0Y2g0O1xudHJ5IHtcbiAgX2ZldGNoNCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNChmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDQgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0WmFwRW5kcG9pbnQobWV0YWRhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQgbG51cmwgPSBcIlwiO1xuICAgIGxldCB7IGx1ZDA2LCBsdWQxNiB9ID0gSlNPTi5wYXJzZShtZXRhZGF0YS5jb250ZW50KTtcbiAgICBpZiAobHVkMTYpIHtcbiAgICAgIGxldCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICAgIGxudXJsID0gbmV3IFVSTChgLy53ZWxsLWtub3duL2xudXJscC8ke25hbWV9YCwgYGh0dHBzOi8vJHtkb21haW59YCkudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDA2KSB7XG4gICAgICBsZXQgeyB3b3JkcyB9ID0gYmVjaDMyMi5kZWNvZGUobHVkMDYsIDFlMyk7XG4gICAgICBsZXQgZGF0YSA9IGJlY2gzMjIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICAgIGxudXJsID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IF9mZXRjaDQobG51cmwpO1xuICAgIGxldCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoYm9keS5hbGxvd3NOb3N0ciAmJiBib2R5Lm5vc3RyUHVia2V5KSB7XG4gICAgICByZXR1cm4gYm9keS5jYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlcXVlc3QocGFyYW1zKSB7XG4gIGxldCB6ciA9IHtcbiAgICBraW5kOiA5NzM0LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgY29udGVudDogcGFyYW1zLmNvbW1lbnQgfHwgXCJcIixcbiAgICB0YWdzOiBbXG4gICAgICBbXCJwXCIsIFwicHVia2V5XCIgaW4gcGFyYW1zID8gcGFyYW1zLnB1YmtleSA6IHBhcmFtcy5ldmVudC5wdWJrZXldLFxuICAgICAgW1wiYW1vdW50XCIsIHBhcmFtcy5hbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucGFyYW1zLnJlbGF5c11cbiAgICBdXG4gIH07XG4gIGlmIChcImV2ZW50XCIgaW4gcGFyYW1zKSB7XG4gICAgenIudGFncy5wdXNoKFtcImVcIiwgcGFyYW1zLmV2ZW50LmlkXSk7XG4gICAgaWYgKGlzUmVwbGFjZWFibGVLaW5kKHBhcmFtcy5ldmVudC5raW5kKSkge1xuICAgICAgY29uc3QgYSA9IFtcImFcIiwgYCR7cGFyYW1zLmV2ZW50LmtpbmR9OiR7cGFyYW1zLmV2ZW50LnB1YmtleX06YF07XG4gICAgICB6ci50YWdzLnB1c2goYSk7XG4gICAgfSBlbHNlIGlmIChpc0FkZHJlc3NhYmxlS2luZChwYXJhbXMuZXZlbnQua2luZCkpIHtcbiAgICAgIGxldCBkID0gcGFyYW1zLmV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcImRcIiAmJiB2KTtcbiAgICAgIGlmICghZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZCB0YWcgbm90IGZvdW5kIG9yIGlzIGVtcHR5XCIpO1xuICAgICAgY29uc3QgYSA9IFtcImFcIiwgYCR7cGFyYW1zLmV2ZW50LmtpbmR9OiR7cGFyYW1zLmV2ZW50LnB1YmtleX06JHtkWzFdfWBdO1xuICAgICAgenIudGFncy5wdXNoKGEpO1xuICAgIH1cbiAgICB6ci50YWdzLnB1c2goW1wia1wiLCBwYXJhbXMuZXZlbnQua2luZC50b1N0cmluZygpXSk7XG4gIH1cbiAgcmV0dXJuIHpyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVaYXBSZXF1ZXN0KHphcFJlcXVlc3RTdHJpbmcpIHtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFN0cmluZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBcIkludmFsaWQgemFwIHJlcXVlc3QgSlNPTi5cIjtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghdmVyaWZ5RXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJQXCIsIHpyLnB1YmtleV0sIFtcImJvbHQxMVwiLCBib2x0MTFdLCBbXCJkZXNjcmlwdGlvblwiLCB6YXBSZXF1ZXN0XV1cbiAgfTtcbiAgaWYgKHByZWltYWdlKSB7XG4gICAgemFwLnRhZ3MucHVzaChbXCJwcmVpbWFnZVwiLCBwcmVpbWFnZV0pO1xuICB9XG4gIHJldHVybiB6YXA7XG59XG5mdW5jdGlvbiBnZXRTYXRvc2hpc0Ftb3VudEZyb21Cb2x0MTEoYm9sdDExKSB7XG4gIGlmIChib2x0MTEubGVuZ3RoIDwgNTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBib2x0MTEgPSBib2x0MTEuc3Vic3RyaW5nKDAsIDUwKTtcbiAgY29uc3QgaWR4ID0gYm9sdDExLmxhc3RJbmRleE9mKFwiMVwiKTtcbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBocnAgPSBib2x0MTEuc3Vic3RyaW5nKDAsIGlkeCk7XG4gIGlmICghaHJwLnN0YXJ0c1dpdGgoXCJsbmJjXCIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gaHJwLnN1YnN0cmluZyg0KTtcbiAgaWYgKGFtb3VudC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY2hhciA9IGFtb3VudFthbW91bnQubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGRpZ2l0ID0gY2hhci5jaGFyQ29kZUF0KDApIC0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbiAgY29uc3QgaXNEaWdpdCA9IGRpZ2l0ID49IDAgJiYgZGlnaXQgPD0gOTtcbiAgbGV0IGN1dFBvaW50ID0gYW1vdW50Lmxlbmd0aCAtIDE7XG4gIGlmIChpc0RpZ2l0KSB7XG4gICAgY3V0UG9pbnQrKztcbiAgfVxuICBpZiAoY3V0UG9pbnQgPCAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoYW1vdW50LnN1YnN0cmluZygwLCBjdXRQb2ludCkpO1xuICBzd2l0Y2ggKGNoYXIpIHtcbiAgICBjYXNlIFwibVwiOlxuICAgICAgcmV0dXJuIG51bSAqIDFlNTtcbiAgICBjYXNlIFwidVwiOlxuICAgICAgcmV0dXJuIG51bSAqIDEwMDtcbiAgICBjYXNlIFwiblwiOlxuICAgICAgcmV0dXJuIG51bSAvIDEwO1xuICAgIGNhc2UgXCJwXCI6XG4gICAgICByZXR1cm4gbnVtIC8gMWU0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVtICogMWU4O1xuICB9XG59XG5cbi8vIG5pcDc3LnRzXG52YXIgbmlwNzdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNzdfZXhwb3J0cywge1xuICBOZWdlbnRyb3B5OiAoKSA9PiBOZWdlbnRyb3B5LFxuICBOZWdlbnRyb3B5U3RvcmFnZVZlY3RvcjogKCkgPT4gTmVnZW50cm9weVN0b3JhZ2VWZWN0b3IsXG4gIE5lZ2VudHJvcHlTeW5jOiAoKSA9PiBOZWdlbnRyb3B5U3luY1xufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXg1LCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXM2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTY0IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMi5qc1wiO1xudmFyIFBST1RPQ09MX1ZFUlNJT04gPSA5NztcbnZhciBJRF9TSVpFID0gMzI7XG52YXIgRklOR0VSUFJJTlRfU0laRSA9IDE2O1xudmFyIE1vZGUgPSB7XG4gIFNraXA6IDAsXG4gIEZpbmdlcnByaW50OiAxLFxuICBJZExpc3Q6IDJcbn07XG52YXIgV3JhcHBlZEJ1ZmZlciA9IGNsYXNzIHtcbiAgX3JhdztcbiAgbGVuZ3RoO1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5fcmF3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMuX3JhdyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICB0aGlzLmxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JhdyA9IG5ldyBVaW50OEFycmF5KDUxMik7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3LnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICBnZXQgY2FwYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhdy5ieXRlTGVuZ3RoO1xuICB9XG4gIGV4dGVuZChidWYpIHtcbiAgICBpZiAoYnVmIGluc3RhbmNlb2YgV3JhcHBlZEJ1ZmZlcilcbiAgICAgIGJ1ZiA9IGJ1Zi51bndyYXAoKTtcbiAgICBpZiAodHlwZW9mIGJ1Zi5sZW5ndGggIT09IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBFcnJvcihcImJhZCBsZW5ndGhcIik7XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IGJ1Zi5sZW5ndGggKyB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5jYXBhY2l0eSA8IHRhcmdldFNpemUpIHtcbiAgICAgIGNvbnN0IG9sZFJhdyA9IHRoaXMuX3JhdztcbiAgICAgIGNvbnN0IG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgodGhpcy5jYXBhY2l0eSAqIDIsIHRhcmdldFNpemUpO1xuICAgICAgdGhpcy5fcmF3ID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgICAgdGhpcy5fcmF3LnNldChvbGRSYXcpO1xuICAgIH1cbiAgICB0aGlzLl9yYXcuc2V0KGJ1ZiwgdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLl9yYXdbMF07XG4gICAgdGhpcy5fcmF3ID0gdGhpcy5fcmF3LnN1YmFycmF5KDEpO1xuICAgIHRoaXMubGVuZ3RoLS07XG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG4gIHNoaWZ0TihuID0gMSkge1xuICAgIGNvbnN0IGZpcnN0U3ViYXJyYXkgPSB0aGlzLl9yYXcuc3ViYXJyYXkoMCwgbik7XG4gICAgdGhpcy5fcmF3ID0gdGhpcy5fcmF3LnN1YmFycmF5KG4pO1xuICAgIHRoaXMubGVuZ3RoIC09IG47XG4gICAgcmV0dXJuIGZpcnN0U3ViYXJyYXk7XG4gIH1cbn07XG5mdW5jdGlvbiBkZWNvZGVWYXJJbnQoYnVmKSB7XG4gIGxldCByZXMgPSAwO1xuICB3aGlsZSAoMSkge1xuICAgIGlmIChidWYubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJwYXJzZSBlbmRzIHByZW1hdHVyZWx5XCIpO1xuICAgIGxldCBieXRlID0gYnVmLnNoaWZ0KCk7XG4gICAgcmVzID0gcmVzIDw8IDcgfCBieXRlICYgMTI3O1xuICAgIGlmICgoYnl0ZSAmIDEyOCkgPT09IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFySW50KG4pIHtcbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkQnVmZmVyKG5ldyBVaW50OEFycmF5KFswXSkpO1xuICBsZXQgbyA9IFtdO1xuICB3aGlsZSAobiAhPT0gMCkge1xuICAgIG8ucHVzaChuICYgMTI3KTtcbiAgICBuID4+Pj0gNztcbiAgfVxuICBvLnJldmVyc2UoKTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG8ubGVuZ3RoIC0gMTsgaTIrKylcbiAgICBvW2kyXSB8PSAxMjg7XG4gIHJldHVybiBuZXcgV3JhcHBlZEJ1ZmZlcihuZXcgVWludDhBcnJheShvKSk7XG59XG5mdW5jdGlvbiBnZXRCeXRlKGJ1Zikge1xuICByZXR1cm4gZ2V0Qnl0ZXMoYnVmLCAxKVswXTtcbn1cbmZ1bmN0aW9uIGdldEJ5dGVzKGJ1Ziwgbikge1xuICBpZiAoYnVmLmxlbmd0aCA8IG4pXG4gICAgdGhyb3cgRXJyb3IoXCJwYXJzZSBlbmRzIHByZW1hdHVyZWx5XCIpO1xuICByZXR1cm4gYnVmLnNoaWZ0TihuKTtcbn1cbnZhciBBY2N1bXVsYXRvciA9IGNsYXNzIHtcbiAgYnVmO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNldFRvWmVybygpO1xuICB9XG4gIHNldFRvWmVybygpIHtcbiAgICB0aGlzLmJ1ZiA9IG5ldyBVaW50OEFycmF5KElEX1NJWkUpO1xuICB9XG4gIGFkZChvdGhlckJ1Zikge1xuICAgIGxldCBjdXJyQ2FycnkgPSAwLCBuZXh0Q2FycnkgPSAwO1xuICAgIGxldCBwID0gbmV3IERhdGFWaWV3KHRoaXMuYnVmLmJ1ZmZlcik7XG4gICAgbGV0IHBvID0gbmV3IERhdGFWaWV3KG90aGVyQnVmLmJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IDg7IGkyKyspIHtcbiAgICAgIGxldCBvZmZzZXQgPSBpMiAqIDQ7XG4gICAgICBsZXQgb3JpZyA9IHAuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICBsZXQgb3RoZXJWID0gcG8uZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICBsZXQgbmV4dCA9IG9yaWc7XG4gICAgICBuZXh0ICs9IGN1cnJDYXJyeTtcbiAgICAgIG5leHQgKz0gb3RoZXJWO1xuICAgICAgaWYgKG5leHQgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICBuZXh0Q2FycnkgPSAxO1xuICAgICAgcC5zZXRVaW50MzIob2Zmc2V0LCBuZXh0ICYgNDI5NDk2NzI5NSwgdHJ1ZSk7XG4gICAgICBjdXJyQ2FycnkgPSBuZXh0Q2Fycnk7XG4gICAgICBuZXh0Q2FycnkgPSAwO1xuICAgIH1cbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgbGV0IHAgPSBuZXcgRGF0YVZpZXcodGhpcy5idWYuYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgODsgaTIrKykge1xuICAgICAgbGV0IG9mZnNldCA9IGkyICogNDtcbiAgICAgIHAuc2V0VWludDMyKG9mZnNldCwgfnAuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBsZXQgb25lID0gbmV3IFVpbnQ4QXJyYXkoSURfU0laRSk7XG4gICAgb25lWzBdID0gMTtcbiAgICB0aGlzLmFkZChvbmUpO1xuICB9XG4gIGdldEZpbmdlcnByaW50KG4pIHtcbiAgICBsZXQgaW5wdXQgPSBuZXcgV3JhcHBlZEJ1ZmZlcigpO1xuICAgIGlucHV0LmV4dGVuZCh0aGlzLmJ1Zik7XG4gICAgaW5wdXQuZXh0ZW5kKGVuY29kZVZhckludChuKSk7XG4gICAgbGV0IGhhc2ggPSBzaGEyNTY0KGlucHV0LnVud3JhcCgpKTtcbiAgICByZXR1cm4gaGFzaC5zdWJhcnJheSgwLCBGSU5HRVJQUklOVF9TSVpFKTtcbiAgfVxufTtcbnZhciBOZWdlbnRyb3B5U3RvcmFnZVZlY3RvciA9IGNsYXNzIHtcbiAgaXRlbXM7XG4gIHNlYWxlZDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuc2VhbGVkID0gZmFsc2U7XG4gIH1cbiAgaW5zZXJ0KHRpbWVzdGFtcCwgaWQpIHtcbiAgICBpZiAodGhpcy5zZWFsZWQpXG4gICAgICB0aHJvdyBFcnJvcihcImFscmVhZHkgc2VhbGVkXCIpO1xuICAgIGNvbnN0IGlkYiA9IGhleFRvQnl0ZXM2KGlkKTtcbiAgICBpZiAoaWRiLmJ5dGVMZW5ndGggIT09IElEX1NJWkUpXG4gICAgICB0aHJvdyBFcnJvcihcImJhZCBpZCBzaXplIGZvciBhZGRlZCBpdGVtXCIpO1xuICAgIHRoaXMuaXRlbXMucHVzaCh7IHRpbWVzdGFtcCwgaWQ6IGlkYiB9KTtcbiAgfVxuICBzZWFsKCkge1xuICAgIGlmICh0aGlzLnNlYWxlZClcbiAgICAgIHRocm93IEVycm9yKFwiYWxyZWFkeSBzZWFsZWRcIik7XG4gICAgdGhpcy5zZWFsZWQgPSB0cnVlO1xuICAgIHRoaXMuaXRlbXMuc29ydChpdGVtQ29tcGFyZSk7XG4gICAgZm9yIChsZXQgaTIgPSAxOyBpMiA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBpZiAoaXRlbUNvbXBhcmUodGhpcy5pdGVtc1tpMiAtIDFdLCB0aGlzLml0ZW1zW2kyXSkgPT09IDApXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGl0ZW0gaW5zZXJ0ZWRcIik7XG4gICAgfVxuICB9XG4gIHVuc2VhbCgpIHtcbiAgICB0aGlzLnNlYWxlZCA9IGZhbHNlO1xuICB9XG4gIHNpemUoKSB7XG4gICAgdGhpcy5fY2hlY2tTZWFsZWQoKTtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIH1cbiAgZ2V0SXRlbShpMikge1xuICAgIHRoaXMuX2NoZWNrU2VhbGVkKCk7XG4gICAgaWYgKGkyID49IHRoaXMuaXRlbXMubGVuZ3RoKVxuICAgICAgdGhyb3cgRXJyb3IoXCJvdXQgb2YgcmFuZ2VcIik7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaTJdO1xuICB9XG4gIGl0ZXJhdGUoYmVnaW4sIGVuZCwgY2IpIHtcbiAgICB0aGlzLl9jaGVja1NlYWxlZCgpO1xuICAgIHRoaXMuX2NoZWNrQm91bmRzKGJlZ2luLCBlbmQpO1xuICAgIGZvciAobGV0IGkyID0gYmVnaW47IGkyIDwgZW5kOyArK2kyKSB7XG4gICAgICBpZiAoIWNiKHRoaXMuaXRlbXNbaTJdLCBpMikpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmaW5kTG93ZXJCb3VuZChiZWdpbiwgZW5kLCBib3VuZCkge1xuICAgIHRoaXMuX2NoZWNrU2VhbGVkKCk7XG4gICAgdGhpcy5fY2hlY2tCb3VuZHMoYmVnaW4sIGVuZCk7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVNlYXJjaCh0aGlzLml0ZW1zLCBiZWdpbiwgZW5kLCAoYSkgPT4gaXRlbUNvbXBhcmUoYSwgYm91bmQpIDwgMCk7XG4gIH1cbiAgZmluZ2VycHJpbnQoYmVnaW4sIGVuZCkge1xuICAgIGxldCBvdXQgPSBuZXcgQWNjdW11bGF0b3IoKTtcbiAgICBvdXQuc2V0VG9aZXJvKCk7XG4gICAgdGhpcy5pdGVyYXRlKGJlZ2luLCBlbmQsIChpdGVtKSA9PiB7XG4gICAgICBvdXQuYWRkKGl0ZW0uaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dC5nZXRGaW5nZXJwcmludChlbmQgLSBiZWdpbik7XG4gIH1cbiAgX2NoZWNrU2VhbGVkKCkge1xuICAgIGlmICghdGhpcy5zZWFsZWQpXG4gICAgICB0aHJvdyBFcnJvcihcIm5vdCBzZWFsZWRcIik7XG4gIH1cbiAgX2NoZWNrQm91bmRzKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5pdGVtcy5sZW5ndGgpXG4gICAgICB0aHJvdyBFcnJvcihcImJhZCByYW5nZVwiKTtcbiAgfVxuICBfYmluYXJ5U2VhcmNoKGFyciwgZmlyc3QsIGxhc3QsIGNtcCkge1xuICAgIGxldCBjb3VudCA9IGxhc3QgLSBmaXJzdDtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICBsZXQgaXQgPSBmaXJzdDtcbiAgICAgIGxldCBzdGVwID0gTWF0aC5mbG9vcihjb3VudCAvIDIpO1xuICAgICAgaXQgKz0gc3RlcDtcbiAgICAgIGlmIChjbXAoYXJyW2l0XSkpIHtcbiAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICBjb3VudCAtPSBzdGVwICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG59O1xudmFyIE5lZ2VudHJvcHkgPSBjbGFzcyB7XG4gIHN0b3JhZ2U7XG4gIGZyYW1lU2l6ZUxpbWl0O1xuICBsYXN0VGltZXN0YW1wSW47XG4gIGxhc3RUaW1lc3RhbXBPdXQ7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGZyYW1lU2l6ZUxpbWl0ID0gNmU0KSB7XG4gICAgaWYgKGZyYW1lU2l6ZUxpbWl0IDwgNDA5NilcbiAgICAgIHRocm93IEVycm9yKFwiZnJhbWVTaXplTGltaXQgdG9vIHNtYWxsXCIpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5mcmFtZVNpemVMaW1pdCA9IGZyYW1lU2l6ZUxpbWl0O1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcEluID0gMDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXBPdXQgPSAwO1xuICB9XG4gIF9ib3VuZCh0aW1lc3RhbXAsIGlkKSB7XG4gICAgcmV0dXJuIHsgdGltZXN0YW1wLCBpZDogaWQgfHwgbmV3IFVpbnQ4QXJyYXkoMCkgfTtcbiAgfVxuICBpbml0aWF0ZSgpIHtcbiAgICBsZXQgb3V0cHV0ID0gbmV3IFdyYXBwZWRCdWZmZXIoKTtcbiAgICBvdXRwdXQuZXh0ZW5kKG5ldyBVaW50OEFycmF5KFtQUk9UT0NPTF9WRVJTSU9OXSkpO1xuICAgIHRoaXMuc3BsaXRSYW5nZSgwLCB0aGlzLnN0b3JhZ2Uuc2l6ZSgpLCB0aGlzLl9ib3VuZChOdW1iZXIuTUFYX1ZBTFVFKSwgb3V0cHV0KTtcbiAgICByZXR1cm4gYnl0ZXNUb0hleDUob3V0cHV0LnVud3JhcCgpKTtcbiAgfVxuICByZWNvbmNpbGUocXVlcnlNc2csIG9uaGF2ZSwgb25uZWVkKSB7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgV3JhcHBlZEJ1ZmZlcihoZXhUb0J5dGVzNihxdWVyeU1zZykpO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcEluID0gdGhpcy5sYXN0VGltZXN0YW1wT3V0ID0gMDtcbiAgICBsZXQgZnVsbE91dHB1dCA9IG5ldyBXcmFwcGVkQnVmZmVyKCk7XG4gICAgZnVsbE91dHB1dC5leHRlbmQobmV3IFVpbnQ4QXJyYXkoW1BST1RPQ09MX1ZFUlNJT05dKSk7XG4gICAgbGV0IHByb3RvY29sVmVyc2lvbiA9IGdldEJ5dGUocXVlcnkpO1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPCA5NiB8fCBwcm90b2NvbFZlcnNpb24gPiAxMTEpXG4gICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgbmVnZW50cm9weSBwcm90b2NvbCB2ZXJzaW9uIGJ5dGVcIik7XG4gICAgaWYgKHByb3RvY29sVmVyc2lvbiAhPT0gUFJPVE9DT0xfVkVSU0lPTikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBuZWdlbnRyb3B5IHByb3RvY29sIHZlcnNpb24gcmVxdWVzdGVkOiBcIiArIChwcm90b2NvbFZlcnNpb24gLSA5NikpO1xuICAgIH1cbiAgICBsZXQgc3RvcmFnZVNpemUgPSB0aGlzLnN0b3JhZ2Uuc2l6ZSgpO1xuICAgIGxldCBwcmV2Qm91bmQgPSB0aGlzLl9ib3VuZCgwKTtcbiAgICBsZXQgcHJldkluZGV4ID0gMDtcbiAgICBsZXQgc2tpcCA9IGZhbHNlO1xuICAgIHdoaWxlIChxdWVyeS5sZW5ndGggIT09IDApIHtcbiAgICAgIGxldCBvID0gbmV3IFdyYXBwZWRCdWZmZXIoKTtcbiAgICAgIGxldCBkb1NraXAgPSAoKSA9PiB7XG4gICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgIG8uZXh0ZW5kKHRoaXMuZW5jb2RlQm91bmQocHJldkJvdW5kKSk7XG4gICAgICAgICAgby5leHRlbmQoZW5jb2RlVmFySW50KE1vZGUuU2tpcCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGV0IGN1cnJCb3VuZCA9IHRoaXMuZGVjb2RlQm91bmQocXVlcnkpO1xuICAgICAgbGV0IG1vZGUgPSBkZWNvZGVWYXJJbnQocXVlcnkpO1xuICAgICAgbGV0IGxvd2VyID0gcHJldkluZGV4O1xuICAgICAgbGV0IHVwcGVyID0gdGhpcy5zdG9yYWdlLmZpbmRMb3dlckJvdW5kKHByZXZJbmRleCwgc3RvcmFnZVNpemUsIGN1cnJCb3VuZCk7XG4gICAgICBpZiAobW9kZSA9PT0gTW9kZS5Ta2lwKSB7XG4gICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBNb2RlLkZpbmdlcnByaW50KSB7XG4gICAgICAgIGxldCB0aGVpckZpbmdlcnByaW50ID0gZ2V0Qnl0ZXMocXVlcnksIEZJTkdFUlBSSU5UX1NJWkUpO1xuICAgICAgICBsZXQgb3VyRmluZ2VycHJpbnQgPSB0aGlzLnN0b3JhZ2UuZmluZ2VycHJpbnQobG93ZXIsIHVwcGVyKTtcbiAgICAgICAgaWYgKGNvbXBhcmVVaW50OEFycmF5KHRoZWlyRmluZ2VycHJpbnQsIG91ckZpbmdlcnByaW50KSAhPT0gMCkge1xuICAgICAgICAgIGRvU2tpcCgpO1xuICAgICAgICAgIHRoaXMuc3BsaXRSYW5nZShsb3dlciwgdXBwZXIsIGN1cnJCb3VuZCwgbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gTW9kZS5JZExpc3QpIHtcbiAgICAgICAgbGV0IG51bUlkcyA9IGRlY29kZVZhckludChxdWVyeSk7XG4gICAgICAgIGxldCB0aGVpckVsZW1zID0ge307XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBudW1JZHM7IGkyKyspIHtcbiAgICAgICAgICBsZXQgZSA9IGdldEJ5dGVzKHF1ZXJ5LCBJRF9TSVpFKTtcbiAgICAgICAgICB0aGVpckVsZW1zW2J5dGVzVG9IZXg1KGUpXSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5pdGVyYXRlKGxvd2VyLCB1cHBlciwgKGl0ZW0pID0+IHtcbiAgICAgICAgICBsZXQgayA9IGl0ZW0uaWQ7XG4gICAgICAgICAgY29uc3QgaWQgPSBieXRlc1RvSGV4NShrKTtcbiAgICAgICAgICBpZiAoIXRoZWlyRWxlbXNbaWRdKSB7XG4gICAgICAgICAgICBvbmhhdmU/LihpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGVpckVsZW1zW2J5dGVzVG9IZXg1KGspXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25uZWVkKSB7XG4gICAgICAgICAgZm9yIChsZXQgdiBvZiBPYmplY3QudmFsdWVzKHRoZWlyRWxlbXMpKSB7XG4gICAgICAgICAgICBvbm5lZWQoYnl0ZXNUb0hleDUodikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkIG1vZGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5leGNlZWRlZEZyYW1lU2l6ZUxpbWl0KGZ1bGxPdXRwdXQubGVuZ3RoICsgby5sZW5ndGgpKSB7XG4gICAgICAgIGxldCByZW1haW5pbmdGaW5nZXJwcmludCA9IHRoaXMuc3RvcmFnZS5maW5nZXJwcmludCh1cHBlciwgc3RvcmFnZVNpemUpO1xuICAgICAgICBmdWxsT3V0cHV0LmV4dGVuZCh0aGlzLmVuY29kZUJvdW5kKHRoaXMuX2JvdW5kKE51bWJlci5NQVhfVkFMVUUpKSk7XG4gICAgICAgIGZ1bGxPdXRwdXQuZXh0ZW5kKGVuY29kZVZhckludChNb2RlLkZpbmdlcnByaW50KSk7XG4gICAgICAgIGZ1bGxPdXRwdXQuZXh0ZW5kKHJlbWFpbmluZ0ZpbmdlcnByaW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxsT3V0cHV0LmV4dGVuZChvKTtcbiAgICAgIH1cbiAgICAgIHByZXZJbmRleCA9IHVwcGVyO1xuICAgICAgcHJldkJvdW5kID0gY3VyckJvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbE91dHB1dC5sZW5ndGggPT09IDEgPyBudWxsIDogYnl0ZXNUb0hleDUoZnVsbE91dHB1dC51bndyYXAoKSk7XG4gIH1cbiAgc3BsaXRSYW5nZShsb3dlciwgdXBwZXIsIHVwcGVyQm91bmQsIG8pIHtcbiAgICBsZXQgbnVtRWxlbXMgPSB1cHBlciAtIGxvd2VyO1xuICAgIGxldCBidWNrZXRzID0gMTY7XG4gICAgaWYgKG51bUVsZW1zIDwgYnVja2V0cyAqIDIpIHtcbiAgICAgIG8uZXh0ZW5kKHRoaXMuZW5jb2RlQm91bmQodXBwZXJCb3VuZCkpO1xuICAgICAgby5leHRlbmQoZW5jb2RlVmFySW50KE1vZGUuSWRMaXN0KSk7XG4gICAgICBvLmV4dGVuZChlbmNvZGVWYXJJbnQobnVtRWxlbXMpKTtcbiAgICAgIHRoaXMuc3RvcmFnZS5pdGVyYXRlKGxvd2VyLCB1cHBlciwgKGl0ZW0pID0+IHtcbiAgICAgICAgby5leHRlbmQoaXRlbS5pZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpdGVtc1BlckJ1Y2tldCA9IE1hdGguZmxvb3IobnVtRWxlbXMgLyBidWNrZXRzKTtcbiAgICAgIGxldCBidWNrZXRzV2l0aEV4dHJhID0gbnVtRWxlbXMgJSBidWNrZXRzO1xuICAgICAgbGV0IGN1cnIgPSBsb3dlcjtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBidWNrZXRzOyBpMisrKSB7XG4gICAgICAgIGxldCBidWNrZXRTaXplID0gaXRlbXNQZXJCdWNrZXQgKyAoaTIgPCBidWNrZXRzV2l0aEV4dHJhID8gMSA6IDApO1xuICAgICAgICBsZXQgb3VyRmluZ2VycHJpbnQgPSB0aGlzLnN0b3JhZ2UuZmluZ2VycHJpbnQoY3VyciwgY3VyciArIGJ1Y2tldFNpemUpO1xuICAgICAgICBjdXJyICs9IGJ1Y2tldFNpemU7XG4gICAgICAgIGxldCBuZXh0Qm91bmQ7XG4gICAgICAgIGlmIChjdXJyID09PSB1cHBlcikge1xuICAgICAgICAgIG5leHRCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHByZXZJdGVtO1xuICAgICAgICAgIGxldCBjdXJySXRlbTtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2UuaXRlcmF0ZShjdXJyIC0gMSwgY3VyciArIDEsIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBjdXJyIC0gMSlcbiAgICAgICAgICAgICAgcHJldkl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjdXJySXRlbSA9IGl0ZW07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuZXh0Qm91bmQgPSB0aGlzLmdldE1pbmltYWxCb3VuZChwcmV2SXRlbSwgY3Vyckl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIG8uZXh0ZW5kKHRoaXMuZW5jb2RlQm91bmQobmV4dEJvdW5kKSk7XG4gICAgICAgIG8uZXh0ZW5kKGVuY29kZVZhckludChNb2RlLkZpbmdlcnByaW50KSk7XG4gICAgICAgIG8uZXh0ZW5kKG91ckZpbmdlcnByaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXhjZWVkZWRGcmFtZVNpemVMaW1pdChuKSB7XG4gICAgcmV0dXJuIG4gPiB0aGlzLmZyYW1lU2l6ZUxpbWl0IC0gMjAwO1xuICB9XG4gIGRlY29kZVRpbWVzdGFtcEluKGVuY29kZWQpIHtcbiAgICBsZXQgdGltZXN0YW1wID0gZGVjb2RlVmFySW50KGVuY29kZWQpO1xuICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiB0aW1lc3RhbXAgLSAxO1xuICAgIGlmICh0aGlzLmxhc3RUaW1lc3RhbXBJbiA9PT0gTnVtYmVyLk1BWF9WQUxVRSB8fCB0aW1lc3RhbXAgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgIHRoaXMubGFzdFRpbWVzdGFtcEluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICB0aW1lc3RhbXAgKz0gdGhpcy5sYXN0VGltZXN0YW1wSW47XG4gICAgdGhpcy5sYXN0VGltZXN0YW1wSW4gPSB0aW1lc3RhbXA7XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgfVxuICBkZWNvZGVCb3VuZChlbmNvZGVkKSB7XG4gICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuZGVjb2RlVGltZXN0YW1wSW4oZW5jb2RlZCk7XG4gICAgbGV0IGxlbiA9IGRlY29kZVZhckludChlbmNvZGVkKTtcbiAgICBpZiAobGVuID4gSURfU0laRSlcbiAgICAgIHRocm93IEVycm9yKFwiYm91bmQga2V5IHRvbyBsb25nXCIpO1xuICAgIGxldCBpZCA9IGdldEJ5dGVzKGVuY29kZWQsIGxlbik7XG4gICAgcmV0dXJuIHsgdGltZXN0YW1wLCBpZCB9O1xuICB9XG4gIGVuY29kZVRpbWVzdGFtcE91dCh0aW1lc3RhbXApIHtcbiAgICBpZiAodGltZXN0YW1wID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lc3RhbXBPdXQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgcmV0dXJuIGVuY29kZVZhckludCgwKTtcbiAgICB9XG4gICAgbGV0IHRlbXAgPSB0aW1lc3RhbXA7XG4gICAgdGltZXN0YW1wIC09IHRoaXMubGFzdFRpbWVzdGFtcE91dDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXBPdXQgPSB0ZW1wO1xuICAgIHJldHVybiBlbmNvZGVWYXJJbnQodGltZXN0YW1wICsgMSk7XG4gIH1cbiAgZW5jb2RlQm91bmQoa2V5KSB7XG4gICAgbGV0IG91dHB1dCA9IG5ldyBXcmFwcGVkQnVmZmVyKCk7XG4gICAgb3V0cHV0LmV4dGVuZCh0aGlzLmVuY29kZVRpbWVzdGFtcE91dChrZXkudGltZXN0YW1wKSk7XG4gICAgb3V0cHV0LmV4dGVuZChlbmNvZGVWYXJJbnQoa2V5LmlkLmxlbmd0aCkpO1xuICAgIG91dHB1dC5leHRlbmQoa2V5LmlkKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIGdldE1pbmltYWxCb3VuZChwcmV2LCBjdXJyKSB7XG4gICAgaWYgKGN1cnIudGltZXN0YW1wICE9PSBwcmV2LnRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kKGN1cnIudGltZXN0YW1wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNoYXJlZFByZWZpeEJ5dGVzID0gMDtcbiAgICAgIGxldCBjdXJyS2V5ID0gY3Vyci5pZDtcbiAgICAgIGxldCBwcmV2S2V5ID0gcHJldi5pZDtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBJRF9TSVpFOyBpMisrKSB7XG4gICAgICAgIGlmIChjdXJyS2V5W2kyXSAhPT0gcHJldktleVtpMl0pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHNoYXJlZFByZWZpeEJ5dGVzKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmQoY3Vyci50aW1lc3RhbXAsIGN1cnIuaWQuc3ViYXJyYXkoMCwgc2hhcmVkUHJlZml4Qnl0ZXMgKyAxKSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXkoYSwgYikge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgYS5ieXRlTGVuZ3RoOyBpMisrKSB7XG4gICAgaWYgKGFbaTJdIDwgYltpMl0pXG4gICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGFbaTJdID4gYltpMl0pXG4gICAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoYS5ieXRlTGVuZ3RoID4gYi5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBpZiAoYS5ieXRlTGVuZ3RoIDwgYi5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpdGVtQ29tcGFyZShhLCBiKSB7XG4gIGlmIChhLnRpbWVzdGFtcCA9PT0gYi50aW1lc3RhbXApIHtcbiAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXkoYS5pZCwgYi5pZCk7XG4gIH1cbiAgcmV0dXJuIGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXA7XG59XG52YXIgTmVnZW50cm9weVN5bmMgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdG9yYWdlO1xuICBuZWc7XG4gIGZpbHRlcjtcbiAgc3Vic2NyaXB0aW9uO1xuICBvbmhhdmU7XG4gIG9ubmVlZDtcbiAgY29uc3RydWN0b3IocmVsYXksIHN0b3JhZ2UsIGZpbHRlciwgcGFyYW1zID0ge30pIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLm5lZyA9IG5ldyBOZWdlbnRyb3B5KHN0b3JhZ2UpO1xuICAgIHRoaXMub25oYXZlID0gcGFyYW1zLm9uaGF2ZTtcbiAgICB0aGlzLm9ubmVlZCA9IHBhcmFtcy5vbm5lZWQ7XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlbGF5LnByZXBhcmVTdWJzY3JpcHRpb24oW3t9XSwgeyBsYWJlbDogcGFyYW1zLmxhYmVsIHx8IFwibmVnZW50cm9weVwiIH0pO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLm9uY3VzdG9tID0gKGRhdGEpID0+IHtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiTkVHLU1TR1wiOiB7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBnb3QgaW52YWxpZCBORUctTVNHIGZyb20gJHt0aGlzLnJlbGF5LnVybH06ICR7ZGF0YX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5uZWcucmVjb25jaWxlKGRhdGFbMl0sIHRoaXMub25oYXZlLCB0aGlzLm9ubmVlZCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWxheS5zZW5kKGBbXCJORUctTVNHXCIsIFwiJHt0aGlzLnN1YnNjcmlwdGlvbi5pZH1cIiwgXCIke3Jlc3BvbnNlfVwiXWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICBwYXJhbXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJuZWdlbnRyb3B5IHJlY29uY2lsZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcGFyYW1zPy5vbmNsb3NlPy4oYHJlY29uY2lsZSBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5FRy1DTE9TRVwiOiB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJuZWdlbnRyb3B5IGVycm9yOlwiLCByZWFzb24pO1xuICAgICAgICAgIHBhcmFtcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTkVHLUVSUlwiOiB7XG4gICAgICAgICAgcGFyYW1zLm9uY2xvc2U/LigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgICBjb25zdCBpbml0TXNnID0gdGhpcy5uZWcuaW5pdGlhdGUoKTtcbiAgICB0aGlzLnJlbGF5LnNlbmQoYFtcIk5FRy1PUEVOXCIsXCIke3RoaXMuc3Vic2NyaXB0aW9uLmlkfVwiLCR7SlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXIpfSxcIiR7aW5pdE1zZ31cIl1gKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoYFtcIk5FRy1DTE9TRVwiLFwiJHt0aGlzLnN1YnNjcmlwdGlvbi5pZH1cIl1gKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5jbG9zZSgpO1xuICB9XG59O1xuXG4vLyBuaXA5OC50c1xudmFyIG5pcDk4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDk4X2V4cG9ydHMsIHtcbiAgZ2V0VG9rZW46ICgpID0+IGdldFRva2VuLFxuICBoYXNoUGF5bG9hZDogKCkgPT4gaGFzaFBheWxvYWQsXG4gIHVucGFja0V2ZW50RnJvbVRva2VuOiAoKSA9PiB1bnBhY2tFdmVudEZyb21Ub2tlbixcbiAgdmFsaWRhdGVFdmVudDogKCkgPT4gdmFsaWRhdGVFdmVudDIsXG4gIHZhbGlkYXRlRXZlbnRLaW5kOiAoKSA9PiB2YWxpZGF0ZUV2ZW50S2luZCxcbiAgdmFsaWRhdGVFdmVudE1ldGhvZFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyxcbiAgdmFsaWRhdGVFdmVudFBheWxvYWRUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnLFxuICB2YWxpZGF0ZUV2ZW50VGltZXN0YW1wOiAoKSA9PiB2YWxpZGF0ZUV2ZW50VGltZXN0YW1wLFxuICB2YWxpZGF0ZUV2ZW50VXJsVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50VXJsVGFnLFxuICB2YWxpZGF0ZVRva2VuOiAoKSA9PiB2YWxpZGF0ZVRva2VuXG59KTtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTY1IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMi5qc1wiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTY1KHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDYoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIFJlbGF5LFxuICBTaW1wbGVQb29sLFxuICBmaW5hbGl6ZUV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdCxcbiAgZ2V0UHVibGljS2V5LFxuICBraW5kc19leHBvcnRzIGFzIGtpbmRzLFxuICBtYXRjaEZpbHRlcixcbiAgbWF0Y2hGaWx0ZXJzLFxuICBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0X2V4cG9ydHMgYXMgbmlwMDQsXG4gIG5pcDA1X2V4cG9ydHMgYXMgbmlwMDUsXG4gIG5pcDEwX2V4cG9ydHMgYXMgbmlwMTAsXG4gIG5pcDExX2V4cG9ydHMgYXMgbmlwMTEsXG4gIG5pcDEzX2V4cG9ydHMgYXMgbmlwMTMsXG4gIG5pcDE3X2V4cG9ydHMgYXMgbmlwMTcsXG4gIG5pcDE4X2V4cG9ydHMgYXMgbmlwMTgsXG4gIG5pcDE5X2V4cG9ydHMgYXMgbmlwMTksXG4gIG5pcDIxX2V4cG9ydHMgYXMgbmlwMjEsXG4gIG5pcDI1X2V4cG9ydHMgYXMgbmlwMjUsXG4gIG5pcDI3X2V4cG9ydHMgYXMgbmlwMjcsXG4gIG5pcDI4X2V4cG9ydHMgYXMgbmlwMjgsXG4gIG5pcDMwX2V4cG9ydHMgYXMgbmlwMzAsXG4gIG5pcDM5X2V4cG9ydHMgYXMgbmlwMzksXG4gIG5pcDQyX2V4cG9ydHMgYXMgbmlwNDIsXG4gIG5pcDQ0X2V4cG9ydHMgYXMgbmlwNDQsXG4gIG5pcDQ3X2V4cG9ydHMgYXMgbmlwNDcsXG4gIG5pcDU0X2V4cG9ydHMgYXMgbmlwNTQsXG4gIG5pcDU3X2V4cG9ydHMgYXMgbmlwNTcsXG4gIG5pcDU5X2V4cG9ydHMgYXMgbmlwNTksXG4gIG5pcDc3X2V4cG9ydHMgYXMgbmlwNzcsXG4gIG5pcDk4X2V4cG9ydHMgYXMgbmlwOTgsXG4gIHBhcnNlUmVmZXJlbmNlcyxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHMsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlFdmVudFxufTtcbiIsICIvKipcbiAqIFBCS0RGIChSRkMgMjg5OCkuIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGtleSBmcm9tIHBhc3N3b3JkIGFuZCBzYWx0LlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLnRzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHtcbiAgYWhhc2gsIGFudW1iZXIsXG4gIGFzeW5jTG9vcCwgY2hlY2tPcHRzLCBjbGVhbiwgY3JlYXRlVmlldywga2RmSW5wdXRUb0J5dGVzLFxuICB0eXBlIENIYXNoLFxuICB0eXBlIEhhc2gsXG4gIHR5cGUgS0RGSW5wdXRcbn0gZnJvbSAnLi91dGlscy50cyc7XG5cbi8qKlxuICogUEJLREYyIG9wdGlvbnM6XG4gKiAqIGM6IGl0ZXJhdGlvbnMsIHNob3VsZCBwcm9iYWJseSBiZSBoaWdoZXIgdGhhbiAxMDBfMDAwXG4gKiAqIGRrTGVuOiBkZXNpcmVkIGxlbmd0aCBvZiBkZXJpdmVkIGtleSBpbiBieXRlc1xuICogKiBhc3luY1RpY2s6IG1heCB0aW1lIGluIG1zIGZvciB3aGljaCBhc3luYyBmdW5jdGlvbiBjYW4gYmxvY2sgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFBia2RmMk9wdCA9IHtcbiAgYzogbnVtYmVyO1xuICBka0xlbj86IG51bWJlcjtcbiAgYXN5bmNUaWNrPzogbnVtYmVyO1xufTtcbi8vIENvbW1vbiBzdGFydCBhbmQgZW5kIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoOiBDSGFzaCwgX3Bhc3N3b3JkOiBLREZJbnB1dCwgX3NhbHQ6IEtERklucHV0LCBfb3B0czogUGJrZGYyT3B0KSB7XG4gIGFoYXNoKGhhc2gpO1xuICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICBhbnVtYmVyKGMsICdjJyk7XG4gIGFudW1iZXIoZGtMZW4sICdka0xlbicpO1xuICBhbnVtYmVyKGFzeW5jVGljaywgJ2FzeW5jVGljaycpO1xuICBpZiAoYyA8IDEpIHRocm93IG5ldyBFcnJvcignaXRlcmF0aW9ucyAoYykgbXVzdCBiZSA+PSAxJyk7XG4gIGNvbnN0IHBhc3N3b3JkID0ga2RmSW5wdXRUb0J5dGVzKF9wYXNzd29yZCwgJ3Bhc3N3b3JkJyk7XG4gIGNvbnN0IHNhbHQgPSBrZGZJbnB1dFRvQnl0ZXMoX3NhbHQsICdzYWx0Jyk7XG4gIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShka0xlbik7XG4gIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuXG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQ8VCBleHRlbmRzIEhhc2g8VD4+KFxuICBQUkY6IEhhc2g8VD4sXG4gIFBSRlNhbHQ6IEhhc2g8VD4sXG4gIERLOiBVaW50OEFycmF5LFxuICBwcmZXOiBIYXNoPFQ+LFxuICB1OiBVaW50OEFycmF5XG4pIHtcbiAgUFJGLmRlc3Ryb3koKTtcbiAgUFJGU2FsdC5kZXN0cm95KCk7XG4gIGlmIChwcmZXKSBwcmZXLmRlc3Ryb3koKTtcbiAgY2xlYW4odSk7XG4gIHJldHVybiBESztcbn1cblxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGtleSA9IHBia2RmMihzaGEyNTYsICdwYXNzd29yZCcsICdzYWx0JywgeyBka0xlbjogMzIsIGM6IE1hdGgucG93KDIsIDE4KSB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihcbiAgaGFzaDogQ0hhc2gsXG4gIHBhc3N3b3JkOiBLREZJbnB1dCxcbiAgc2FsdDogS0RGSW5wdXQsXG4gIG9wdHM6IFBia2RmMk9wdFxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICBsZXQgcHJmVzogYW55OyAvLyBXb3JraW5nIGNvcHlcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgLy8gREsgPSBUMSArIFQyICsgXHUyMkVGICsgVGRrbGVuL2hsZW5cbiAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiBcdTIyRUYgXiBVY1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWNcdTIyMTIxKVxuICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKSBUaVtpXSBePSB1W2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuXG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi4gQXN5bmMgdmVyc2lvbi5cbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBwYmtkZjJBc3luYyhzaGEyNTYsICdwYXNzd29yZCcsICdzYWx0JywgeyBka0xlbjogMzIsIGM6IDUwMF8wMDAgfSk7XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhcbiAgaGFzaDogQ0hhc2gsXG4gIHBhc3N3b3JkOiBLREZJbnB1dCxcbiAgc2FsdDogS0RGSW5wdXQsXG4gIG9wdHM6IFBia2RmMk9wdFxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gIGxldCBwcmZXOiBhbnk7IC8vIFdvcmtpbmcgY29weVxuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAvLyBESyA9IFQxICsgVDIgKyBcdTIyRUYgKyBUZGtsZW4vaGxlblxuICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIFx1MjJFRiBeIFVjXG4gICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY1x1MjIxMjEpXG4gICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspIFRpW2ldIF49IHVbaV07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbiIsICIvKipcbiAqIFJGQyA3OTE0IFNjcnlwdCBLREYuIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGtleSBmcm9tIHBhc3N3b3JkIGFuZCBzYWx0LlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tICcuL3Bia2RmMi50cyc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICcuL3NoYTIudHMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQge1xuICBhbnVtYmVyLCBhc3luY0xvb3AsXG4gIGNoZWNrT3B0cywgY2xlYW4sXG4gIHR5cGUgS0RGSW5wdXQsIHJvdGwsXG4gIHN3YXAzMklmQkUsXG4gIHUzMlxufSBmcm9tICcuL3V0aWxzLnRzJztcblxuLy8gVGhlIG1haW4gU2NyeXB0IGxvb3A6IHVzZXMgU2Fsc2EgZXh0ZW5zaXZlbHkuXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBYb3JBbmRTYWxzYShcbiAgcHJldjogVWludDMyQXJyYXksXG4gIHBpOiBudW1iZXIsXG4gIGlucHV0OiBVaW50MzJBcnJheSxcbiAgaWk6IG51bWJlcixcbiAgb3V0OiBVaW50MzJBcnJheSxcbiAgb2k6IG51bWJlclxuKSB7XG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vY3IueXAudG8vc2Fsc2EyMC5odG1sXG4gIC8vIFhvciBibG9ja3NcbiAgbGV0IHkwMCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAxID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICBsZXQgeTAyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgbGV0IHkwNiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA3ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICBsZXQgeTA4ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDkgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgbGV0IHkxMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTEzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICBsZXQgeTE0ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTUgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsXG4gICAgICB4MDQgPSB5MDQsIHgwNSA9IHkwNSwgeDA2ID0geTA2LCB4MDcgPSB5MDcsXG4gICAgICB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsXG4gICAgICB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gIC8vIE1haW4gbG9vcCAoc2Fsc2EpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgeDA0IF49IHJvdGwoeDAwICsgeDEyIHwgMCwgIDcpOyB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCAgOSk7XG4gICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpOyB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgeDA5IF49IHJvdGwoeDA1ICsgeDAxIHwgMCwgIDcpOyB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCAgOSk7XG4gICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpOyB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgeDE0IF49IHJvdGwoeDEwICsgeDA2IHwgMCwgIDcpOyB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCAgOSk7XG4gICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpOyB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgeDAzIF49IHJvdGwoeDE1ICsgeDExIHwgMCwgIDcpOyB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCAgOSk7XG4gICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpOyB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgeDAxIF49IHJvdGwoeDAwICsgeDAzIHwgMCwgIDcpOyB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCAgOSk7XG4gICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpOyB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgeDA2IF49IHJvdGwoeDA1ICsgeDA0IHwgMCwgIDcpOyB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCAgOSk7XG4gICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpOyB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgeDExIF49IHJvdGwoeDEwICsgeDA5IHwgMCwgIDcpOyB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCAgOSk7XG4gICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpOyB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgeDEyIF49IHJvdGwoeDE1ICsgeDE0IHwgMCwgIDcpOyB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCAgOSk7XG4gICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpOyB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gIH1cbiAgLy8gV3JpdGUgb3V0cHV0IChzYWxzYSlcbiAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwOyBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDsgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7IG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcbiAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwOyBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDsgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7IG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcbiAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwOyBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDsgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuXG5mdW5jdGlvbiBCbG9ja01peChpbnB1dDogVWludDMyQXJyYXksIGlpOiBudW1iZXIsIG91dDogVWludDMyQXJyYXksIG9pOiBudW1iZXIsIHI6IG51bWJlcikge1xuICAvLyBUaGUgYmxvY2sgQiBpcyByIDEyOC1ieXRlIGNodW5rcyAod2hpY2ggaXMgZXF1aXZhbGVudCBvZiAyciA2NC1ieXRlIGNodW5rcylcbiAgbGV0IGhlYWQgPSBvaSArIDA7XG4gIGxldCB0YWlsID0gb2kgKyAxNiAqIHI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykgb3V0W3RhaWwgKyBpXSA9IGlucHV0W2lpICsgKDIgKiByIC0gMSkgKiAxNiArIGldOyAvLyBYIFx1MjE5MCBCWzJyXHUyMjEyMV1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgLy8gV2Ugd3JpdGUgb2RkICYgZXZlbiBZaSBhdCBzYW1lIHRpbWUuIEV2ZW46IDBiWFhYWFgwIE9kZDogIDBiWFhYWFgxXG4gICAgWG9yQW5kU2Fsc2Eob3V0LCB0YWlsLCBpbnB1dCwgaWksIG91dCwgaGVhZCk7IC8vIGhlYWRbaV0gPSBTYWxzYShibG9ja0luWzIqaV0gXiB0YWlsW2ktMV0pXG4gICAgaWYgKGkgPiAwKSB0YWlsICs9IDE2OyAvLyBGaXJzdCBpdGVyYXRpb24gb3ZlcndyaXRlcyB0bXAgdmFsdWUgaW4gdGFpbFxuICAgIFhvckFuZFNhbHNhKG91dCwgaGVhZCwgaW5wdXQsIChpaSArPSAxNiksIG91dCwgdGFpbCk7IC8vIHRhaWxbaV0gPSBTYWxzYShibG9ja0luWzIqaSsxXSBeIGhlYWRbaV0pXG4gIH1cbn1cblxuLyoqXG4gKiBTY3J5cHQgb3B0aW9uczpcbiAqIC0gYE5gIGlzIGNwdS9tZW0gd29yayBmYWN0b3IgKHBvd2VyIG9mIDIgZS5nLiBgMioqMThgKVxuICogLSBgcmAgaXMgYmxvY2sgc2l6ZSAoOCBpcyBjb21tb24pLCBmaW5lLXR1bmVzIHNlcXVlbnRpYWwgbWVtb3J5IHJlYWQgc2l6ZSBhbmQgcGVyZm9ybWFuY2VcbiAqIC0gYHBgIGlzIHBhcmFsbGVsaXphdGlvbiBmYWN0b3IgKDEgaXMgY29tbW9uKVxuICogLSBgZGtMZW5gIGlzIG91dHB1dCBrZXkgbGVuZ3RoIGluIGJ5dGVzIGUuZy4gMzIuXG4gKiAtIGBhc3luY1RpY2tgIC0gKGRlZmF1bHQ6IDEwKSBtYXggdGltZSBpbiBtcyBmb3Igd2hpY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGJsb2NrIGV4ZWN1dGlvblxuICogLSBgbWF4bWVtYCAtIChkZWZhdWx0OiBgMTAyNCAqKiAzICsgMTAyNGAgYWthIDFHQisxS0IpLiBBIGxpbWl0IHRoYXQgdGhlIGFwcCBjb3VsZCB1c2UgZm9yIHNjcnlwdFxuICogLSBgb25Qcm9ncmVzc2AgLSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIGV4ZWN1dGVkIGZvciBwcm9ncmVzcyByZXBvcnRcbiAqL1xuZXhwb3J0IHR5cGUgU2NyeXB0T3B0cyA9IHtcbiAgTjogbnVtYmVyOyAvLyBjb3N0IGZhY3RvclxuICByOiBudW1iZXI7IC8vIGJsb2NrIHNpemVcbiAgcDogbnVtYmVyOyAvLyBwYXJhbGxlbGl6YXRpb25cbiAgZGtMZW4/OiBudW1iZXI7IC8vIGtleSBsZW5ndGhcbiAgYXN5bmNUaWNrPzogbnVtYmVyOyAvLyBibG9jayBleGVjdXRpb24gbWF4IHRpbWVcbiAgbWF4bWVtPzogbnVtYmVyO1xuICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWQ7XG59O1xuXG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZDogS0RGSW5wdXQsIHNhbHQ6IEtERklucHV0LCBfb3B0cz86IFNjcnlwdE9wdHMpIHtcbiAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XG4gIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoXG4gICAge1xuICAgICAgZGtMZW46IDMyLFxuICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgIG1heG1lbTogMTAyNCAqKiAzICsgMTAyNCxcbiAgICB9LFxuICAgIF9vcHRzXG4gICk7XG4gIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGFzeW5jVGljaywgbWF4bWVtLCBvblByb2dyZXNzIH0gPSBvcHRzO1xuICBhbnVtYmVyKE4sICdOJyk7XG4gIGFudW1iZXIociwgJ3InKTtcbiAgYW51bWJlcihwLCAncCcpO1xuICBhbnVtYmVyKGRrTGVuLCAnZGtMZW4nKTtcbiAgYW51bWJlcihhc3luY1RpY2ssICdhc3luY1RpY2snKTtcbiAgYW51bWJlcihtYXhtZW0sICdtYXhtZW0nKTtcbiAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2dyZXNzQ2IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIGNvbnN0IGJsb2NrU2l6ZSA9IDEyOCAqIHI7XG4gIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcblxuICAvLyBNYXggTiBpcyAyXjMyIChJbnRlZ3JpZnkgaXMgMzItYml0KS5cbiAgLy8gUmVhbCBsaW1pdCBjYW4gYmUgMl4yMjogc29tZSBKUyBlbmdpbmVzIGxpbWl0IFVpbnQ4QXJyYXkgdG8gNEdCLlxuICAvLyBTcGVjIGNoZWNrIGBOID49IDJeKGJsb2NrU2l6ZSAvIDgpYCBpcyBub3QgZG9uZSBmb3IgY29tcGF0IHdpdGggcG9wdWxhciBsaWJzLFxuICAvLyB3aGljaCB1c2VkIGluY29ycmVjdCByOiAxLCBwOiA4LiBBbHNvLCB0aGUgY2hlY2sgc2VlbXMgdG8gYmUgYSBzcGVjIGVycm9yOlxuICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9lcnJhdGFfc2VhcmNoLnBocD9yZmM9NzkxNFxuICBjb25zdCBwb3czMiA9IE1hdGgucG93KDIsIDMyKTtcbiAgaWYgKE4gPD0gMSB8fCAoTiAmIChOIC0gMSkpICE9PSAwIHx8IE4gPiBwb3czMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiTlwiIGV4cGVjdGVkIGEgcG93ZXIgb2YgMiwgYW5kIDJeMSA8PSBOIDw9IDJeMzInKTtcbiAgaWYgKHAgPCAxIHx8IHAgPiAoKHBvdzMyIC0gMSkgKiAzMikgLyBibG9ja1NpemUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInBcIiBleHBlY3RlZCBpbnRlZ2VyIDEuLigoMl4zMiAtIDEpICogMzIpIC8gKDEyOCAqIHIpJyk7XG4gIGlmIChka0xlbiA8IDEgfHwgZGtMZW4gPiAocG93MzIgLSAxKSAqIDMyKVxuICAgIHRocm93IG5ldyBFcnJvcignXCJka0xlblwiIGV4cGVjdGVkIGludGVnZXIgMS4uKDJeMzIgLSAxKSAqIDMyJyk7XG4gIGNvbnN0IG1lbVVzZWQgPSBibG9ja1NpemUgKiAoTiArIHApO1xuICBpZiAobWVtVXNlZCA+IG1heG1lbSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWF4bWVtXCIgbGltaXQgd2FzIGhpdCwgZXhwZWN0ZWQgMTI4KnIqKE4rcCkgPD0gXCJtYXhtZW1cIj0nICsgbWF4bWVtKTtcbiAgLy8gW0IwLi4uQnBcdTIyMTIxXSBcdTIxOTAgUEJLREYySE1BQy1TSEEyNTYoUGFzc3BocmFzZSwgU2FsdCwgMSwgYmxvY2tTaXplKlBhcmFsbGVsaXphdGlvbkZhY3RvcilcbiAgLy8gU2luY2UgaXQgaGFzIG9ubHkgb25lIGl0ZXJhdGlvbiB0aGVyZSBpcyBubyByZWFzb24gdG8gdXNlIGFzeW5jIHZhcmlhbnRcbiAgY29uc3QgQiA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBzYWx0LCB7IGM6IDEsIGRrTGVuOiBibG9ja1NpemUgKiBwIH0pO1xuICBjb25zdCBCMzIgPSB1MzIoQik7XG4gIC8vIFJlLXVzZWQgYmV0d2VlbiBwYXJhbGxlbCBpdGVyYXRpb25zLiBBcnJheShpdGVyYXRpb25zKSBvZiBCXG4gIGNvbnN0IFYgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogTikpO1xuICBjb25zdCB0bXAgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplKSk7XG4gIGxldCBibG9ja01peENiID0gKCkgPT4ge307XG4gIGlmIChvblByb2dyZXNzKSB7XG4gICAgY29uc3QgdG90YWxCbG9ja01peCA9IDIgKiBOICogcDtcbiAgICAvLyBJbnZva2UgY2FsbGJhY2sgaWYgcHJvZ3Jlc3MgY2hhbmdlcyBmcm9tIDEwLjAxIHRvIDEwLjAyXG4gICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICBjb25zdCBjYWxsYmFja1BlciA9IE1hdGgubWF4KE1hdGguZmxvb3IodG90YWxCbG9ja01peCAvIDEwMDAwKSwgMSk7XG4gICAgbGV0IGJsb2NrTWl4Q250ID0gMDtcbiAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgb25Qcm9ncmVzcyhibG9ja01peENudCAvIHRvdGFsQmxvY2tNaXgpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH07XG59XG5cbmZ1bmN0aW9uIHNjcnlwdE91dHB1dChcbiAgcGFzc3dvcmQ6IEtERklucHV0LFxuICBka0xlbjogbnVtYmVyLFxuICBCOiBVaW50OEFycmF5LFxuICBWOiBVaW50MzJBcnJheSxcbiAgdG1wOiBVaW50MzJBcnJheVxuKSB7XG4gIGNvbnN0IHJlcyA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBCLCB7IGM6IDEsIGRrTGVuIH0pO1xuICBjbGVhbihCLCBWLCB0bXApO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC4gU2VlIHtAbGluayBTY3J5cHRPcHRzfS5cbiAqIEBleGFtcGxlXG4gKiBzY3J5cHQoJ3Bhc3N3b3JkJywgJ3NhbHQnLCB7IE46IDIqKjE4LCByOiA4LCBwOiAxLCBka0xlbjogMzIgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3J5cHQocGFzc3dvcmQ6IEtERklucHV0LCBzYWx0OiBLREZJbnB1dCwgb3B0czogU2NyeXB0T3B0cyk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IgfSA9IHNjcnlwdEluaXQoXG4gICAgcGFzc3dvcmQsXG4gICAgc2FsdCxcbiAgICBvcHRzXG4gICk7XG4gIHN3YXAzMklmQkUoQjMyKTtcbiAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKSBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XG4gICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICBibG9ja01peENiKCk7XG4gICAgfVxuICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgYmxvY2tNaXhDYigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgLy8gJiAoTiAtIDEpIGlzICUgTiBhcyBOIGlzIGEgcG93ZXIgb2YgMiwgTiAmIChOIC0gMSkgPSAwIGlzIGNoZWNrZWQgYWJvdmU7ID4+PiAwIGZvciB1bnNpZ25lZCwgaW5wdXQgZml0cyBpbiB1MzJcbiAgICAgIGNvbnN0IGogPSAoQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJiAoTiAtIDEpKSA+Pj4gMDsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKykgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgYmxvY2tNaXhDYigpO1xuICAgIH1cbiAgfVxuICBzd2FwMzJJZkJFKEIzMik7XG4gIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuXG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC4gQXN5bmMgdmVyc2lvbi4gU2VlIHtAbGluayBTY3J5cHRPcHRzfS5cbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBzY3J5cHRBc3luYygncGFzc3dvcmQnLCAnc2FsdCcsIHsgTjogMioqMTgsIHI6IDgsIHA6IDEsIGRrTGVuOiAzMiB9KTtcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdEFzeW5jKFxuICBwYXNzd29yZDogS0RGSW5wdXQsXG4gIHNhbHQ6IEtERklucHV0LFxuICBvcHRzOiBTY3J5cHRPcHRzXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfSA9IHNjcnlwdEluaXQoXG4gICAgcGFzc3dvcmQsXG4gICAgc2FsdCxcbiAgICBvcHRzXG4gICk7XG4gIHN3YXAzMklmQkUoQjMyKTtcbiAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKSBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgYXdhaXQgYXN5bmNMb29wKE4gLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICB9KTtcbiAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgIGJsb2NrTWl4Q2IoKTtcbiAgICBhd2FpdCBhc3luY0xvb3AoTiwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgLy8gJiAoTiAtIDEpIGlzICUgTiBhcyBOIGlzIGEgcG93ZXIgb2YgMiwgTiAmIChOIC0gMSkgPSAwIGlzIGNoZWNrZWQgYWJvdmU7ID4+PiAwIGZvciB1bnNpZ25lZCwgaW5wdXQgZml0cyBpbiB1MzJcbiAgICAgIGNvbnN0IGogPSAoQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJiAoTiAtIDEpKSA+Pj4gMDsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKykgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgYmxvY2tNaXhDYigpO1xuICAgIH0pO1xuICB9XG4gIHN3YXAzMklmQkUoQjMyKTtcbiAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4iLCAiLy8gbmlwNDkudHNcbmltcG9ydCB7IGJlY2gzMiBhcyBiZWNoMzIyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgeyBzY3J5cHQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zY3J5cHQuanNcIjtcbmltcG9ydCB7IHhjaGFjaGEyMHBvbHkxMzA1IH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL2NoYWNoYS5qc1wiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXMyLCByYW5kb21CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCI7XG5cbi8vIG5pcDE5LnRzXG5pbXBvcnQgeyBieXRlc1RvSGV4LCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBCZWNoMzJNYXhTaXplID0gNWUzO1xuZnVuY3Rpb24gZW5jb2RlQmVjaDMyKHByZWZpeCwgZGF0YSkge1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIocHJlZml4LCBieXRlcyk7XG59XG5cbi8vIG5pcDQ5LnRzXG5mdW5jdGlvbiBlbmNyeXB0KHNlYywgcGFzc3dvcmQsIGxvZ24gPSAxNiwga3NiID0gMikge1xuICBsZXQgc2FsdCA9IHJhbmRvbUJ5dGVzKDE2KTtcbiAgbGV0IG4gPSAyICoqIGxvZ247XG4gIGxldCBrZXkgPSBzY3J5cHQocGFzc3dvcmQubm9ybWFsaXplKFwiTkZLQ1wiKSwgc2FsdCwgeyBOOiBuLCByOiA4LCBwOiAxLCBka0xlbjogMzIgfSk7XG4gIGxldCBub25jZSA9IHJhbmRvbUJ5dGVzKDI0KTtcbiAgbGV0IGFhZCA9IFVpbnQ4QXJyYXkuZnJvbShba3NiXSk7XG4gIGxldCB4YzJwMSA9IHhjaGFjaGEyMHBvbHkxMzA1KGtleSwgbm9uY2UsIGFhZCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0geGMycDEuZW5jcnlwdChzZWMpO1xuICBsZXQgYiA9IGNvbmNhdEJ5dGVzMihVaW50OEFycmF5LmZyb20oWzJdKSwgVWludDhBcnJheS5mcm9tKFtsb2duXSksIHNhbHQsIG5vbmNlLCBhYWQsIGNpcGhlcnRleHQpO1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuY3J5cHRzZWNcIiwgYik7XG59XG5mdW5jdGlvbiBkZWNyeXB0KG5jcnlwdHNlYywgcGFzc3dvcmQpIHtcbiAgbGV0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMyMi5kZWNvZGUobmNyeXB0c2VjLCBCZWNoMzJNYXhTaXplKTtcbiAgaWYgKHByZWZpeCAhPT0gXCJuY3J5cHRzZWNcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcmVmaXggJHtwcmVmaXh9LCBleHBlY3RlZCAnbmNyeXB0c2VjJ2ApO1xuICB9XG4gIGxldCBiID0gbmV3IFVpbnQ4QXJyYXkoYmVjaDMyMi5mcm9tV29yZHMod29yZHMpKTtcbiAgbGV0IHZlcnNpb24gPSBiWzBdO1xuICBpZiAodmVyc2lvbiAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB2ZXJzaW9uICR7dmVyc2lvbn0sIGV4cGVjdGVkIDB4MDJgKTtcbiAgfVxuICBsZXQgbG9nbiA9IGJbMV07XG4gIGxldCBuID0gMiAqKiBsb2duO1xuICBsZXQgc2FsdCA9IGIuc2xpY2UoMiwgMiArIDE2KTtcbiAgbGV0IG5vbmNlID0gYi5zbGljZSgyICsgMTYsIDIgKyAxNiArIDI0KTtcbiAgbGV0IGtzYiA9IGJbMiArIDE2ICsgMjRdO1xuICBsZXQgYWFkID0gVWludDhBcnJheS5mcm9tKFtrc2JdKTtcbiAgbGV0IGNpcGhlcnRleHQgPSBiLnNsaWNlKDIgKyAxNiArIDI0ICsgMSk7XG4gIGxldCBrZXkgPSBzY3J5cHQocGFzc3dvcmQubm9ybWFsaXplKFwiTkZLQ1wiKSwgc2FsdCwgeyBOOiBuLCByOiA4LCBwOiAxLCBka0xlbjogMzIgfSk7XG4gIGxldCB4YzJwMSA9IHhjaGFjaGEyMHBvbHkxMzA1KGtleSwgbm9uY2UsIGFhZCk7XG4gIGxldCBzZWMgPSB4YzJwMS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICByZXR1cm4gc2VjO1xufVxuZXhwb3J0IHtcbiAgZGVjcnlwdCxcbiAgZW5jcnlwdFxufTtcbiIsICIvKipcbiAqIEtleSBnZW5lcmF0aW9uIHV0aWxpdGllcyBmb3IgTm9zdHJcbiAqIFxuICogVXNlcyBzY2hub3JyLXNwZWNpZmljIGZ1bmN0aW9ucyBmcm9tIEBub2JsZS9jdXJ2ZXMgYXMgcmVxdWlyZWQgYnkgTklQLTAxLlxuICogVGhpcyBlbnN1cmVzIHByb3BlciBrZXkgZ2VuZXJhdGlvbiBjb21wYXRpYmxlIHdpdGggdGhlIE5vc3RyIHByb3RvY29sLlxuICovXG5cbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyBOb3N0ciBrZXlwYWlyIHVzaW5nIHNjaG5vcnIgZnVuY3Rpb25zLlxuICogUmV0dXJucyB0aGUgcHJpdmF0ZSBrZXkgYXMgaGV4IHN0cmluZyBhbmQgcHVibGljIGtleSBhcyBoZXggc3RyaW5nLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVLZXlQYWlyKCkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlCeXRlcyA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXZhdGVLZXlCeXRlcyk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJpdmF0ZUtleTogYnl0ZXNUb0hleChwcml2YXRlS2V5Qnl0ZXMpLFxuICAgICAgICBwdWJsaWNLZXk6IGJ5dGVzVG9IZXgocHVibGljS2V5Qnl0ZXMpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwdWJsaWMga2V5IGZyb20gYSBwcml2YXRlIGtleSAoaGV4IHN0cmluZykuXG4gKiBVc2VzIHNjaG5vcnIuZ2V0UHVibGljS2V5IGFzIHJlcXVpcmVkIGJ5IE5vc3RyL0JJUDM0MC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleUZyb21Qcml2YXRlKHByaXZhdGVLZXlIZXgpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5Qnl0ZXMgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlIZXgpO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2Nobm9yci5nZXRQdWJsaWNLZXkocHJpdmF0ZUtleUJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChwdWJsaWNLZXlCeXRlcyk7XG59XG5cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIFVpbnQ4QXJyYXlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IHsgYnl0ZXNUb0hleCB9O1xuIiwgImNvbnN0IEVfVElNRU9VVCA9IG5ldyBFcnJvcigndGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBtdXRleCB0byBiZWNvbWUgYXZhaWxhYmxlJyk7XG5jb25zdCBFX0FMUkVBRFlfTE9DS0VEID0gbmV3IEVycm9yKCdtdXRleCBhbHJlYWR5IGxvY2tlZCcpO1xuY29uc3QgRV9DQU5DRUxFRCA9IG5ldyBFcnJvcigncmVxdWVzdCBmb3IgbG9jayBjYW5jZWxlZCcpO1xuXG52YXIgX19hd2FpdGVyJDIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfY2FuY2VsRXJyb3IgPSBFX0NBTkNFTEVEKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jYW5jZWxFcnJvciA9IF9jYW5jZWxFcnJvcjtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzID0gW107XG4gICAgfVxuICAgIGFjcXVpcmUod2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0geyByZXNvbHZlLCByZWplY3QsIHdlaWdodCwgcHJpb3JpdHkgfTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBmaW5kSW5kZXhGcm9tRW5kKHRoaXMuX3F1ZXVlLCAob3RoZXIpID0+IHByaW9yaXR5IDw9IG90aGVyLnByaW9yaXR5KTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSAmJiB3ZWlnaHQgPD0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyBpbW1lZGlhdGUgZGlzcGF0Y2gsIHNraXAgdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hJdGVtKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFja18xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChjYWxsYmFjaywgd2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHJlbGVhc2VdID0geWllbGQgdGhpcy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jayh3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvdWxkTG9ja0ltbWVkaWF0ZWx5KHdlaWdodCwgcHJpb3JpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSwgeyByZXNvbHZlLCBwcmlvcml0eSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPD0gMDtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hRdWV1ZSgpO1xuICAgIH1cbiAgICByZWxlYXNlKHdlaWdodCA9IDEpIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgKz0gd2VpZ2h0O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaCgoZW50cnkpID0+IGVudHJ5LnJlamVjdCh0aGlzLl9jYW5jZWxFcnJvcikpO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBfZGlzcGF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX3F1ZXVlWzBdLndlaWdodCA8PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hJdGVtKHRoaXMuX3F1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Rpc3BhdGNoSXRlbShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgLT0gaXRlbS53ZWlnaHQ7XG4gICAgICAgIGl0ZW0ucmVzb2x2ZShbcHJldmlvdXNWYWx1ZSwgdGhpcy5fbmV3UmVsZWFzZXIoaXRlbS53ZWlnaHQpXSk7XG4gICAgfVxuICAgIF9uZXdSZWxlYXNlcih3ZWlnaHQpIHtcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9kcmFpblVubG9ja1dhaXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRlcnMgPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCF3YWl0ZXJzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB3YWl0ZXJzLmZvckVhY2goKHdhaXRlcikgPT4gd2FpdGVyLnJlc29sdmUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZWRQcmlvcml0eSA9IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5O1xuICAgICAgICAgICAgZm9yIChsZXQgd2VpZ2h0ID0gdGhpcy5fdmFsdWU7IHdlaWdodCA+IDA7IHdlaWdodC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGVycyA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXdhaXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YWl0ZXJzLmZpbmRJbmRleCgod2FpdGVyKSA9PiB3YWl0ZXIucHJpb3JpdHkgPD0gcXVldWVkUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIChpID09PSAtMSA/IHdhaXRlcnMgOiB3YWl0ZXJzLnNwbGljZSgwLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKHdhaXRlciA9PiB3YWl0ZXIucmVzb2x2ZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvdWxkTG9ja0ltbWVkaWF0ZWx5KHdlaWdodCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDAgfHwgdGhpcy5fcXVldWVbMF0ucHJpb3JpdHkgPCBwcmlvcml0eSkgJiZcbiAgICAgICAgICAgIHdlaWdodCA8PSB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYSwgdikge1xuICAgIGNvbnN0IGkgPSBmaW5kSW5kZXhGcm9tRW5kKGEsIChvdGhlcikgPT4gdi5wcmlvcml0eSA8PSBvdGhlci5wcmlvcml0eSk7XG4gICAgYS5zcGxpY2UoaSArIDEsIDAsIHYpO1xufVxuZnVuY3Rpb24gZmluZEluZGV4RnJvbUVuZChhLCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbnZhciBfX2F3YWl0ZXIkMSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY2xhc3MgTXV0ZXgge1xuICAgIGNvbnN0cnVjdG9yKGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NlbWFwaG9yZSA9IG5ldyBTZW1hcGhvcmUoMSwgY2FuY2VsRXJyb3IpO1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAocHJpb3JpdHkgPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbLCByZWxlYXNlcl0gPSB5aWVsZCB0aGlzLl9zZW1hcGhvcmUuYWNxdWlyZSgxLCBwcmlvcml0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHByaW9yaXR5ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLnJ1bkV4Y2x1c2l2ZSgoKSA9PiBjYWxsYmFjaygpLCAxLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2socHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUud2FpdEZvclVubG9jaygxLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKSlcbiAgICAgICAgICAgIHRoaXMuX3NlbWFwaG9yZS5yZWxlYXNlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5jYW5jZWwoKTtcbiAgICB9XG59XG5cbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIHdpdGhUaW1lb3V0KHN5bmMsIHRpbWVvdXQsIHRpbWVvdXRFcnJvciA9IEVfVElNRU9VVCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjcXVpcmU6ICh3ZWlnaHRPclByaW9yaXR5LCBwcmlvcml0eSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdlaWdodDtcbiAgICAgICAgICAgIGlmIChpc1NlbWFwaG9yZShzeW5jKSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCAoaXNTZW1hcGhvcmUoc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3luYy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN5bmMuYWNxdWlyZShwcmlvcml0eSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlID0gQXJyYXkuaXNBcnJheSh0aWNrZXQpID8gdGlja2V0WzFdIDogdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRpY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHdlaWdodCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgdGhpcy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aWNrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHRpY2tldFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsZWFzZSh3ZWlnaHQpIHtcbiAgICAgICAgICAgIHN5bmMucmVsZWFzZSh3ZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3luYy5jYW5jZWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdEZvclVubG9jazogKHdlaWdodE9yUHJpb3JpdHksIHByaW9yaXR5KSA9PiB7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKGlzU2VtYXBob3JlKHN5bmMpKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdCh0aW1lb3V0RXJyb3IpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAoaXNTZW1hcGhvcmUoc3luYylcbiAgICAgICAgICAgICAgICAgICAgPyBzeW5jLndhaXRGb3JVbmxvY2sod2VpZ2h0LCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBzeW5jLndhaXRGb3JVbmxvY2socHJpb3JpdHkpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpc0xvY2tlZDogKCkgPT4gc3luYy5pc0xvY2tlZCgpLFxuICAgICAgICBnZXRWYWx1ZTogKCkgPT4gc3luYy5nZXRWYWx1ZSgpLFxuICAgICAgICBzZXRWYWx1ZTogKHZhbHVlKSA9PiBzeW5jLnNldFZhbHVlKHZhbHVlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNTZW1hcGhvcmUoc3luYykge1xuICAgIHJldHVybiBzeW5jLmdldFZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGlzbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gdHJ5QWNxdWlyZShzeW5jLCBhbHJlYWR5QWNxdWlyZWRFcnJvciA9IEVfQUxSRUFEWV9MT0NLRUQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiB3aXRoVGltZW91dChzeW5jLCAwLCBhbHJlYWR5QWNxdWlyZWRFcnJvcik7XG59XG5cbmV4cG9ydCB7IEVfQUxSRUFEWV9MT0NLRUQsIEVfQ0FOQ0VMRUQsIEVfVElNRU9VVCwgTXV0ZXgsIFNlbWFwaG9yZSwgdHJ5QWNxdWlyZSwgd2l0aFRpbWVvdXQgfTtcbiIsICIvKipcbiAqIEJyb3dzZXIgQVBJIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIENocm9tZSAvIFNhZmFyaSAvIEZpcmVmb3guXG4gKlxuICogU2FmYXJpIGFuZCBGaXJlZm94IGV4cG9zZSBgYnJvd3Nlci4qYCAoUHJvbWlzZS1iYXNlZCwgV2ViRXh0ZW5zaW9uIHN0YW5kYXJkKS5cbiAqIENocm9tZSBleHBvc2VzIGBjaHJvbWUuKmAgKGNhbGxiYWNrLWJhc2VkIGhpc3RvcmljYWxseSwgYnV0IE1WMyBzdXBwb3J0c1xuICogcHJvbWlzZXMgb24gbW9zdCBBUElzKS4gSW4gYSBzZXJ2aWNlLXdvcmtlciBjb250ZXh0IGBicm93c2VyYCBpcyB1bmRlZmluZWRcbiAqIG9uIENocm9tZSwgc28gd2Ugbm9ybWFsaXNlIGV2ZXJ5dGhpbmcgaGVyZS5cbiAqXG4gKiBVc2FnZTogIGltcG9ydCB7IGFwaSB9IGZyb20gJy4vdXRpbGl0aWVzL2Jyb3dzZXItcG9seWZpbGwnO1xuICogICAgICAgICBhcGkucnVudGltZS5zZW5kTWVzc2FnZSguLi4pXG4gKlxuICogVGhlIGV4cG9ydGVkIGBhcGlgIG9iamVjdCBtaXJyb3JzIHRoZSBzdWJzZXQgb2YgdGhlIFdlYkV4dGVuc2lvbiBBUEkgdGhhdFxuICogTm9zdHJLZXkgYWN0dWFsbHkgdXNlcywgd2l0aCBldmVyeSBtZXRob2QgcmV0dXJuaW5nIGEgUHJvbWlzZS5cbiAqL1xuXG4vLyBEZXRlY3Qgd2hpY2ggZ2xvYmFsIG5hbWVzcGFjZSBpcyBhdmFpbGFibGUuXG5jb25zdCBfYnJvd3NlciA9XG4gICAgdHlwZW9mIGJyb3dzZXIgIT09ICd1bmRlZmluZWQnID8gYnJvd3NlciA6XG4gICAgdHlwZW9mIGNocm9tZSAgIT09ICd1bmRlZmluZWQnID8gY2hyb21lICA6XG4gICAgbnVsbDtcblxuaWYgKCFfYnJvd3Nlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1wb2x5ZmlsbDogTm8gZXh0ZW5zaW9uIEFQSSBuYW1lc3BhY2UgZm91bmQgKG5laXRoZXIgYnJvd3NlciBub3IgY2hyb21lKS4nKTtcbn1cblxuLyoqXG4gKiBUcnVlIHdoZW4gcnVubmluZyBvbiBDaHJvbWUgKG9yIGFueSBDaHJvbWl1bS1iYXNlZCBicm93c2VyIHRoYXQgb25seVxuICogZXhwb3NlcyB0aGUgYGNocm9tZWAgbmFtZXNwYWNlKS5cbiAqL1xuY29uc3QgaXNDaHJvbWUgPSB0eXBlb2YgYnJvd3NlciA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogV3JhcCBhIENocm9tZSBjYWxsYmFjay1zdHlsZSBtZXRob2Qgc28gaXQgcmV0dXJucyBhIFByb21pc2UuXG4gKiBJZiB0aGUgbWV0aG9kIGFscmVhZHkgcmV0dXJucyBhIHByb21pc2UgKE1WMykgd2UganVzdCBwYXNzIHRocm91Z2guXG4gKi9cbmZ1bmN0aW9uIHByb21pc2lmeShjb250ZXh0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gTVYzIENocm9tZSBBUElzIHJldHVybiBwcm9taXNlcyB3aGVuIG5vIGNhbGxiYWNrIGlzIHN1cHBsaWVkLlxuICAgICAgICAvLyBXZSB0cnkgdGhlIHByb21pc2UgcGF0aCBmaXJzdDsgaWYgdGhlIHJ1bnRpbWUgc2lnbmFscyBhbiBlcnJvclxuICAgICAgICAvLyB2aWEgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yIGluc2lkZSBhIGNhbGxiYWNrIHdlIGNhdGNoIHRoYXQgdG9vLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gY2FsbGJhY2sgd3JhcHBpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkoY29udGV4dCwgW1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgKC4uLmNiQXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2Jyb3dzZXIucnVudGltZSAmJiBfYnJvd3Nlci5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihfYnJvd3Nlci5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNiQXJncy5sZW5ndGggPD0gMSA/IGNiQXJnc1swXSA6IGNiQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQnVpbGQgdGhlIHVuaWZpZWQgYGFwaWAgb2JqZWN0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYXBpID0ge307XG5cbi8vIC0tLSBydW50aW1lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYXBpLnJ1bnRpbWUgPSB7XG4gICAgLyoqXG4gICAgICogc2VuZE1lc3NhZ2UgXHUyMDEzIGFsd2F5cyByZXR1cm5zIGEgUHJvbWlzZS5cbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghaXNDaHJvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci5ydW50aW1lLnNlbmRNZXNzYWdlKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkoX2Jyb3dzZXIucnVudGltZSwgX2Jyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZSkoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG9uTWVzc2FnZSBcdTIwMTMgdGhpbiB3cmFwcGVyIHNvIGNhbGxlcnMgdXNlIGEgY29uc2lzdGVudCByZWZlcmVuY2UuXG4gICAgICogVGhlIGxpc3RlbmVyIHNpZ25hdHVyZSBpcyAobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpLlxuICAgICAqIE9uIENocm9tZSB0aGUgbGlzdGVuZXIgY2FuIHJldHVybiBgdHJ1ZWAgdG8ga2VlcCB0aGUgY2hhbm5lbCBvcGVuLFxuICAgICAqIG9yIHJldHVybiBhIFByb21pc2UgKE1WMykuICBTYWZhcmkgLyBGaXJlZm94IGV4cGVjdCBhIFByb21pc2UgcmV0dXJuLlxuICAgICAqL1xuICAgIG9uTWVzc2FnZTogX2Jyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UsXG5cbiAgICAvKipcbiAgICAgKiBnZXRVUkwgXHUyMDEzIHN5bmNocm9ub3VzIG9uIGFsbCBicm93c2Vycy5cbiAgICAgKi9cbiAgICBnZXRVUkwocGF0aCkge1xuICAgICAgICByZXR1cm4gX2Jyb3dzZXIucnVudGltZS5nZXRVUkwocGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG9wZW5PcHRpb25zUGFnZVxuICAgICAqL1xuICAgIG9wZW5PcHRpb25zUGFnZSgpIHtcbiAgICAgICAgaWYgKCFpc0Nocm9tZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9icm93c2VyLnJ1bnRpbWUub3Blbk9wdGlvbnNQYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2lmeShfYnJvd3Nlci5ydW50aW1lLCBfYnJvd3Nlci5ydW50aW1lLm9wZW5PcHRpb25zUGFnZSkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIHRoZSBpZCBmb3IgY29udmVuaWVuY2UuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gX2Jyb3dzZXIucnVudGltZS5pZDtcbiAgICB9LFxufTtcblxuLy8gLS0tIHN0b3JhZ2UubG9jYWwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5hcGkuc3RvcmFnZSA9IHtcbiAgICBsb2NhbDoge1xuICAgICAgICBnZXQoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFpc0Nocm9tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkoX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbCwgX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQpKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFpc0Nocm9tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkoX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbCwgX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbC5zZXQpKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhciguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ2hyb21lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9icm93c2VyLnN0b3JhZ2UubG9jYWwuY2xlYXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KF9icm93c2VyLnN0b3JhZ2UubG9jYWwsIF9icm93c2VyLnN0b3JhZ2UubG9jYWwuY2xlYXIpKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmUoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFpc0Nocm9tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnJlbW92ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkoX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbCwgX2Jyb3dzZXIuc3RvcmFnZS5sb2NhbC5yZW1vdmUpKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG4vLyAtLS0gdGFicyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmFwaS50YWJzID0ge1xuICAgIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghaXNDaHJvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci50YWJzLmNyZWF0ZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KF9icm93c2VyLnRhYnMsIF9icm93c2VyLnRhYnMuY3JlYXRlKSguLi5hcmdzKTtcbiAgICB9LFxuICAgIHF1ZXJ5KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFpc0Nocm9tZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9icm93c2VyLnRhYnMucXVlcnkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2lmeShfYnJvd3Nlci50YWJzLCBfYnJvd3Nlci50YWJzLnF1ZXJ5KSguLi5hcmdzKTtcbiAgICB9LFxuICAgIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghaXNDaHJvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci50YWJzLnJlbW92ZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KF9icm93c2VyLnRhYnMsIF9icm93c2VyLnRhYnMucmVtb3ZlKSguLi5hcmdzKTtcbiAgICB9LFxuICAgIHVwZGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghaXNDaHJvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci50YWJzLnVwZGF0ZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KF9icm93c2VyLnRhYnMsIF9icm93c2VyLnRhYnMudXBkYXRlKSguLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgIGlmICghaXNDaHJvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfYnJvd3Nlci50YWJzLmdldCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KF9icm93c2VyLnRhYnMsIF9icm93c2VyLnRhYnMuZ2V0KSguLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnQoLi4uYXJncykge1xuICAgICAgICBpZiAoIWlzQ2hyb21lKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Jyb3dzZXIudGFicy5nZXRDdXJyZW50KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkoX2Jyb3dzZXIudGFicywgX2Jyb3dzZXIudGFicy5nZXRDdXJyZW50KSguLi5hcmdzKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgYXBpLCBpc0Nocm9tZSB9O1xuIiwgIi8qKlxuICogRW5jcnlwdGlvbiB1dGlsaXRpZXMgZm9yIE5vc3RyS2V5IG1hc3RlciBwYXNzd29yZCBmZWF0dXJlLlxuICpcbiAqIFVzZXMgV2ViIENyeXB0byBBUEkgKGNyeXB0by5zdWJ0bGUpIGV4Y2x1c2l2ZWx5IFx1MjAxNCBubyBleHRlcm5hbCBsaWJyYXJpZXMuXG4gKiAtIFBCS0RGMiB3aXRoIDYwMCwwMDAgaXRlcmF0aW9ucyAoT1dBU1AgMjAyMyByZWNvbW1lbmRhdGlvbilcbiAqIC0gQUVTLTI1Ni1HQ00gZm9yIGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvblxuICogLSBSYW5kb20gc2FsdCAoMTYgYnl0ZXMpIGFuZCBJViAoMTIgYnl0ZXMpIHBlciBvcGVyYXRpb25cbiAqIC0gQWxsIGJpbmFyeSBkYXRhIGVuY29kZWQgYXMgYmFzZTY0IGZvciBKU09OIHN0b3JhZ2UgY29tcGF0aWJpbGl0eVxuICovXG5cbmNvbnN0IFBCS0RGMl9JVEVSQVRJT05TID0gNjAwXzAwMDtcbmNvbnN0IFNBTFRfQllURVMgPSAxNjtcbmNvbnN0IElWX0JZVEVTID0gMTI7XG5cbi8vIC0tLSBCYXNlNjQgaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgbGV0IGJpbmFyeSA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NCkge1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5idWZmZXI7XG59XG5cbi8vIC0tLSBLZXkgZGVyaXZhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBEZXJpdmUgYW4gQUVTLTI1Ni1HQ00gQ3J5cHRvS2V5IGZyb20gYSBwYXNzd29yZCBhbmQgc2FsdCB1c2luZyBQQktERjIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIG1hc3RlciBwYXNzd29yZFxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxVaW50OEFycmF5fSBzYWx0IC0gMTYtYnl0ZSBzYWx0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDcnlwdG9LZXk+fSBBRVMtMjU2LUdDTSBrZXlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleShwYXNzd29yZCwgc2FsdCkge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICAgICdyYXcnLFxuICAgICAgICBlbmMuZW5jb2RlKHBhc3N3b3JkKSxcbiAgICAgICAgJ1BCS0RGMicsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBbJ2Rlcml2ZUtleSddXG4gICAgKTtcblxuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICAgICAgICBzYWx0OiBzYWx0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHNhbHQgOiBuZXcgVWludDhBcnJheShzYWx0KSxcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IFBCS0RGMl9JVEVSQVRJT05TLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICB9LFxuICAgICAgICBrZXlNYXRlcmlhbCxcbiAgICAgICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddXG4gICAgKTtcbn1cblxuLy8gLS0tIEVuY3J5cHQgLyBEZWNyeXB0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEVuY3J5cHQgYSBwbGFpbnRleHQgc3RyaW5nIHdpdGggYSBwYXNzd29yZC5cbiAqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc2FsdCAoMTYgYnl0ZXMpIGFuZCBJViAoMTIgYnl0ZXMpLCBkZXJpdmVzIGFuXG4gKiBBRVMtMjU2LUdDTSBrZXkgdmlhIFBCS0RGMiwgYW5kIHJldHVybnMgYSBKU09OIHN0cmluZyBjb250YWluaW5nXG4gKiBiYXNlNjQtZW5jb2RlZCBzYWx0LCBpdiwgYW5kIGNpcGhlcnRleHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBsYWludGV4dCAtIFRoZSBkYXRhIHRvIGVuY3J5cHQgKGUuZy4gaGV4IHByaXZhdGUga2V5KVxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkICAtIFRoZSBtYXN0ZXIgcGFzc3dvcmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEpTT04gc3RyaW5nOiB7IHNhbHQsIGl2LCBjaXBoZXJ0ZXh0IH0gKGFsbCBiYXNlNjQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0KHBsYWludGV4dCwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBzYWx0ID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShTQUxUX0JZVEVTKSk7XG4gICAgY29uc3QgaXYgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KElWX0JZVEVTKSk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlS2V5KHBhc3N3b3JkLCBzYWx0KTtcblxuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgICAgIHsgbmFtZTogJ0FFUy1HQ00nLCBpdiB9LFxuICAgICAgICBrZXksXG4gICAgICAgIGVuYy5lbmNvZGUocGxhaW50ZXh0KVxuICAgICk7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzYWx0OiBhcnJheUJ1ZmZlclRvQmFzZTY0KHNhbHQpLFxuICAgICAgICBpdjogYXJyYXlCdWZmZXJUb0Jhc2U2NChpdiksXG4gICAgICAgIGNpcGhlcnRleHQ6IGFycmF5QnVmZmVyVG9CYXNlNjQoY2lwaGVydGV4dCksXG4gICAgfSk7XG59XG5cbi8qKlxuICogRGVjcnlwdCBkYXRhIHRoYXQgd2FzIGVuY3J5cHRlZCB3aXRoIGBlbmNyeXB0KClgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0ZWREYXRhIC0gSlNPTiBzdHJpbmcgZnJvbSBlbmNyeXB0KClcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAgICAgIC0gVGhlIG1hc3RlciBwYXNzd29yZFxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIG9yaWdpbmFsIHBsYWludGV4dFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXNzd29yZCBpcyB3cm9uZyBvciBkYXRhIGlzIHRhbXBlcmVkIHdpdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCB7IHNhbHQsIGl2LCBjaXBoZXJ0ZXh0IH0gPSBKU09OLnBhcnNlKGVuY3J5cHRlZERhdGEpO1xuXG4gICAgY29uc3Qgc2FsdEJ1ZiA9IG5ldyBVaW50OEFycmF5KGJhc2U2NFRvQXJyYXlCdWZmZXIoc2FsdCkpO1xuICAgIGNvbnN0IGl2QnVmID0gbmV3IFVpbnQ4QXJyYXkoYmFzZTY0VG9BcnJheUJ1ZmZlcihpdikpO1xuICAgIGNvbnN0IGN0QnVmID0gYmFzZTY0VG9BcnJheUJ1ZmZlcihjaXBoZXJ0ZXh0KTtcblxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUtleShwYXNzd29yZCwgc2FsdEJ1Zik7XG5cbiAgICBjb25zdCBwbGFpbkJ1ZiA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICAgICAgeyBuYW1lOiAnQUVTLUdDTScsIGl2OiBpdkJ1ZiB9LFxuICAgICAgICBrZXksXG4gICAgICAgIGN0QnVmXG4gICAgKTtcblxuICAgIGNvbnN0IGRlYyA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHJldHVybiBkZWMuZGVjb2RlKHBsYWluQnVmKTtcbn1cblxuLy8gLS0tIFBhc3N3b3JkIGhhc2hpbmcgKGZvciB2ZXJpZmljYXRpb24pIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEhhc2ggYSBwYXNzd29yZCB3aXRoIFBCS0RGMiBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzLlxuICpcbiAqIFRoaXMgcHJvZHVjZXMgYSBzZXBhcmF0ZSBoYXNoIChub3QgdGhlIGVuY3J5cHRpb24ga2V5KSB0aGF0IGNhbiBiZSBzdG9yZWRcbiAqIHRvIHZlcmlmeSB0aGUgcGFzc3dvcmQgd2l0aG91dCBuZWVkaW5nIHRvIGF0dGVtcHQgZGVjcnlwdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgbWFzdGVyIHBhc3N3b3JkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtzYWx0XSAtIE9wdGlvbmFsIHNhbHQ7IGdlbmVyYXRlZCBpZiBvbWl0dGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7IGhhc2g6IHN0cmluZywgc2FsdDogc3RyaW5nIH0+fSBiYXNlNjQtZW5jb2RlZCBoYXNoIGFuZCBzYWx0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNoUGFzc3dvcmQocGFzc3dvcmQsIHNhbHQpIHtcbiAgICBpZiAoIXNhbHQpIHtcbiAgICAgICAgc2FsdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoU0FMVF9CWVRFUykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNhbHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNhbHQgPSBuZXcgVWludDhBcnJheShiYXNlNjRUb0FycmF5QnVmZmVyKHNhbHQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICAncmF3JyxcbiAgICAgICAgZW5jLmVuY29kZShwYXNzd29yZCksXG4gICAgICAgICdQQktERjInLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgWydkZXJpdmVCaXRzJ11cbiAgICApO1xuXG4gICAgY29uc3QgaGFzaEJpdHMgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICAgICAgc2FsdCxcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IFBCS0RGMl9JVEVSQVRJT05TLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICB9LFxuICAgICAgICBrZXlNYXRlcmlhbCxcbiAgICAgICAgMjU2XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2g6IGFycmF5QnVmZmVyVG9CYXNlNjQoaGFzaEJpdHMpLFxuICAgICAgICBzYWx0OiBhcnJheUJ1ZmZlclRvQmFzZTY0KHNhbHQpLFxuICAgIH07XG59XG5cbi8qKlxuICogVmVyaWZ5IGEgcGFzc3dvcmQgYWdhaW5zdCBhIHN0b3JlZCBoYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAgIC0gVGhlIHBhc3N3b3JkIHRvIHZlcmlmeVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlZEhhc2ggLSBiYXNlNjQtZW5jb2RlZCBoYXNoIGZyb20gaGFzaFBhc3N3b3JkKClcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZWRTYWx0IC0gYmFzZTY0LWVuY29kZWQgc2FsdCBmcm9tIGhhc2hQYXNzd29yZCgpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiB0aGUgcGFzc3dvcmQgbWF0Y2hlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQsIHN0b3JlZEhhc2gsIHN0b3JlZFNhbHQpIHtcbiAgICBjb25zdCB7IGhhc2ggfSA9IGF3YWl0IGhhc2hQYXNzd29yZChwYXNzd29yZCwgc3RvcmVkU2FsdCk7XG4gICAgcmV0dXJuIGhhc2ggPT09IHN0b3JlZEhhc2g7XG59XG4iLCAiaW1wb3J0IHsgYXBpIH0gZnJvbSAnLi9icm93c2VyLXBvbHlmaWxsJztcbmltcG9ydCB7IGVuY3J5cHQsIGRlY3J5cHQsIGhhc2hQYXNzd29yZCwgdmVyaWZ5UGFzc3dvcmQgfSBmcm9tICcuL2NyeXB0byc7XG5cbmNvbnN0IERCX1ZFUlNJT04gPSA1O1xuY29uc3Qgc3RvcmFnZSA9IGFwaS5zdG9yYWdlLmxvY2FsO1xuZXhwb3J0IGNvbnN0IFJFQ09NTUVOREVEX1JFTEFZUyA9IFtcbiAgICBuZXcgVVJMKCd3c3M6Ly9yZWxheS5kYW11cy5pbycpLFxuICAgIG5ldyBVUkwoJ3dzczovL3JlbGF5LnByaW1hbC5uZXQnKSxcbiAgICBuZXcgVVJMKCd3c3M6Ly9yZWxheS5zbm9ydC5zb2NpYWwnKSxcbiAgICBuZXcgVVJMKCd3c3M6Ly9yZWxheS5nZXRhbGJ5LmNvbS92MScpLFxuICAgIG5ldyBVUkwoJ3dzczovL25vcy5sb2wnKSxcbiAgICBuZXcgVVJMKCd3c3M6Ly9icmIuaW8nKSxcbiAgICBuZXcgVVJMKCd3c3M6Ly9ub3N0ci5vcmFuZ2VwaWxsLmRldicpLFxuXTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEtJTkRTID0gW1xuICAgIFswLCAnTWV0YWRhdGEnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDEubWQnXSxcbiAgICBbMSwgJ1RleHQnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDEubWQnXSxcbiAgICBbMiwgJ1JlY29tbWVuZCBSZWxheScsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8wMS5tZCddLFxuICAgIFszLCAnQ29udGFjdHMnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDIubWQnXSxcbiAgICBbNCwgJ0VuY3J5cHRlZCBEaXJlY3QgTWVzc2FnZXMnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDQubWQnXSxcbiAgICBbNSwgJ0V2ZW50IERlbGV0aW9uJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzA5Lm1kJ10sXG4gICAgWzYsICdSZXBvc3QnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMTgubWQnXSxcbiAgICBbNywgJ1JlYWN0aW9uJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzI1Lm1kJ10sXG4gICAgWzgsICdCYWRnZSBBd2FyZCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81OC5tZCddLFxuICAgIFsxNiwgJ0dlbmVyaWMgUmVwb3N0JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzE4Lm1kJ10sXG4gICAgWzQwLCAnQ2hhbm5lbCBDcmVhdGlvbicsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8yOC5tZCddLFxuICAgIFs0MSwgJ0NoYW5uZWwgTWV0YWRhdGEnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjgubWQnXSxcbiAgICBbNDIsICdDaGFubmVsIE1lc3NhZ2UnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjgubWQnXSxcbiAgICBbNDMsICdDaGFubmVsIEhpZGUgTWVzc2FnZScsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8yOC5tZCddLFxuICAgIFs0NCwgJ0NoYW5uZWwgTXV0ZSBVc2VyJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzI4Lm1kJ10sXG4gICAgWzEwNjMsICdGaWxlIE1ldGFkYXRhJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzk0Lm1kJ10sXG4gICAgWzEzMTEsICdMaXZlIENoYXQgTWVzc2FnZScsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81My5tZCddLFxuICAgIFsxOTg0LCAnUmVwb3J0aW5nJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU2Lm1kJ10sXG4gICAgWzE5ODUsICdMYWJlbCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8zMi5tZCddLFxuICAgIFs0NTUwLCAnQ29tbXVuaXR5IFBvc3QgQXBwcm92YWwnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzIubWQnXSxcbiAgICBbNzAwMCwgJ0pvYiBGZWVkYmFjaycsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85MC5tZCddLFxuICAgIFs5MDQxLCAnWmFwIEdvYWwnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzUubWQnXSxcbiAgICBbOTczNCwgJ1phcCBSZXF1ZXN0JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU3Lm1kJ10sXG4gICAgWzk3MzUsICdaYXAnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTcubWQnXSxcbiAgICBbMTAwMDAsICdNdXRlIExpc3QnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTEubWQnXSxcbiAgICBbMTAwMDEsICdQaW4gTGlzdCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81MS5tZCddLFxuICAgIFsxMDAwMiwgJ1JlbGF5IExpc3QgTWV0YWRhdGEnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNjUubWQnXSxcbiAgICBbMTMxOTQsICdXYWxsZXQgSW5mbycsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci80Ny5tZCddLFxuICAgIFsyMjI0MiwgJ0NsaWVudCBBdXRoZW50aWNhdGlvbicsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci80Mi5tZCddLFxuICAgIFsyMzE5NCwgJ1dhbGxldCBSZXF1ZXN0JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzQ3Lm1kJ10sXG4gICAgWzIzMTk1LCAnV2FsbGV0IFJlc3BvbnNlJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzQ3Lm1kJ10sXG4gICAgWzI0MTMzLCAnTm9zdHIgQ29ubmVjdCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci80Ni5tZCddLFxuICAgIFsyNzIzNSwgJ0hUVFAgQXV0aCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85OC5tZCddLFxuICAgIFszMDAwMCwgJ0NhdGVnb3JpemVkIFBlb3BsZSBMaXN0JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzUxLm1kJ10sXG4gICAgWzMwMDAxLCAnQ2F0ZWdvcml6ZWQgQm9va21hcmsgTGlzdCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81MS5tZCddLFxuICAgIFszMDAwOCwgJ1Byb2ZpbGUgQmFkZ2VzJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU4Lm1kJ10sXG4gICAgWzMwMDA5LCAnQmFkZ2UgRGVmaW5pdGlvbicsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81OC5tZCddLFxuICAgIFszMDAxNywgJ0NyZWF0ZSBvciB1cGRhdGUgYSBzdGFsbCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8xNS5tZCddLFxuICAgIFszMDAxOCwgJ0NyZWF0ZSBvciB1cGRhdGUgYSBwcm9kdWN0JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzE1Lm1kJ10sXG4gICAgWzMwMDIzLCAnTG9uZy1Gb3JtIENvbnRlbnQnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjMubWQnXSxcbiAgICBbMzAwMjQsICdEcmFmdCBMb25nLWZvcm0gQ29udGVudCcsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8yMy5tZCddLFxuICAgIFszMDA3OCwgJ0FwcGxpY2F0aW9uLXNwZWNpZmljIERhdGEnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzgubWQnXSxcbiAgICBbMzAzMTEsICdMaXZlIEV2ZW50JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzUzLm1kJ10sXG4gICAgWzMwMzE1LCAnVXNlciBTdGF0dXNlcycsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8zOC5tZCddLFxuICAgIFszMDQwMiwgJ0NsYXNzaWZpZWQgTGlzdGluZycsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85OS5tZCddLFxuICAgIFszMDQwMywgJ0RyYWZ0IENsYXNzaWZpZWQgTGlzdGluZycsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85OS5tZCddLFxuICAgIFszMTkyMiwgJ0RhdGUtQmFzZWQgQ2FsZW5kYXIgRXZlbnQnLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTIubWQnXSxcbiAgICBbMzE5MjMsICdUaW1lLUJhc2VkIENhbGVuZGFyIEV2ZW50JywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzUyLm1kJ10sXG4gICAgWzMxOTI0LCAnQ2FsZW5kYXInLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTIubWQnXSxcbiAgICBbMzE5MjUsICdDYWxlbmRhciBFdmVudCBSU1ZQJywgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzUyLm1kJ10sXG4gICAgWzMxOTg5LCAnSGFuZGxlciByZWNvbW1lbmRhdGlvbicsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci84OS5tZCddLFxuICAgIFszMTk5MCwgJ0hhbmRsZXIgaW5mb3JtYXRpb24nLCAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvODkubWQnXSxcbiAgICBbMzQ1NTAsICdDb21tdW5pdHkgRGVmaW5pdGlvbicsICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci83Mi5tZCddLFxuXTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgYXdhaXQgZ2V0T3JTZXREZWZhdWx0KCdwcm9maWxlSW5kZXgnLCAwKTtcbiAgICBhd2FpdCBnZXRPclNldERlZmF1bHQoJ3Byb2ZpbGVzJywgW2F3YWl0IGdlbmVyYXRlUHJvZmlsZSgpXSk7XG4gICAgbGV0IHZlcnNpb24gPSAoYXdhaXQgc3RvcmFnZS5nZXQoeyB2ZXJzaW9uOiAwIH0pKS52ZXJzaW9uO1xuICAgIGNvbnNvbGUubG9nKCdEQiB2ZXJzaW9uOiAnLCB2ZXJzaW9uKTtcbiAgICB3aGlsZSAodmVyc2lvbiA8IERCX1ZFUlNJT04pIHtcbiAgICAgICAgdmVyc2lvbiA9IGF3YWl0IG1pZ3JhdGUodmVyc2lvbiwgREJfVkVSU0lPTik7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgdmVyc2lvbiB9KTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUodmVyc2lvbiwgZ29hbCkge1xuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNaWdyYXRpbmcgdG8gdmVyc2lvbiAxLicpO1xuICAgICAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgICAgICBwcm9maWxlcy5mb3JFYWNoKHByb2ZpbGUgPT4gKHByb2ZpbGUuaG9zdHMgPSB7fSkpO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ21pZ3JhdGluZyB0byB2ZXJzaW9uIDIuJyk7XG4gICAgICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uICsgMTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgICAgICBjb25zb2xlLmxvZygnTWlncmF0aW5nIHRvIHZlcnNpb24gMy4nKTtcbiAgICAgICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICAgICAgcHJvZmlsZXMuZm9yRWFjaChwcm9maWxlID0+IChwcm9maWxlLnJlbGF5UmVtaW5kZXIgPSB0cnVlKSk7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uICsgMTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gMykge1xuICAgICAgICBjb25zb2xlLmxvZygnTWlncmF0aW5nIHRvIHZlcnNpb24gNCAoZW5jcnlwdGlvbiBzdXBwb3J0KS4nKTtcbiAgICAgICAgLy8gTm8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBuZWVkZWQgXHUyMDE0IGV4aXN0aW5nIHBsYWludGV4dCBrZXlzIHN0YXkgYXMtaXMuXG4gICAgICAgIC8vIEVuY3J5cHRpb24gb25seSBhY3RpdmF0ZXMgd2hlbiB0aGUgdXNlciBzZXRzIGEgbWFzdGVyIHBhc3N3b3JkLlxuICAgICAgICAvLyBXZSBqdXN0IGVuc3VyZSB0aGUgaXNFbmNyeXB0ZWQgZmxhZyBleGlzdHMgYW5kIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHN0b3JhZ2UuZ2V0KHsgaXNFbmNyeXB0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIWRhdGEuaXNFbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgaXNFbmNyeXB0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJzaW9uICsgMTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gNCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTWlncmF0aW5nIHRvIHZlcnNpb24gNSAoTklQLTQ2IGJ1bmtlciBzdXBwb3J0KS4nKTtcbiAgICAgICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICAgICAgcHJvZmlsZXMuZm9yRWFjaChwcm9maWxlID0+IHtcbiAgICAgICAgICAgIGlmICghcHJvZmlsZS50eXBlKSBwcm9maWxlLnR5cGUgPSAnbG9jYWwnO1xuICAgICAgICAgICAgaWYgKHByb2ZpbGUuYnVua2VyVXJsID09PSB1bmRlZmluZWQpIHByb2ZpbGUuYnVua2VyVXJsID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwcm9maWxlLnJlbW90ZVB1YmtleSA9PT0gdW5kZWZpbmVkKSBwcm9maWxlLnJlbW90ZVB1YmtleSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZXMoKSB7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBwcm9maWxlczogW10gfSk7XG4gICAgcmV0dXJuIHByb2ZpbGVzLnByb2ZpbGVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZShpbmRleCkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgcmV0dXJuIHByb2ZpbGVzW2luZGV4XTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2ZpbGVOYW1lcygpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIHJldHVybiBwcm9maWxlcy5tYXAocCA9PiBwLm5hbWUpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZUluZGV4KCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBwcm9maWxlSW5kZXg6IDAgfSk7XG4gICAgcmV0dXJuIGluZGV4LnByb2ZpbGVJbmRleDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFByb2ZpbGVJbmRleChwcm9maWxlSW5kZXgpIHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVJbmRleCB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVByb2ZpbGUoaW5kZXgpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGxldCBwcm9maWxlSW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICBwcm9maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChwcm9maWxlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBhd2FpdCBjbGVhckRhdGEoKTsgLy8gSWYgd2UgaGF2ZSBkZWxldGVkIGFsbCBvZiB0aGUgcHJvZmlsZXMsIGxldCdzIGp1c3Qgc3RhcnQgZnJlc2ggd2l0aCBhbGwgbmV3IGRhdGFcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBkZWxldGVkIHdhcyB0aGUgYWN0aXZlIHByb2ZpbGUsIGNoYW5nZSB0aGUgYWN0aXZlIHByb2ZpbGUgdG8gdGhlIG5leHQgb25lXG4gICAgICAgIGxldCBuZXdJbmRleCA9XG4gICAgICAgICAgICBwcm9maWxlSW5kZXggPT09IGluZGV4ID8gTWF0aC5tYXgoaW5kZXggLSAxLCAwKSA6IHByb2ZpbGVJbmRleDtcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcywgcHJvZmlsZUluZGV4OiBuZXdJbmRleCB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhckRhdGEoKSB7XG4gICAgbGV0IGlnbm9yZUluc3RhbGxIb29rID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBpZ25vcmVJbnN0YWxsSG9vazogZmFsc2UgfSk7XG4gICAgYXdhaXQgc3RvcmFnZS5jbGVhcigpO1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KGlnbm9yZUluc3RhbGxIb29rKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiBhd2FpdCBhcGkucnVudGltZS5zZW5kTWVzc2FnZSh7IGtpbmQ6ICdnZW5lcmF0ZVByaXZhdGVLZXknIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQcm9maWxlKG5hbWUgPSAnRGVmYXVsdCBOb3N0ciBQcm9maWxlJywgdHlwZSA9ICdsb2NhbCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwcml2S2V5OiB0eXBlID09PSAnbG9jYWwnID8gYXdhaXQgZ2VuZXJhdGVQcml2YXRlS2V5KCkgOiAnJyxcbiAgICAgICAgaG9zdHM6IHt9LFxuICAgICAgICByZWxheXM6IFJFQ09NTUVOREVEX1JFTEFZUy5tYXAociA9PiAoeyB1cmw6IHIuaHJlZiwgcmVhZDogdHJ1ZSwgd3JpdGU6IHRydWUgfSkpLFxuICAgICAgICByZWxheVJlbWluZGVyOiBmYWxzZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgYnVua2VyVXJsOiBudWxsLFxuICAgICAgICByZW1vdGVQdWJrZXk6IG51bGwsXG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T3JTZXREZWZhdWx0KGtleSwgZGVmKSB7XG4gICAgbGV0IHZhbCA9IChhd2FpdCBzdG9yYWdlLmdldChrZXkpKVtrZXldO1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgW2tleV06IGRlZiB9KTtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVByb2ZpbGVOYW1lKGluZGV4LCBwcm9maWxlTmFtZSkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgcHJvZmlsZXNbaW5kZXhdLm5hbWUgPSBwcm9maWxlTmFtZTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVByaXZhdGVLZXkoaW5kZXgsIHByaXZhdGVLZXkpIHtcbiAgICBhd2FpdCBhcGkucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIGtpbmQ6ICdzYXZlUHJpdmF0ZUtleScsXG4gICAgICAgIHBheWxvYWQ6IFtpbmRleCwgcHJpdmF0ZUtleV0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdQcm9maWxlKCkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgY29uc3QgbmV3UHJvZmlsZSA9IGF3YWl0IGdlbmVyYXRlUHJvZmlsZSgnTmV3IFByb2ZpbGUnKTtcbiAgICBwcm9maWxlcy5wdXNoKG5ld1Byb2ZpbGUpO1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG4gICAgcmV0dXJuIHByb2ZpbGVzLmxlbmd0aCAtIDE7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdCdW5rZXJQcm9maWxlKG5hbWUgPSAnTmV3IEJ1bmtlcicsIGJ1bmtlclVybCA9IG51bGwpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZW5lcmF0ZVByb2ZpbGUobmFtZSwgJ2J1bmtlcicpO1xuICAgIHByb2ZpbGUuYnVua2VyVXJsID0gYnVua2VyVXJsO1xuICAgIHByb2ZpbGVzLnB1c2gocHJvZmlsZSk7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcyB9KTtcbiAgICByZXR1cm4gcHJvZmlsZXMubGVuZ3RoIC0gMTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlbGF5cyhwcm9maWxlSW5kZXgpIHtcbiAgICBsZXQgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUocHJvZmlsZUluZGV4KTtcbiAgICByZXR1cm4gcHJvZmlsZS5yZWxheXMgfHwgW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlUmVsYXlzKHByb2ZpbGVJbmRleCwgcmVsYXlzKSB7XG4gICAgLy8gSGF2aW5nIGFuIEFscGluZSBwcm94eSBvYmplY3QgYXMgYSBzdWItb2JqZWN0IGRvZXMgbm90IHNlcmlhbGl6ZSBjb3JyZWN0bHkgaW4gc3RvcmFnZSxcbiAgICAvLyBzbyB3ZSBhcmUgcHJlLXNlcmlhbGl6aW5nIGhlcmUgYmVmb3JlIGFzc2lnbmluZyBpdCB0byB0aGUgcHJvZmlsZSwgc28gdGhlIHByb3h5XG4gICAgLy8gb2JqIGRvZXNuJ3QgYnVnIG91dC5cbiAgICBsZXQgZml4ZWRSZWxheXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlbGF5cykpO1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgbGV0IHByb2ZpbGUgPSBwcm9maWxlc1twcm9maWxlSW5kZXhdO1xuICAgIHByb2ZpbGUucmVsYXlzID0gZml4ZWRSZWxheXM7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcyB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldChpdGVtKSB7XG4gICAgcmV0dXJuIChhd2FpdCBzdG9yYWdlLmdldChpdGVtKSlbaXRlbV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZXJtaXNzaW9ucyhpbmRleCA9IG51bGwpIHtcbiAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICBpbmRleCA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIH1cbiAgICBsZXQgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUoaW5kZXgpO1xuICAgIGxldCBob3N0cyA9IGF3YWl0IHByb2ZpbGUuaG9zdHM7XG4gICAgcmV0dXJuIGhvc3RzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVybWlzc2lvbihob3N0LCBhY3Rpb24pIHtcbiAgICBsZXQgaW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICBsZXQgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUoaW5kZXgpO1xuICAgIHJldHVybiBwcm9maWxlLmhvc3RzPy5baG9zdF0/LlthY3Rpb25dIHx8ICdhc2snO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0UGVybWlzc2lvbihob3N0LCBhY3Rpb24sIHBlcm0sIGluZGV4ID0gbnVsbCkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgICBpbmRleCA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIH1cbiAgICBsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2luZGV4XTtcbiAgICBsZXQgbmV3UGVybXMgPSBwcm9maWxlLmhvc3RzW2hvc3RdIHx8IHt9O1xuICAgIG5ld1Blcm1zID0geyAuLi5uZXdQZXJtcywgW2FjdGlvbl06IHBlcm0gfTtcbiAgICBwcm9maWxlLmhvc3RzW2hvc3RdID0gbmV3UGVybXM7XG4gICAgcHJvZmlsZXNbaW5kZXhdID0gcHJvZmlsZTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVtYW5QZXJtaXNzaW9uKHApIHtcbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZXJlIGV2ZW50IHNpZ25pbmcgaW5jbHVkZXMgYSBraW5kIG51bWJlclxuICAgIGlmIChwLnN0YXJ0c1dpdGgoJ3NpZ25FdmVudDonKSkge1xuICAgICAgICBsZXQgW2UsIG5dID0gcC5zcGxpdCgnOicpO1xuICAgICAgICBuID0gcGFyc2VJbnQobik7XG4gICAgICAgIGxldCBubmFtZSA9IEtJTkRTLmZpbmQoayA9PiBrWzBdID09PSBuKT8uWzFdIHx8IGBVbmtub3duIChLaW5kICR7bn0pYDtcbiAgICAgICAgcmV0dXJuIGBTaWduIGV2ZW50OiAke25uYW1lfWA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwKSB7XG4gICAgICAgIGNhc2UgJ2dldFB1YktleSc6XG4gICAgICAgICAgICByZXR1cm4gJ1JlYWQgcHVibGljIGtleSc7XG4gICAgICAgIGNhc2UgJ3NpZ25FdmVudCc6XG4gICAgICAgICAgICByZXR1cm4gJ1NpZ24gZXZlbnQnO1xuICAgICAgICBjYXNlICdnZXRSZWxheXMnOlxuICAgICAgICAgICAgcmV0dXJuICdSZWFkIHJlbGF5IGxpc3QnO1xuICAgICAgICBjYXNlICduaXAwNC5lbmNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAnRW5jcnlwdCBwcml2YXRlIG1lc3NhZ2UgKE5JUC0wNCknO1xuICAgICAgICBjYXNlICduaXAwNC5kZWNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAnRGVjcnlwdCBwcml2YXRlIG1lc3NhZ2UgKE5JUC0wNCknO1xuICAgICAgICBjYXNlICduaXA0NC5lbmNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAnRW5jcnlwdCBwcml2YXRlIG1lc3NhZ2UgKE5JUC00NCknO1xuICAgICAgICBjYXNlICduaXA0NC5kZWNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAnRGVjcnlwdCBwcml2YXRlIG1lc3NhZ2UgKE5JUC00NCknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUtleShrZXkpIHtcbiAgICBjb25zdCBoZXhNYXRjaCA9IC9eW1xcZGEtZl17NjR9JC9pLnRlc3Qoa2V5KTtcbiAgICBjb25zdCBiMzJNYXRjaCA9IC9ebnNlYzFbcXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2xdezU4fSQvLnRlc3Qoa2V5KTtcblxuICAgIHJldHVybiBoZXhNYXRjaCB8fCBiMzJNYXRjaCB8fCBpc05jcnlwdHNlYyhrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOY3J5cHRzZWMoa2V5KSB7XG4gICAgcmV0dXJuIC9ebmNyeXB0c2VjMVtxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bF0rJC8udGVzdChrZXkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmVhdHVyZShuYW1lKSB7XG4gICAgbGV0IGZuYW1lID0gYGZlYXR1cmU6JHtuYW1lfWA7XG4gICAgbGV0IGYgPSBhd2FpdCBhcGkuc3RvcmFnZS5sb2NhbC5nZXQoeyBbZm5hbWVdOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gZltmbmFtZV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWxheVJlbWluZGVyKCkge1xuICAgIGxldCBpbmRleCA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIGxldCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShpbmRleCk7XG4gICAgcmV0dXJuIHByb2ZpbGUucmVsYXlSZW1pbmRlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZVJlbGF5UmVtaW5kZXIoKSB7XG4gICAgbGV0IGluZGV4ID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICBwcm9maWxlc1tpbmRleF0ucmVsYXlSZW1pbmRlciA9IGZhbHNlO1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROcHViKCkge1xuICAgIGxldCBpbmRleCA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIHJldHVybiBhd2FpdCBhcGkucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIGtpbmQ6ICdnZXROcHViJyxcbiAgICAgICAgcGF5bG9hZDogaW5kZXgsXG4gICAgfSk7XG59XG5cbi8vIC0tLSBNYXN0ZXIgcGFzc3dvcmQgZW5jcnlwdGlvbiBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIG1hc3RlciBwYXNzd29yZCBlbmNyeXB0aW9uIGlzIGFjdGl2ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzRW5jcnlwdGVkKCkge1xuICAgIGxldCBkYXRhID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBpc0VuY3J5cHRlZDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGRhdGEuaXNFbmNyeXB0ZWQ7XG59XG5cbi8qKlxuICogU3RvcmUgdGhlIHBhc3N3b3JkIHZlcmlmaWNhdGlvbiBoYXNoIChuZXZlciB0aGUgcGFzc3dvcmQgaXRzZWxmKS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFBhc3N3b3JkSGFzaChwYXNzd29yZCkge1xuICAgIGNvbnN0IHsgaGFzaCwgc2FsdCB9ID0gYXdhaXQgaGFzaFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7XG4gICAgICAgIHBhc3N3b3JkSGFzaDogaGFzaCxcbiAgICAgICAgcGFzc3dvcmRTYWx0OiBzYWx0LFxuICAgICAgICBpc0VuY3J5cHRlZDogdHJ1ZSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBwYXNzd29yZCBhZ2FpbnN0IHRoZSBzdG9yZWQgaGFzaC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgc3RvcmFnZS5nZXQoe1xuICAgICAgICBwYXNzd29yZEhhc2g6IG51bGwsXG4gICAgICAgIHBhc3N3b3JkU2FsdDogbnVsbCxcbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucGFzc3dvcmRIYXNoIHx8ICFkYXRhLnBhc3N3b3JkU2FsdCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB2ZXJpZnlQYXNzd29yZChwYXNzd29yZCwgZGF0YS5wYXNzd29yZEhhc2gsIGRhdGEucGFzc3dvcmRTYWx0KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgbWFzdGVyIHBhc3N3b3JkIHByb3RlY3Rpb24gXHUyMDE0IGNsZWFycyBoYXNoIGFuZCBkZWNyeXB0cyBhbGwga2V5cy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVBhc3N3b3JkUHJvdGVjdGlvbihwYXNzd29yZCkge1xuICAgIGNvbnN0IHZhbGlkID0gYXdhaXQgY2hlY2tQYXNzd29yZChwYXNzd29yZCk7XG4gICAgaWYgKCF2YWxpZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhc3N3b3JkJyk7XG5cbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb2ZpbGVzW2ldLnR5cGUgPT09ICdidW5rZXInKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzRW5jcnlwdGVkQmxvYihwcm9maWxlc1tpXS5wcml2S2V5KSkge1xuICAgICAgICAgICAgcHJvZmlsZXNbaV0ucHJpdktleSA9IGF3YWl0IGRlY3J5cHQocHJvZmlsZXNbaV0ucHJpdktleSwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHtcbiAgICAgICAgcHJvZmlsZXMsXG4gICAgICAgIGlzRW5jcnlwdGVkOiBmYWxzZSxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiBudWxsLFxuICAgICAgICBwYXNzd29yZFNhbHQ6IG51bGwsXG4gICAgfSk7XG59XG5cbi8qKlxuICogRW5jcnlwdCBhbGwgcHJvZmlsZSBwcml2YXRlIGtleXMgd2l0aCBhIG1hc3RlciBwYXNzd29yZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBbGxLZXlzKHBhc3N3b3JkKSB7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2ZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9maWxlc1tpXS50eXBlID09PSAnYnVua2VyJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNFbmNyeXB0ZWRCbG9iKHByb2ZpbGVzW2ldLnByaXZLZXkpKSB7XG4gICAgICAgICAgICBwcm9maWxlc1tpXS5wcml2S2V5ID0gYXdhaXQgZW5jcnlwdChwcm9maWxlc1tpXS5wcml2S2V5LCBwYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgc2V0UGFzc3dvcmRIYXNoKHBhc3N3b3JkKTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xufVxuXG4vKipcbiAqIFJlLWVuY3J5cHQgYWxsIGtleXMgd2l0aCBhIG5ldyBwYXNzd29yZCAocmVxdWlyZXMgdGhlIG9sZCBwYXNzd29yZCkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGFuZ2VQYXNzd29yZEZvcktleXMob2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkKSB7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2ZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9maWxlc1tpXS50eXBlID09PSAnYnVua2VyJykgY29udGludWU7XG4gICAgICAgIGxldCBoZXggPSBwcm9maWxlc1tpXS5wcml2S2V5O1xuICAgICAgICBpZiAoaXNFbmNyeXB0ZWRCbG9iKGhleCkpIHtcbiAgICAgICAgICAgIGhleCA9IGF3YWl0IGRlY3J5cHQoaGV4LCBvbGRQYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZmlsZXNbaV0ucHJpdktleSA9IGF3YWl0IGVuY3J5cHQoaGV4LCBuZXdQYXNzd29yZCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaGFzaCwgc2FsdCB9ID0gYXdhaXQgaGFzaFBhc3N3b3JkKG5ld1Bhc3N3b3JkKTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7XG4gICAgICAgIHByb2ZpbGVzLFxuICAgICAgICBwYXNzd29yZEhhc2g6IGhhc2gsXG4gICAgICAgIHBhc3N3b3JkU2FsdDogc2FsdCxcbiAgICAgICAgaXNFbmNyeXB0ZWQ6IHRydWUsXG4gICAgfSk7XG59XG5cbi8qKlxuICogRGVjcnlwdCBhIHNpbmdsZSBwcm9maWxlJ3MgcHJpdmF0ZSBrZXksIHJldHVybmluZyB0aGUgaGV4IHN0cmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlY3J5cHRlZFByaXZLZXkocHJvZmlsZSwgcGFzc3dvcmQpIHtcbiAgICBpZiAocHJvZmlsZS50eXBlID09PSAnYnVua2VyJykgcmV0dXJuICcnO1xuICAgIGlmIChpc0VuY3J5cHRlZEJsb2IocHJvZmlsZS5wcml2S2V5KSkge1xuICAgICAgICByZXR1cm4gZGVjcnlwdChwcm9maWxlLnByaXZLZXksIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2ZpbGUucHJpdktleTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgc3RvcmVkIHZhbHVlIGxvb2tzIGxpa2UgYW4gZW5jcnlwdGVkIGJsb2IuXG4gKiBFbmNyeXB0ZWQgYmxvYnMgYXJlIEpTT04gc3RyaW5ncyBjb250YWluaW5nIHtzYWx0LCBpdiwgY2lwaGVydGV4dH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VuY3J5cHRlZEJsb2IodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gISEocGFyc2VkLnNhbHQgJiYgcGFyc2VkLml2ICYmIHBhcnNlZC5jaXBoZXJ0ZXh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsICJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XG5cbmxldCBpZGJQcm94eWFibGVUeXBlcztcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSB7XG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxuICAgICAgICAoaWRiUHJveHlhYmxlVHlwZXMgPSBbXG4gICAgICAgICAgICBJREJEYXRhYmFzZSxcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxuICAgICAgICAgICAgSURCSW5kZXgsXG4gICAgICAgICAgICBJREJDdXJzb3IsXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcbiAgICAgICAgXSkpO1xufVxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpIHtcbiAgICByZXR1cm4gKGN1cnNvckFkdmFuY2VNZXRob2RzIHx8XG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWUsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcbiAgICAgICAgXSkpO1xufVxuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0aGlzLnJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwKHJlcXVlc3QpO1xuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZSh3cmFwKHJlcXVlc3QucmVzdWx0KSwgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgd3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKGV2ZW50KSA9PiBibG9ja2luZyhldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuY29uc3QgYWR2YW5jZU1ldGhvZFByb3BzID0gWydjb250aW51ZScsICdjb250aW51ZVByaW1hcnlLZXknLCAnYWR2YW5jZSddO1xuY29uc3QgbWV0aG9kTWFwID0ge307XG5jb25zdCBhZHZhbmNlUmVzdWx0cyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjdXJzb3JJdGVyYXRvclRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCFhZHZhbmNlTWV0aG9kUHJvcHMuaW5jbHVkZXMocHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBsZXQgY2FjaGVkRnVuYyA9IG1ldGhvZE1hcFtwcm9wXTtcbiAgICAgICAgaWYgKCFjYWNoZWRGdW5jKSB7XG4gICAgICAgICAgICBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlUmVzdWx0cy5zZXQodGhpcywgaXR0clByb3hpZWRDdXJzb3JUb09yaWdpbmFsUHJveHkuZ2V0KHRoaXMpW3Byb3BdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZEZ1bmM7XG4gICAgfSxcbn07XG5hc3luYyBmdW5jdGlvbiogaXRlcmF0ZSguLi5hcmdzKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXRoaXMtYXNzaWdubWVudFxuICAgIGxldCBjdXJzb3IgPSB0aGlzO1xuICAgIGlmICghKGN1cnNvciBpbnN0YW5jZW9mIElEQkN1cnNvcikpIHtcbiAgICAgICAgY3Vyc29yID0gYXdhaXQgY3Vyc29yLm9wZW5DdXJzb3IoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICghY3Vyc29yKVxuICAgICAgICByZXR1cm47XG4gICAgY3Vyc29yID0gY3Vyc29yO1xuICAgIGNvbnN0IHByb3hpZWRDdXJzb3IgPSBuZXcgUHJveHkoY3Vyc29yLCBjdXJzb3JJdGVyYXRvclRyYXBzKTtcbiAgICBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5zZXQocHJveGllZEN1cnNvciwgY3Vyc29yKTtcbiAgICAvLyBNYXAgdGhpcyBkb3VibGUtcHJveHkgYmFjayB0byB0aGUgb3JpZ2luYWwsIHNvIG90aGVyIGN1cnNvciBtZXRob2RzIHdvcmsuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm94aWVkQ3Vyc29yLCB1bndyYXAoY3Vyc29yKSk7XG4gICAgd2hpbGUgKGN1cnNvcikge1xuICAgICAgICB5aWVsZCBwcm94aWVkQ3Vyc29yO1xuICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIGFkdmFuY2luZyBtZXRob2RzIHdhcyBub3QgY2FsbGVkLCBjYWxsIGNvbnRpbnVlKCkuXG4gICAgICAgIGN1cnNvciA9IGF3YWl0IChhZHZhbmNlUmVzdWx0cy5nZXQocHJveGllZEN1cnNvcikgfHwgY3Vyc29yLmNvbnRpbnVlKCkpO1xuICAgICAgICBhZHZhbmNlUmVzdWx0cy5kZWxldGUocHJveGllZEN1cnNvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB7XG4gICAgcmV0dXJuICgocHJvcCA9PT0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgJiZcbiAgICAgICAgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmUsIElEQkN1cnNvcl0pKSB8fFxuICAgICAgICAocHJvcCA9PT0gJ2l0ZXJhdGUnICYmIGluc3RhbmNlT2ZBbnkodGFyZ2V0LCBbSURCSW5kZXgsIElEQk9iamVjdFN0b3JlXSkpKTtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZTtcbiAgICAgICAgcmV0dXJuIG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiwgdW53cmFwLCB3cmFwIH07XG4iLCAiaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuYXN5bmMgZnVuY3Rpb24gb3BlbkV2ZW50c0RiKCkge1xuICAgIHJldHVybiBhd2FpdCBvcGVuREIoJ2V2ZW50cycsIDEsIHtcbiAgICAgICAgdXBncmFkZShkYikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2V2ZW50cycsIHtcbiAgICAgICAgICAgICAgICBrZXlQYXRoOiAnZXZlbnQuaWQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudHMuY3JlYXRlSW5kZXgoJ3B1YmtleScsICdldmVudC5wdWJrZXknKTtcbiAgICAgICAgICAgIGV2ZW50cy5jcmVhdGVJbmRleCgnY3JlYXRlZF9hdCcsICdldmVudC5jcmVhdGVkX2F0Jyk7XG4gICAgICAgICAgICBldmVudHMuY3JlYXRlSW5kZXgoJ2tpbmQnLCAnZXZlbnQua2luZCcpO1xuICAgICAgICAgICAgZXZlbnRzLmNyZWF0ZUluZGV4KCdob3N0JywgJ21ldGFkYXRhLmhvc3QnKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVFdmVudChldmVudCkge1xuICAgIGxldCBkYiA9IGF3YWl0IG9wZW5FdmVudHNEYigpO1xuICAgIHJldHVybiBkYi5wdXQoJ2V2ZW50cycsIGV2ZW50KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNvcnRCeUluZGV4KGluZGV4LCBxdWVyeSwgYXNjLCBtYXgpIHtcbiAgICBsZXQgZGIgPSBhd2FpdCBvcGVuRXZlbnRzRGIoKTtcbiAgICBsZXQgZXZlbnRzID0gW107XG4gICAgbGV0IGN1cnNvciA9IGF3YWl0IGRiXG4gICAgICAgIC50cmFuc2FjdGlvbignZXZlbnRzJylcbiAgICAgICAgLnN0b3JlLmluZGV4KGluZGV4KVxuICAgICAgICAub3BlbkN1cnNvcihxdWVyeSwgYXNjID8gJ25leHQnIDogJ3ByZXYnKTtcbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoID49IG1heCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3Vyc29yID0gYXdhaXQgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIb3N0cygpIHtcbiAgICBsZXQgZGIgPSBhd2FpdCBvcGVuRXZlbnRzRGIoKTtcbiAgICBsZXQgaG9zdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnNvciA9IGF3YWl0IGRiLnRyYW5zYWN0aW9uKCdldmVudHMnKS5zdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgd2hpbGUgKGN1cnNvcikge1xuICAgICAgICBob3N0cy5hZGQoY3Vyc29yLnZhbHVlLm1ldGFkYXRhLmhvc3QpO1xuICAgICAgICBjdXJzb3IgPSBhd2FpdCBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5ob3N0c107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb3dubG9hZEFsbENvbnRlbnRzKCkge1xuICAgIGxldCBkYiA9IGF3YWl0IG9wZW5FdmVudHNEYigpO1xuICAgIGxldCBldmVudHMgPSBbXTtcbiAgICBsZXQgY3Vyc29yID0gYXdhaXQgZGIudHJhbnNhY3Rpb24oJ2V2ZW50cycpLnN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGN1cnNvci52YWx1ZS5ldmVudCk7XG4gICAgICAgIGN1cnNvciA9IGF3YWl0IGN1cnNvci5jb250aW51ZSgpO1xuICAgIH1cbiAgICBldmVudHMgPSBldmVudHMubWFwKGUgPT4gSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgIGV2ZW50cyA9IGV2ZW50cy5qb2luKCdcXG4nKTtcbiAgICBjb25zb2xlLmxvZyhldmVudHMpO1xuXG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtldmVudHNdLCAnZXZlbnRzLmpzb25sJywge1xuICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZXZlbnRzXSwgeyB0eXBlOiAncGxhaW4vdGV4dCcgfSk7XG5cbiAgICByZXR1cm4gYmxvYjtcbn1cbiIsICIvLyBuaXA0NC50c1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhLmpzXCI7XG5pbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanNcIjtcbmltcG9ydCB7IGV4dHJhY3QgYXMgaGtkZl9leHRyYWN0LCBleHBhbmQgYXMgaGtkZl9leHBhbmQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9oa2RmLmpzXCI7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaG1hYy5qc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMi5qc1wiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuXG4vLyB1dGlscy50c1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCI7XG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4vLyBuaXA0NC50c1xudmFyIG1pblBsYWludGV4dFNpemUgPSAxO1xudmFyIG1heFBsYWludGV4dFNpemUgPSA2NTUzNTtcbmZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICBjb25zdCBzaGFyZWRYID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5QSwgaGV4VG9CeXRlczIoXCIwMlwiICsgcHVia2V5QikpLnN1YmFycmF5KDEsIDMzKTtcbiAgcmV0dXJuIGhrZGZfZXh0cmFjdChzaGEyNTYsIHNoYXJlZFgsIHV0ZjhFbmNvZGVyLmVuY29kZShcIm5pcDQ0LXYyXCIpKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpIHtcbiAgY29uc3Qga2V5cyA9IGhrZGZfZXhwYW5kKHNoYTI1NiwgY29udmVyc2F0aW9uS2V5LCBub25jZSwgNzYpO1xuICByZXR1cm4ge1xuICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgIGNoYWNoYV9ub25jZToga2V5cy5zdWJhcnJheSgzMiwgNDQpLFxuICAgIGhtYWNfa2V5OiBrZXlzLnN1YmFycmF5KDQ0LCA3NilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNQYWRkZWRMZW4obGVuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGVuKSB8fCBsZW4gPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmIChsZW4gPD0gMzIpXG4gICAgcmV0dXJuIDMyO1xuICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gIGNvbnN0IGNodW5rID0gbmV4dFBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dFBvd2VyIC8gODtcbiAgcmV0dXJuIGNodW5rICogKE1hdGguZmxvb3IoKGxlbiAtIDEpIC8gY2h1bmspICsgMSk7XG59XG5mdW5jdGlvbiB3cml0ZVUxNkJFKG51bSkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgfHwgbnVtIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCBudW0gPiBtYXhQbGFpbnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemU6IG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2NTUzNSBieXRlc1wiKTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYWQocGxhaW50ZXh0KSB7XG4gIGNvbnN0IHVucGFkZGVkID0gdXRmOEVuY29kZXIuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gdW5wYWRkZWQubGVuZ3RoO1xuICBjb25zdCBwcmVmaXggPSB3cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkoY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikgLSB1bnBhZGRlZExlbik7XG4gIHJldHVybiBjb25jYXRCeXRlcyhwcmVmaXgsIHVucGFkZGVkLCBzdWZmaXgpO1xufVxuZnVuY3Rpb24gdW5wYWQocGFkZGVkKSB7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gbmV3IERhdGFWaWV3KHBhZGRlZC5idWZmZXIpLmdldFVpbnQxNigwKTtcbiAgY29uc3QgdW5wYWRkZWQgPSBwYWRkZWQuc3ViYXJyYXkoMiwgMiArIHVucGFkZGVkTGVuKTtcbiAgaWYgKHVucGFkZGVkTGVuIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZExlbiA+IG1heFBsYWludGV4dFNpemUgfHwgdW5wYWRkZWQubGVuZ3RoICE9PSB1bnBhZGRlZExlbiB8fCBwYWRkZWQubGVuZ3RoICE9PSAyICsgY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYWRkaW5nXCIpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHVucGFkZGVkKTtcbn1cbmZ1bmN0aW9uIGhtYWNBYWQoa2V5LCBtZXNzYWdlLCBhYWQpIHtcbiAgaWYgKGFhZC5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFBRCBhc3NvY2lhdGVkIGRhdGEgbXVzdCBiZSAzMiBieXRlc1wiKTtcbiAgY29uc3QgY29tYmluZWQgPSBjb25jYXRCeXRlcyhhYWQsIG1lc3NhZ2UpO1xuICByZXR1cm4gaG1hYyhzaGEyNTYsIGtleSwgY29tYmluZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXlsb2FkIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcIik7XG4gIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgaWYgKHBsZW4gPCAxMzIgfHwgcGxlbiA+IDg3NDcyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZCBsZW5ndGg6IFwiICsgcGxlbik7XG4gIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGJhc2U2NC5kZWNvZGUocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiYXNlNjQ6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgZGxlbiA9IGRhdGEubGVuZ3RoO1xuICBpZiAoZGxlbiA8IDk5IHx8IGRsZW4gPiA2NTYwMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoOiBcIiArIGRsZW4pO1xuICBjb25zdCB2ZXJzID0gZGF0YVswXTtcbiAgaWYgKHZlcnMgIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb24gXCIgKyB2ZXJzKTtcbiAgcmV0dXJuIHtcbiAgICBub25jZTogZGF0YS5zdWJhcnJheSgxLCAzMyksXG4gICAgY2lwaGVydGV4dDogZGF0YS5zdWJhcnJheSgzMywgLTMyKSxcbiAgICBtYWM6IGRhdGEuc3ViYXJyYXkoLTMyKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jcnlwdChwbGFpbnRleHQsIGNvbnZlcnNhdGlvbktleSwgbm9uY2UgPSByYW5kb21CeXRlcygzMikpIHtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgcGFkZGVkID0gcGFkKHBsYWludGV4dCk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIHBhZGRlZCk7XG4gIGNvbnN0IG1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29uY2F0Qnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzJdKSwgbm9uY2UsIGNpcGhlcnRleHQsIG1hYykpO1xufVxuZnVuY3Rpb24gZGVjcnlwdChwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSBkZWNvZGVQYXlsb2FkKHBheWxvYWQpO1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoIWVxdWFsQnl0ZXMoY2FsY3VsYXRlZE1hYywgbWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1BQ1wiKTtcbiAgY29uc3QgcGFkZGVkID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHVucGFkKHBhZGRlZCk7XG59XG52YXIgdjIgPSB7XG4gIHV0aWxzOiB7XG4gICAgZ2V0Q29udmVyc2F0aW9uS2V5LFxuICAgIGNhbGNQYWRkZWRMZW5cbiAgfSxcbiAgZW5jcnlwdCxcbiAgZGVjcnlwdFxufTtcbmV4cG9ydCB7XG4gIGRlY3J5cHQsXG4gIGVuY3J5cHQsXG4gIGdldENvbnZlcnNhdGlvbktleSxcbiAgdjJcbn07XG4iLCAiLyoqXG4gKiBOSVAtNDYgTm9zdHIgQ29ubmVjdCAobnNlY0J1bmtlcikgQ2xpZW50XG4gKlxuICogSW1wbGVtZW50cyB0aGUgY2xpZW50IHNpZGUgb2YgTklQLTQ2IGZvciByZW1vdGUgc2lnbmluZy5cbiAqIFRoZSBleHRlbnNpb24gY29ubmVjdHMgdG8gYSBidW5rZXIgdmlhIE5vc3RyIHJlbGF5cy5cbiAqIFRoZSBidW5rZXIgaG9sZHMgdGhlIG5zZWMgYW5kIHBlcmZvcm1zIHNpZ25pbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiBGbG93OlxuICogICAxLiBVc2VyIHByb3ZpZGVzIGEgYnVua2VyOi8vIGNvbm5lY3Rpb24gc3RyaW5nXG4gKiAgIDIuIENsaWVudCBnZW5lcmF0ZXMgYW4gZXBoZW1lcmFsIGtleXBhaXIgZm9yIHRoZSBzZXNzaW9uXG4gKiAgIDMuIENsaWVudCBjb25uZWN0cyB0byB0aGUgcmVsYXkgc3BlY2lmaWVkIGluIHRoZSBjb25uZWN0aW9uIHN0cmluZ1xuICogICA0LiBDbGllbnQgc2VuZHMgTklQLTQ0IGVuY3J5cHRlZCByZXF1ZXN0cyB0byB0aGUgYnVua2VyIHB1YmtleVxuICogICA1LiBCdW5rZXIgcmVzcG9uZHMgd2l0aCBOSVAtNDQgZW5jcnlwdGVkIHJlc3VsdHNcbiAqICAgNi4gQ2xpZW50IGRlY3J5cHRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRcbiAqXG4gKiBDb25uZWN0aW9uIHN0cmluZyBmb3JtYXQ6XG4gKiAgIGJ1bmtlcjovLzxyZW1vdGUtc2lnbmVyLXB1YmtleT4/cmVsYXk9d3NzOi8vLi4uJnJlbGF5PXdzczovLy4uLiZzZWNyZXQ9PG9wdGlvbmFsPlxuICovXG5cbmltcG9ydCB7XG4gICAgZ2V0UHVibGljS2V5LFxuICAgIGZpbmFsaXplRXZlbnQsXG59IGZyb20gJ25vc3RyLXRvb2xzJztcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGhleFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlS2V5UGFpciB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgKiBhcyBuaXA0NCBmcm9tICdub3N0ci10b29scy9uaXA0NCc7XG5pbXBvcnQgeyBhcGkgfSBmcm9tICcuL2Jyb3dzZXItcG9seWZpbGwnO1xuXG5jb25zdCBzdG9yYWdlID0gYXBpLnN0b3JhZ2UubG9jYWw7XG5jb25zdCBsb2cgPSBtc2cgPT4gY29uc29sZS5sb2coJ05JUC00NjogJywgbXNnKTtcblxuLy8gQWN0aXZlIGJ1bmtlciBzZXNzaW9ucyBrZXllZCBieSBwcm9maWxlIGluZGV4XG5jb25zdCBzZXNzaW9ucyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBQYXJzZSBhIGJ1bmtlcjovLyBjb25uZWN0aW9uIHN0cmluZ1xuICogRm9ybWF0OiBidW5rZXI6Ly88cHVia2V5Pj9yZWxheT13c3M6Ly8uLi4mcmVsYXk9d3NzOi8vLi4uJnNlY3JldD08b3B0aW9uYWw+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJ1bmtlclVybCh1cmwpIHtcbiAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdidW5rZXI6Ly8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVua2VyIFVSTDogbXVzdCBzdGFydCB3aXRoIGJ1bmtlcjovLycpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgICBjb25zdCByZW1vdGVQdWJrZXkgPSBwYXJzZWQuaG9zdG5hbWUgfHwgcGFyc2VkLnBhdGhuYW1lLnJlcGxhY2UoJy8vJywgJycpO1xuXG4gICAgaWYgKCEvXlswLTlhLWZdezY0fSQvaS50ZXN0KHJlbW90ZVB1YmtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1bmtlciBVUkw6IHB1YmtleSBtdXN0IGJlIDY0IGhleCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXlzID0gcGFyc2VkLnNlYXJjaFBhcmFtcy5nZXRBbGwoJ3JlbGF5Jyk7XG4gICAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1bmtlciBVUkw6IGF0IGxlYXN0IG9uZSByZWxheSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHJlbGF5IFVSTHNcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBVUkwocmVsYXkpO1xuICAgICAgICAgICAgaWYgKHIucHJvdG9jb2wgIT09ICd3c3M6JyAmJiByLnByb3RvY29sICE9PSAnd3M6Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWxheSBwcm90b2NvbDogJHtyLnByb3RvY29sfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVsYXkgVVJMOiAke3JlbGF5fWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcmV0ID0gcGFyc2VkLnNlYXJjaFBhcmFtcy5nZXQoJ3NlY3JldCcpIHx8IG51bGw7XG5cbiAgICByZXR1cm4geyByZW1vdGVQdWJrZXksIHJlbGF5cywgc2VjcmV0IH07XG59XG5cbi8qKlxuICogQSBzaW5nbGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gYSBOb3N0ciByZWxheVxuICovXG5leHBvcnQgY2xhc3MgUmVsYXlDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZW9zZUNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzID0gNTtcbiAgICB9XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQ6ICR7ZS5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENvbm5lY3Rpb24gdGltZW91dDogJHt0aGlzLnVybH1gKSk7XG4gICAgICAgICAgICB9LCAxMDAwMCk7XG5cbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICAgICAgbG9nKGBDb25uZWN0ZWQgdG8gJHt0aGlzLnVybH1gKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGxvZyhgV2ViU29ja2V0IGVycm9yOiAke3RoaXMudXJsfWApO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFdlYlNvY2tldCBlcnJvcjogJHt0aGlzLnVybH1gKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsb2coYERpc2Nvbm5lY3RlZCBmcm9tICR7dGhpcy51cmx9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2coYEZhaWxlZCB0byBwYXJzZSBtZXNzYWdlOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIHN1YklkLCAuLi5yZXN0XSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdFVkVOVCcgJiYgc3ViSWQgJiYgcmVzdFswXSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSByZXN0WzBdO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoc3ViSWQpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRU9TRScgJiYgc3ViSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVvc2VIYW5kbGVyID0gdGhpcy5lb3NlQ2FsbGJhY2tzLmdldChzdWJJZCk7XG4gICAgICAgICAgICBpZiAoZW9zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVvc2VDYWxsYmFja3MuZGVsZXRlKHN1YklkKTtcbiAgICAgICAgICAgICAgICBlb3NlSGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdPSycpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IGFjY2VwdGVkXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ05PVElDRScpIHtcbiAgICAgICAgICAgIGxvZyhgUmVsYXkgbm90aWNlOiAke3Jlc3RbMF19YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdWJzY3JpYmUoc3ViSWQsIGZpbHRlcnMsIG9uRXZlbnQsIG9uRW9zZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCB8fCAhdGhpcy53cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWJJZCwgb25FdmVudCk7XG4gICAgICAgIGlmIChvbkVvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW9zZUNhbGxiYWNrcy5zZXQoc3ViSWQsIG9uRW9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnUkVRJywgc3ViSWQsIC4uLmZpbHRlcnNdKSk7XG4gICAgfVxuXG4gICAgdW5zdWJzY3JpYmUoc3ViSWQpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShbJ0NMT1NFJywgc3ViSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJJZCk7XG4gICAgICAgIHRoaXMuZW9zZUNhbGxiYWNrcy5kZWxldGUoc3ViSWQpO1xuICAgIH1cblxuICAgIHB1Ymxpc2goZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCB8fCAhdGhpcy53cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnRVZFTlQnLCBldmVudF0pKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPj0gdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgbG9nKGBNYXggcmVjb25uZWN0IGF0dGVtcHRzIHJlYWNoZWQgZm9yICR7dGhpcy51cmx9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKDEwMDAgKiBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgMzAwMDApO1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbG9nKGBSZWNvbm5lY3RpbmcgdG8gJHt0aGlzLnVybH0gKGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAwOyAvLyBQcmV2ZW50IGZ1cnRoZXIgcmVjb25uZWN0c1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5lb3NlQ2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLndzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOSVAtNDYgQnVua2VyIFNlc3Npb25cbiAqXG4gKiBNYW5hZ2VzIGEgc2Vzc2lvbiB3aXRoIGEgcmVtb3RlIHNpZ25lciAobnNlY0J1bmtlcikuXG4gKiBVc2VzIGFuIGVwaGVtZXJhbCBrZXlwYWlyIGZvciBlbmNyeXB0ZWQgY29tbXVuaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJ1bmtlclNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgcmVtb3RlUHVia2V5LCByZWxheXMsIHNlY3JldCB9KSB7XG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5ID0gcmVtb3RlUHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5cztcbiAgICAgICAgdGhpcy5zZWNyZXQgPSBzZWNyZXQ7XG5cbiAgICAgICAgLy8gS2V5cGFpciB3aWxsIGJlIGluaXRpYWxpemVkIGluIGluaXQoKVxuICAgICAgICB0aGlzLnNlc3Npb25Qcml2a2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXNzaW9uUHVia2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25LZXkgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVsYXlzID0gW107XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YklkID0gYG5vc3Rya2V5LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKS5zbGljZSgwLCA4KX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGVwaGVtZXJhbCBzZXNzaW9uIGtleXBhaXIgKGFzeW5jKVxuICAgICAqL1xuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25Qcml2a2V5KSByZXR1cm47IC8vIEFscmVhZHkgaW5pdGlhbGl6ZWRcblxuICAgICAgICAvLyBHZW5lcmF0ZSBlcGhlbWVyYWwgc2Vzc2lvbiBrZXlwYWlyIHVzaW5nIG5vc3RyLWNyeXB0by11dGlsc1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gYXdhaXQgZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblByaXZrZXkgPSBoZXhUb0J5dGVzKGtleVBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblB1YmtleSA9IGtleVBhaXIucHVibGljS2V5LmhleDtcblxuICAgICAgICAvLyBEZXJpdmUgTklQLTQ0IGNvbnZlcnNhdGlvbiBrZXlcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkoXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25Qcml2a2V5LFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVQdWJrZXlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIGFsbCByZWxheXMgYW5kIHN1YnNjcmliZSBmb3IgcmVzcG9uc2VzXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gRW5zdXJlIGtleXBhaXIgaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0byByZWxheXNcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLnJlbGF5VXJscy5tYXAodXJsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF5ID0gbmV3IFJlbGF5Q29ubmVjdGlvbih1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGF5LmNvbm5lY3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF5cy5wdXNoKHJlbGF5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVsYXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgYXQgbGVhc3Qgb25lIGNvbm5lY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChjb25uZWN0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKTtcblxuICAgICAgICBpZiAoY29ubmVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBhbnkgcmVsYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZyhgQ29ubmVjdGVkIHRvICR7Y29ubmVjdGVkLmxlbmd0aH0vJHt0aGlzLnJlbGF5VXJscy5sZW5ndGh9IHJlbGF5c2ApO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSBmb3IgTklQLTQ2IHJlc3BvbnNlcyAoa2luZCAyNDEzMyBhZGRyZXNzZWQgdG8gb3VyIHNlc3Npb24gcHVia2V5KVxuICAgICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzKSB7XG4gICAgICAgICAgICByZWxheS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJJZCxcbiAgICAgICAgICAgICAgICBbeyBraW5kczogWzI0MTMzXSwgJyNwJzogW3RoaXMuc2Vzc2lvblB1YmtleV0gfV0sXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZVJlc3BvbnNlKGV2ZW50KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBTZW5kIGNvbm5lY3QgcmVxdWVzdCBpZiBzZWNyZXQgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCdjb25uZWN0JywgW3RoaXMucmVtb3RlUHVia2V5LCB0aGlzLnNlY3JldF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCgnY29ubmVjdCcsIFt0aGlzLnJlbW90ZVB1YmtleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIE5JUC00NiByZXNwb25zZSBldmVudFxuICAgICAqL1xuICAgIGhhbmRsZVJlc3BvbnNlKGV2ZW50KSB7XG4gICAgICAgIC8vIE11c3QgYmUgZnJvbSB0aGUgcmVtb3RlIHNpZ25lclxuICAgICAgICBpZiAoZXZlbnQucHVia2V5ICE9PSB0aGlzLnJlbW90ZVB1YmtleSkge1xuICAgICAgICAgICAgbG9nKGBJZ25vcmluZyBldmVudCBmcm9tIHVua25vd24gcHVia2V5OiAke2V2ZW50LnB1YmtleX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZWNyeXB0IHRoZSByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmlwNDQudjIuZGVjcnlwdChldmVudC5jb250ZW50LCB0aGlzLmNvbnZlcnNhdGlvbktleSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UocGxhaW50ZXh0KTtcblxuICAgICAgICAgICAgbG9nKGBSZXNwb25zZTogJHtyZXNwb25zZS5pZH0gLT4gJHtyZXNwb25zZS5yZXN1bHQgPyAnb2snIDogcmVzcG9uc2UuZXJyb3J9YCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5nZXQocmVzcG9uc2UuaWQpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5kZWxldGUocmVzcG9uc2UuaWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5lcnJvcikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nKGBGYWlsZWQgdG8gaGFuZGxlIHJlc3BvbnNlOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gZW5jcnlwdGVkIE5JUC00NiByZXF1ZXN0IHRvIHRoZSBidW5rZXJcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kUmVxdWVzdChtZXRob2QsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQgJiYgbWV0aG9kICE9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCB0byBidW5rZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gSlNPTi5zdHJpbmdpZnkoeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IG5pcDQ0LnYyLmVuY3J5cHQocmVxdWVzdCwgdGhpcy5jb252ZXJzYXRpb25LZXkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgc2lnbiB0aGUgZXZlbnRcbiAgICAgICAgY29uc3QgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KHtcbiAgICAgICAgICAgIGtpbmQ6IDI0MTMzLFxuICAgICAgICAgICAgY29udGVudDogZW5jcnlwdGVkLFxuICAgICAgICAgICAgdGFnczogW1sncCcsIHRoaXMucmVtb3RlUHVia2V5XV0sXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgfSwgdGhpcy5zZXNzaW9uUHJpdmtleSk7XG5cbiAgICAgICAgLy8gUHVibGlzaCB0byBhbGwgY29ubmVjdGVkIHJlbGF5c1xuICAgICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZyhgRmFpbGVkIHRvIHB1Ymxpc2ggdG8gJHtyZWxheS51cmx9OiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIHJlc3BvbnNlIHdpdGggdGltZW91dFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUmVxdWVzdCB0aW1lb3V0OiAke21ldGhvZH1gKSk7XG4gICAgICAgICAgICB9LCAzMDAwMCk7XG5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNldChpZCwge1xuICAgICAgICAgICAgICAgIHJlc29sdmU6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOSVAtNDYgTWV0aG9kc1xuICAgICAqL1xuXG4gICAgYXN5bmMgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCgnZ2V0X3B1YmxpY19rZXknKTtcbiAgICB9XG5cbiAgICBhc3luYyBzaWduRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCgnc2lnbl9ldmVudCcsIFtKU09OLnN0cmluZ2lmeShldmVudCldKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBuaXAwNEVuY3J5cHQodGhpcmRQYXJ0eVB1YmtleSwgcGxhaW50ZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCduaXAwNF9lbmNyeXB0JywgW3RoaXJkUGFydHlQdWJrZXksIHBsYWludGV4dF0pO1xuICAgIH1cblxuICAgIGFzeW5jIG5pcDA0RGVjcnlwdCh0aGlyZFBhcnR5UHVia2V5LCBjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCduaXAwNF9kZWNyeXB0JywgW3RoaXJkUGFydHlQdWJrZXksIGNpcGhlcnRleHRdKTtcbiAgICB9XG5cbiAgICBhc3luYyBuaXA0NEVuY3J5cHQodGhpcmRQYXJ0eVB1YmtleSwgcGxhaW50ZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCduaXA0NF9lbmNyeXB0JywgW3RoaXJkUGFydHlQdWJrZXksIHBsYWludGV4dF0pO1xuICAgIH1cblxuICAgIGFzeW5jIG5pcDQ0RGVjcnlwdCh0aGlyZFBhcnR5UHVia2V5LCBjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCduaXA0NF9kZWNyeXB0JywgW3RoaXJkUGFydHlQdWJrZXksIGNpcGhlcnRleHRdKTtcbiAgICB9XG5cbiAgICBhc3luYyBwaW5nKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCgncGluZycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzZXNzaW9uIGluZm8gZm9yIHBlcnNpc3RlbmNlXG4gICAgICovXG4gICAgZ2V0U2Vzc2lvbkluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGVQdWJrZXk6IHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICAgICAgcmVsYXlVcmxzOiB0aGlzLnJlbGF5VXJscyxcbiAgICAgICAgICAgIHNlY3JldDogdGhpcy5zZWNyZXQsXG4gICAgICAgICAgICBzZXNzaW9uUHJpdmtleTogYnl0ZXNUb0hleCh0aGlzLnNlc3Npb25Qcml2a2V5KSxcbiAgICAgICAgICAgIHNlc3Npb25QdWJrZXk6IHRoaXMuc2Vzc2lvblB1YmtleSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gYWxsIHJlbGF5c1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5yZWxheXMpIHtcbiAgICAgICAgICAgIHJlbGF5LnVuc3Vic2NyaWJlKHRoaXMuc3ViSWQpO1xuICAgICAgICAgICAgcmVsYXkuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGF5cyA9IFtdO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBsb2coJ0Rpc2Nvbm5lY3RlZCBmcm9tIGJ1bmtlcicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXN0b3JlIGEgc2Vzc2lvbiBmcm9tIHBlcnNpc3RlZCBzZXNzaW9uIGluZm9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVTZXNzaW9uKHNlc3Npb25JbmZvKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IG5ldyBCdW5rZXJTZXNzaW9uKHtcbiAgICAgICAgcmVtb3RlUHVia2V5OiBzZXNzaW9uSW5mby5yZW1vdGVQdWJrZXksXG4gICAgICAgIHJlbGF5czogc2Vzc2lvbkluZm8ucmVsYXlVcmxzLFxuICAgICAgICBzZWNyZXQ6IHNlc3Npb25JbmZvLnNlY3JldCxcbiAgICB9KTtcblxuICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHNlc3Npb24ga2V5cGFpciBpbnN0ZWFkIG9mIGdlbmVyYXRpbmcgbmV3IG9uZVxuICAgIHNlc3Npb24uc2Vzc2lvblByaXZrZXkgPSBoZXhUb0J5dGVzKHNlc3Npb25JbmZvLnNlc3Npb25Qcml2a2V5KTtcbiAgICBzZXNzaW9uLnNlc3Npb25QdWJrZXkgPSBzZXNzaW9uSW5mby5zZXNzaW9uUHVia2V5O1xuICAgIHNlc3Npb24uY29udmVyc2F0aW9uS2V5ID0gbmlwNDQudjIudXRpbHMuZ2V0Q29udmVyc2F0aW9uS2V5KFxuICAgICAgICBzZXNzaW9uLnNlc3Npb25Qcml2a2V5LFxuICAgICAgICBzZXNzaW9uLnJlbW90ZVB1YmtleVxuICAgICk7XG5cbiAgICByZXR1cm4gc2Vzc2lvbjtcbn1cblxuLyoqXG4gKiBTZXNzaW9uIE1hbmFnZXIgXHUyMDE0IG1hbmFnZXMgYWN0aXZlIGJ1bmtlciBzZXNzaW9ucyBwZXIgcHJvZmlsZVxuICovXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZVNlc3Npb24ocHJvZmlsZUluZGV4KSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbiBhY3RpdmUgc2Vzc2lvblxuICAgIGlmIChzZXNzaW9ucy5oYXMocHJvZmlsZUluZGV4KSkge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gc2Vzc2lvbnMuZ2V0KHByb2ZpbGVJbmRleCk7XG4gICAgICAgIGlmIChzZXNzaW9uLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Vzc2lvbiBkaXNjb25uZWN0ZWQsIGNsZWFuIHVwXG4gICAgICAgIHNlc3Npb24uZGlzY29ubmVjdCgpO1xuICAgICAgICBzZXNzaW9ucy5kZWxldGUocHJvZmlsZUluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVzdG9yZSBmcm9tIHBlcnNpc3RlZCBzZXNzaW9uIGluZm9cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBidW5rZXJTZXNzaW9uczoge30gfSk7XG4gICAgY29uc3Qgc2Vzc2lvbkluZm8gPSBkYXRhLmJ1bmtlclNlc3Npb25zPy5bcHJvZmlsZUluZGV4XTtcblxuICAgIGlmICghc2Vzc2lvbkluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBidW5rZXIgc2Vzc2lvbiBjb25maWd1cmVkIGZvciB0aGlzIHByb2ZpbGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXNzaW9uID0gcmVzdG9yZVNlc3Npb24oc2Vzc2lvbkluZm8pO1xuICAgIGF3YWl0IHNlc3Npb24uY29ubmVjdCgpO1xuICAgIHNlc3Npb25zLnNldChwcm9maWxlSW5kZXgsIHNlc3Npb24pO1xuICAgIHJldHVybiBzZXNzaW9uO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbihwcm9maWxlSW5kZXgsIGJ1bmtlclVybCkge1xuICAgIC8vIERpc2Nvbm5lY3QgZXhpc3Rpbmcgc2Vzc2lvblxuICAgIGlmIChzZXNzaW9ucy5oYXMocHJvZmlsZUluZGV4KSkge1xuICAgICAgICBzZXNzaW9ucy5nZXQocHJvZmlsZUluZGV4KS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNlc3Npb25zLmRlbGV0ZShwcm9maWxlSW5kZXgpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHBhcnNlQnVua2VyVXJsKGJ1bmtlclVybCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IG5ldyBCdW5rZXJTZXNzaW9uKGNvbmZpZyk7XG4gICAgYXdhaXQgc2Vzc2lvbi5jb25uZWN0KCk7XG5cbiAgICAvLyBQZXJzaXN0IHNlc3Npb24gaW5mb1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yYWdlLmdldCh7IGJ1bmtlclNlc3Npb25zOiB7fSB9KTtcbiAgICBjb25zdCBidW5rZXJTZXNzaW9ucyA9IGRhdGEuYnVua2VyU2Vzc2lvbnMgfHwge307XG4gICAgYnVua2VyU2Vzc2lvbnNbcHJvZmlsZUluZGV4XSA9IHNlc3Npb24uZ2V0U2Vzc2lvbkluZm8oKTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IGJ1bmtlclNlc3Npb25zIH0pO1xuXG4gICAgc2Vzc2lvbnMuc2V0KHByb2ZpbGVJbmRleCwgc2Vzc2lvbik7XG4gICAgcmV0dXJuIHNlc3Npb247XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0U2Vzc2lvbihwcm9maWxlSW5kZXgpIHtcbiAgICBpZiAoc2Vzc2lvbnMuaGFzKHByb2ZpbGVJbmRleCkpIHtcbiAgICAgICAgc2Vzc2lvbnMuZ2V0KHByb2ZpbGVJbmRleCkuZGlzY29ubmVjdCgpO1xuICAgICAgICBzZXNzaW9ucy5kZWxldGUocHJvZmlsZUluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgcGVyc2lzdGVkIHNlc3Npb25cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBidW5rZXJTZXNzaW9uczoge30gfSk7XG4gICAgY29uc3QgYnVua2VyU2Vzc2lvbnMgPSBkYXRhLmJ1bmtlclNlc3Npb25zIHx8IHt9O1xuICAgIGRlbGV0ZSBidW5rZXJTZXNzaW9uc1twcm9maWxlSW5kZXhdO1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgYnVua2VyU2Vzc2lvbnMgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Nlc3Npb25BY3RpdmUocHJvZmlsZUluZGV4KSB7XG4gICAgcmV0dXJuIHNlc3Npb25zLmhhcyhwcm9maWxlSW5kZXgpICYmIHNlc3Npb25zLmdldChwcm9maWxlSW5kZXgpLmNvbm5lY3RlZDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIGJ1bmtlciBVUkwgd2l0aG91dCBjb25uZWN0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJ1bmtlclVybCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZUJ1bmtlclVybCh1cmwpO1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZXJyb3I6IG51bGwgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgIH1cbn1cbiIsICIvKipcbiAqIE5JUC03OCBFbmNyeXB0ZWQgVmF1bHQgUHJvdG9jb2xcbiAqXG4gKiBQdXJlIGZ1bmN0aW9ucyBmb3IgYnVpbGRpbmcvcGFyc2luZyBraW5kIDMwMDc4IChwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlKVxuICogZXZlbnRzIHVzZWQgYXMgYW4gZW5jcnlwdGVkIG1hcmtkb3duIGRvY3VtZW50IHZhdWx0LlxuICpcbiAqIGQtdGFnIHByZWZpeCBcIm5vc3Rya2V5OlwiIG5hbWVzcGFjZXMgb3VyIHZhdWx0IGl0ZW1zIGZyb20gb3RoZXIgTklQLTc4IGFwcHMuXG4gKiBSZWxheXMgc2VlIGZpbGUgcGF0aHMgYnV0IG5vdCBjb250ZW50IChOSVAtNDQgZW5jcnlwdGVkIHRvIHNlbGYpLlxuICovXG5cbmNvbnN0IEtJTkRfQVBQX0RBVEEgPSAzMDA3ODtcbmNvbnN0IEtJTkRfREVMRVRJT04gPSA1O1xuY29uc3QgRFRBR19QUkVGSVggPSAnbm9zdHJrZXk6JztcbmNvbnN0IENMSUVOVF9UQUcgPSAnbm9zdHJrZXknO1xuXG4vKipcbiAqIEJ1aWxkIGFuIHVuc2lnbmVkIGtpbmQgMzAwNzggdmF1bHQgZXZlbnQuXG4gKiBDYWxsZXIgbXVzdCBzaWduIChmaW5hbGl6ZUV2ZW50IG9yIGJ1bmtlciBzZXNzaW9uLnNpZ25FdmVudCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBEb2N1bWVudCBwYXRoIChlLmcuIFwibm90ZXMvdG9kby5tZFwiKVxuICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRlZENvbnRlbnQgLSBOSVAtNDQgZW5jcnlwdGVkIGNvbnRlbnQgc3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBVbnNpZ25lZCBldmVudCB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWYXVsdEV2ZW50KHBhdGgsIGVuY3J5cHRlZENvbnRlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBLSU5EX0FQUF9EQVRBLFxuICAgICAgICBjb250ZW50OiBlbmNyeXB0ZWRDb250ZW50LFxuICAgICAgICB0YWdzOiBbXG4gICAgICAgICAgICBbJ2QnLCBgJHtEVEFHX1BSRUZJWH0ke3BhdGh9YF0sXG4gICAgICAgICAgICBbJ2NsaWVudCcsIENMSUVOVF9UQUddLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIHVuc2lnbmVkIGtpbmQgNSBkZWxldGlvbiBldmVudCAoTklQLTA5KSBmb3IgYSB2YXVsdCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRJZCAtIFRoZSBldmVudCBpZCB0byBkZWxldGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gRG9jdW1lbnQgcGF0aCAoZm9yIHRoZSBhLXRhZyByZWZlcmVuY2UpXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBVbnNpZ25lZCBkZWxldGlvbiBldmVudCB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWYXVsdERlbGV0aW9uKGV2ZW50SWQsIHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBLSU5EX0RFTEVUSU9OLFxuICAgICAgICBjb250ZW50OiAndmF1bHQgZG9jdW1lbnQgZGVsZXRlZCcsXG4gICAgICAgIHRhZ3M6IFtcbiAgICAgICAgICAgIFsnZScsIGV2ZW50SWRdLFxuICAgICAgICAgICAgWydhJywgYCR7S0lORF9BUFBfREFUQX06OiR7RFRBR19QUkVGSVh9JHtwYXRofWBdLFxuICAgICAgICBdLFxuICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgUkVRIGZpbHRlciBmb3IgZmV0Y2hpbmcgYWxsIHZhdWx0IGRvY3VtZW50cyBmb3IgYSBwdWJrZXkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmtleSAtIEhleCBwdWJsaWMga2V5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBOb3N0ciBSRVEgZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFZhdWx0RmlsdGVyKHB1YmtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmRzOiBbS0lORF9BUFBfREFUQV0sXG4gICAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgIH07XG59XG5cbi8qKlxuICogUGFyc2UgYSBraW5kIDMwMDc4IGV2ZW50IGludG8gYSB2YXVsdCBkb2N1bWVudCBkZXNjcmlwdG9yLlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBldmVudCBpcyBub3QgYSBub3N0cmtleSB2YXVsdCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBOb3N0ciBldmVudFxuICogQHJldHVybnMge3sgcGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIGNyZWF0ZWRBdDogbnVtYmVyLCBldmVudElkOiBzdHJpbmcgfSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZhdWx0RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2luZCAhPT0gS0lORF9BUFBfREFUQSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBkVGFnID0gZXZlbnQudGFncz8uZmluZCh0ID0+IHRbMF0gPT09ICdkJyk7XG4gICAgaWYgKCFkVGFnIHx8ICFkVGFnWzFdPy5zdGFydHNXaXRoKERUQUdfUFJFRklYKSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBwYXRoID0gZFRhZ1sxXS5zbGljZShEVEFHX1BSRUZJWC5sZW5ndGgpO1xuICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBjb250ZW50OiBldmVudC5jb250ZW50LFxuICAgICAgICBjcmVhdGVkQXQ6IGV2ZW50LmNyZWF0ZWRfYXQsXG4gICAgICAgIGV2ZW50SWQ6IGV2ZW50LmlkLFxuICAgIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgICBuaXAwNCxcbiAgICBuaXA0NCxcbiAgICBuaXAxOSxcbiAgICBnZXRQdWJsaWNLZXksXG4gICAgZmluYWxpemVFdmVudCxcbn0gZnJvbSAnbm9zdHItdG9vbHMnO1xuaW1wb3J0IHsgZW5jcnlwdCBhcyBuaXA0OUVuY3J5cHQsIGRlY3J5cHQgYXMgbmlwNDlEZWNyeXB0IH0gZnJvbSAnbm9zdHItdG9vbHMvbmlwNDknO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgaGV4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVLZXlQYWlyIH0gZnJvbSAnLi91dGlsaXRpZXMva2V5cy5qcyc7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2FzeW5jLW11dGV4JztcbmltcG9ydCB7XG4gICAgZ2V0UHJvZmlsZUluZGV4LFxuICAgIGdldCxcbiAgICBnZXRQcm9maWxlLFxuICAgIGdldFByb2ZpbGVzLFxuICAgIGdldFBlcm1pc3Npb24sXG4gICAgc2V0UGVybWlzc2lvbixcbiAgICBpc0VuY3J5cHRlZCxcbiAgICBjaGVja1Bhc3N3b3JkLFxuICAgIGVuY3J5cHRBbGxLZXlzLFxuICAgIGNoYW5nZVBhc3N3b3JkRm9yS2V5cyxcbiAgICByZW1vdmVQYXNzd29yZFByb3RlY3Rpb24sXG4gICAgZ2V0RGVjcnlwdGVkUHJpdktleSxcbiAgICBpc0VuY3J5cHRlZEJsb2IsXG59IGZyb20gJy4vdXRpbGl0aWVzL3V0aWxzJztcbmltcG9ydCB7IGVuY3J5cHQgYXMgZW5jcnlwdEJsb2IgfSBmcm9tICcuL3V0aWxpdGllcy9jcnlwdG8nO1xuaW1wb3J0IHsgc2F2ZUV2ZW50IH0gZnJvbSAnLi91dGlsaXRpZXMvZGInO1xuaW1wb3J0IHsgYXBpIH0gZnJvbSAnLi91dGlsaXRpZXMvYnJvd3Nlci1wb2x5ZmlsbCc7XG5pbXBvcnQge1xuICAgIFJlbGF5Q29ubmVjdGlvbixcbiAgICBnZXRPckNyZWF0ZVNlc3Npb24sXG4gICAgY3JlYXRlU2Vzc2lvbixcbiAgICBkaXNjb25uZWN0U2Vzc2lvbixcbiAgICBpc1Nlc3Npb25BY3RpdmUsXG4gICAgdmFsaWRhdGVCdW5rZXJVcmwsXG59IGZyb20gJy4vdXRpbGl0aWVzL25pcDQ2JztcbmltcG9ydCB7XG4gICAgYnVpbGRWYXVsdEV2ZW50LFxuICAgIGJ1aWxkVmF1bHREZWxldGlvbixcbiAgICBidWlsZFZhdWx0RmlsdGVyLFxuICAgIHBhcnNlVmF1bHRFdmVudCxcbn0gZnJvbSAnLi91dGlsaXRpZXMvbmlwNzgnO1xuXG5jb25zdCBzdG9yYWdlID0gYXBpLnN0b3JhZ2UubG9jYWw7XG5jb25zdCBsb2cgPSBtc2cgPT4gY29uc29sZS5sb2coJ0JhY2tncm91bmQ6ICcsIG1zZyk7XG5jb25zdCB2YWxpZGF0aW9ucyA9IHt9O1xubGV0IHByb21wdCA9IHsgbXV0ZXg6IG5ldyBNdXRleCgpLCByZWxlYXNlOiBudWxsLCB0YWJJZDogbnVsbCB9O1xuXG4vLyBSYXRlIGxpbWl0ZXI6IG1heCA1IHBlcm1pc3Npb24gcHJvbXB0cyBwZXIgaG9zdCBwZXIgMTAtc2Vjb25kIHdpbmRvd1xuY29uc3QgcmF0ZUxpbWl0cyA9IG5ldyBNYXAoKTtcbmNvbnN0IFJBVEVfTElNSVRfTUFYID0gNTtcbmNvbnN0IFJBVEVfTElNSVRfV0lORE9XID0gMTAwMDA7XG5cbmZ1bmN0aW9uIGlzUmF0ZUxpbWl0ZWQoaG9zdCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSByYXRlTGltaXRzLmdldChob3N0KSB8fCBbXTtcbiAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5maWx0ZXIodCA9PiBub3cgLSB0IDwgUkFURV9MSU1JVF9XSU5ET1cpO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA+PSBSQVRFX0xJTUlUX01BWCkge1xuICAgICAgICByYXRlTGltaXRzLnNldChob3N0LCB0aW1lc3RhbXBzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMucHVzaChub3cpO1xuICAgIHJhdGVMaW1pdHMuc2V0KGhvc3QsIHRpbWVzdGFtcHMpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gLS0tIFNlc3Npb24gc3RhdGUgZm9yIG1hc3RlciBwYXNzd29yZCBlbmNyeXB0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVjcnlwdGVkIGtleXMgYXJlIGhlbGQgaW4gbWVtb3J5IG9ubHkgd2hpbGUgdW5sb2NrZWQuXG4vLyBNYXAgb2YgcHJvZmlsZUluZGV4IC0+IGhleCBwcml2YXRlIGtleSBzdHJpbmdcbmNvbnN0IHNlc3Npb25LZXlzID0gbmV3IE1hcCgpO1xubGV0IHNlc3Npb25QYXNzd29yZCA9IG51bGw7IC8vIGhlbGQgaW4gbWVtb3J5IHRvIHJlLWVuY3J5cHQgbmV3IGtleXMgZHVyaW5nIHNlc3Npb25cbmxldCBsb2NrZWQgPSB0cnVlOyAvLyBzdGFydCBsb2NrZWQ7IGRldGVybWluZWQgb24gZmlyc3QgaXNMb2NrZWQgY2hlY2tcbmxldCBhdXRvTG9ja1RpbWVvdXQgPSAxNSAqIDYwICogMTAwMDsgLy8gMTUgbWludXRlcyBkZWZhdWx0XG5sZXQgYXV0b0xvY2tUaW1lciA9IG51bGw7XG5cbi8vIExvYWQgcGVyc2lzdGVkIGF1dG8tbG9jayB0aW1lb3V0IG9uIHN0YXJ0dXBcbihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBhdXRvTG9ja01pbnV0ZXMgfSA9IGF3YWl0IHN0b3JhZ2UuZ2V0KHsgYXV0b0xvY2tNaW51dGVzOiAxNSB9KTtcbiAgICBhdXRvTG9ja1RpbWVvdXQgPSBhdXRvTG9ja01pbnV0ZXMgKiA2MCAqIDEwMDA7XG59KSgpO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBhdXRvLWxvY2sgaW5hY3Rpdml0eSB0aW1lci5cbiAqL1xuZnVuY3Rpb24gcmVzZXRBdXRvTG9jaygpIHtcbiAgICBpZiAoYXV0b0xvY2tUaW1lcikgY2xlYXJUaW1lb3V0KGF1dG9Mb2NrVGltZXIpO1xuICAgIGlmICghbG9ja2VkICYmIGF1dG9Mb2NrVGltZW91dCA+IDApIHtcbiAgICAgICAgYXV0b0xvY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbG9ja1Nlc3Npb24oKTtcbiAgICAgICAgfSwgYXV0b0xvY2tUaW1lb3V0KTtcbiAgICB9XG59XG5cbi8qKlxuICogTG9jayB0aGUgc2Vzc2lvbiBcdTIwMTQgY2xlYXIgYWxsIGRlY3J5cHRlZCBrZXlzIGZyb20gbWVtb3J5LlxuICovXG5mdW5jdGlvbiBsb2NrU2Vzc2lvbigpIHtcbiAgICBzZXNzaW9uS2V5cy5jbGVhcigpO1xuICAgIHNlc3Npb25QYXNzd29yZCA9IG51bGw7XG4gICAgbG9ja2VkID0gdHJ1ZTtcbiAgICBpZiAoYXV0b0xvY2tUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYXV0b0xvY2tUaW1lcik7XG4gICAgICAgIGF1dG9Mb2NrVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBsb2coJ1Nlc3Npb24gbG9ja2VkLicpO1xufVxuXG4vKipcbiAqIFVubG9jayB0aGUgc2Vzc2lvbiBcdTIwMTQgdmVyaWZ5IHBhc3N3b3JkIGFuZCBkZWNyeXB0IGFsbCBrZXlzIGludG8gbWVtb3J5LlxuICovXG5hc3luYyBmdW5jdGlvbiB1bmxvY2tTZXNzaW9uKHBhc3N3b3JkKSB7XG4gICAgY29uc3QgdmFsaWQgPSBhd2FpdCBjaGVja1Bhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBpZiAoIXZhbGlkKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIHBhc3N3b3JkJyB9O1xuXG4gICAgY29uc3QgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb2ZpbGVzW2ldLnR5cGUgPT09ICdidW5rZXInKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGV4ID0gYXdhaXQgZ2V0RGVjcnlwdGVkUHJpdktleShwcm9maWxlc1tpXSwgcGFzc3dvcmQpO1xuICAgICAgICBzZXNzaW9uS2V5cy5zZXQoaSwgaGV4KTtcbiAgICB9XG4gICAgc2Vzc2lvblBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgbG9ja2VkID0gZmFsc2U7XG4gICAgcmVzZXRBdXRvTG9jaygpO1xuICAgIGxvZygnU2Vzc2lvbiB1bmxvY2tlZC4nKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIGN1cnJlbnRseSBpbiBhIGxvY2tlZCBzdGF0ZS5cbiAqIElmIG5vIHBhc3N3b3JkIGlzIHNldCwgd2UgYXJlIG5ldmVyIGxvY2tlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tMb2NrU3RhdGUoKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgaXNFbmNyeXB0ZWQoKTtcbiAgICBpZiAoIWVuY3J5cHRlZCkge1xuICAgICAgICBsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9ja2VkO1xufVxuXG4vLyAtLS0gTWVzc2FnZSBoYW5kbGVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmFwaS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigobWVzc2FnZSwgX3NlbmRlciwgc2VuZFJlc3BvbnNlKSA9PiB7XG4gICAgbG9nKG1lc3NhZ2UpO1xuICAgIGxldCB1dWlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICBsZXQgc3I7XG5cbiAgICBzd2l0Y2ggKG1lc3NhZ2Uua2luZCkge1xuICAgICAgICAvLyBHZW5lcmFsXG4gICAgICAgIGNhc2UgJ2Nsb3NlUHJvbXB0JzpcbiAgICAgICAgICAgIHByb21wdC5yZWxlYXNlPy4oKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIGNhc2UgJ2FsbG93ZWQnOlxuICAgICAgICAgICAgcmVzZXRBdXRvTG9jaygpO1xuICAgICAgICAgICAgY29tcGxldGUobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICBjYXNlICdkZW5pZWQnOlxuICAgICAgICAgICAgZGVueShtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIGNhc2UgJ2dlbmVyYXRlUHJpdmF0ZUtleSc6XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlUHJpdmF0ZUtleV8oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnZW5lcmF0ZVByaXZhdGVLZXkgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgbWVzc2FnZSBjaGFubmVsIG9wZW4gZm9yIGFzeW5jIHNlbmRSZXNwb25zZVxuICAgICAgICBjYXNlICdzYXZlUHJpdmF0ZUtleSc6XG4gICAgICAgICAgICByZXNldEF1dG9Mb2NrKCk7XG4gICAgICAgICAgICByZXR1cm4gc2F2ZVByaXZhdGVLZXkobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgY2FzZSAnZ2V0TnB1Yic6XG4gICAgICAgICAgICByZXNldEF1dG9Mb2NrKCk7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldE5wdWIobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnZXROcHViIGVycm9yOicsIGUpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdnZXROc2VjJzpcbiAgICAgICAgICAgIHJlc2V0QXV0b0xvY2soKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0TnNlYyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldE5zZWMgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2NhbGNQdWJLZXknOlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRQdWJsaWNLZXkobWVzc2FnZS5wYXlsb2FkKSk7XG4gICAgICAgIGNhc2UgJ25wdWJFbmNvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuaXAxOS5ucHViRW5jb2RlKG1lc3NhZ2UucGF5bG9hZCkpO1xuICAgICAgICBjYXNlICdjb3B5JzpcbiAgICAgICAgICAgIC8vIG5hdmlnYXRvci5jbGlwYm9hcmQgaXMgdW5hdmFpbGFibGUgaW4gQ2hyb21lIHNlcnZpY2Ugd29ya2Vycy5cbiAgICAgICAgICAgIC8vIFRoZSBjYWxsZXIgKHBvcHVwL29wdGlvbnMpIHNob3VsZCBoYW5kbGUgY2xpcGJvYXJkIGRpcmVjdGx5IHdoZW5cbiAgICAgICAgICAgIC8vIHBvc3NpYmxlOyB0aGlzIHBhdGggaXMga2VwdCBmb3IgU2FmYXJpIGJhY2tncm91bmQtcGFnZSBjb21wYXQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmNsaXBib2FyZD8ud3JpdGVUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblxuICAgICAgICAvLyAtLS0gTWFzdGVyIHBhc3N3b3JkIC8gbG9jayBoYW5kbGVycyAtLS1cbiAgICAgICAgY2FzZSAnaXNMb2NrZWQnOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrTG9ja1N0YXRlKCk7XG4gICAgICAgIGNhc2UgJ2lzRW5jcnlwdGVkJzpcbiAgICAgICAgICAgIHJldHVybiBpc0VuY3J5cHRlZCgpO1xuICAgICAgICBjYXNlICd1bmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIHVubG9ja1Nlc3Npb24obWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgY2FzZSAnbG9jayc6XG4gICAgICAgICAgICBsb2NrU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgY2FzZSAnc2V0UGFzc3dvcmQnOlxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBlbmNyeXB0QWxsS2V5cyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1bmxvY2tTZXNzaW9uKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdjaGFuZ2VQYXNzd29yZCc6XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gYXdhaXQgY2hlY2tQYXNzd29yZChvbGRQYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgY3VycmVudCBwYXNzd29yZCcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hhbmdlUGFzc3dvcmRGb3JLZXlzKG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVubG9ja1Nlc3Npb24obmV3UGFzc3dvcmQpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAncmVtb3ZlUGFzc3dvcmQnOlxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVQYXNzd29yZFByb3RlY3Rpb24obWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbktleXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblBhc3N3b3JkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ3NldEF1dG9Mb2NrVGltZW91dCc6XG4gICAgICAgICAgICBhdXRvTG9ja1RpbWVvdXQgPSBtZXNzYWdlLnBheWxvYWQgKiA2MCAqIDEwMDA7IC8vIHBheWxvYWQgaW4gbWludXRlc1xuICAgICAgICAgICAgc3RvcmFnZS5zZXQoeyBhdXRvTG9ja01pbnV0ZXM6IG1lc3NhZ2UucGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHJlc2V0QXV0b0xvY2soKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIGNhc2UgJ2dldEF1dG9Mb2NrVGltZW91dCc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dG9Mb2NrTWludXRlcyB9ID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBhdXRvTG9ja01pbnV0ZXM6IDE1IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdXRvTG9ja01pbnV0ZXM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICdyZXNldEF1dG9Mb2NrJzpcbiAgICAgICAgICAgIHJlc2V0QXV0b0xvY2soKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cbiAgICAgICAgLy8gLS0tIE5JUC00OSBuY3J5cHRzZWMgaGFuZGxlcnMgLS0tXG4gICAgICAgIGNhc2UgJ25jcnlwdHNlYy5kZWNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmNyeXB0c2VjLCBwYXNzd29yZCB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZXhLZXkgPSBieXRlc1RvSGV4KG5pcDQ5RGVjcnlwdChuY3J5cHRzZWMsIHBhc3N3b3JkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGhleEtleSB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfHwgJ0RlY3J5cHRpb24gZmFpbGVkJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ25jcnlwdHNlYy5lbmNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvZmlsZUluZGV4OiBlaSwgcGFzc3dvcmQgfSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUoZWkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZmlsZT8udHlwZSA9PT0gJ2J1bmtlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0Nhbm5vdCBleHBvcnQgYnVua2VyIHByb2ZpbGUgYXMgbmNyeXB0c2VjJyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhleEtleSA9IGF3YWl0IGdldFBsYWludGV4dFByaXZLZXkoZWksIHByb2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuY3J5cHRzZWMgPSBuaXA0OUVuY3J5cHQoaGV4VG9CeXRlcyhoZXhLZXkpLCBwYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG5jcnlwdHNlYyB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfHwgJ0VuY3J5cHRpb24gZmFpbGVkJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgLy8gLS0tIE5JUC00NiBCdW5rZXIgaGFuZGxlcnMgLS0tXG4gICAgICAgIGNhc2UgJ2dldFByb2ZpbGVUeXBlJzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpID0gbWVzc2FnZS5wYXlsb2FkID8/IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZmlsZT8udHlwZSB8fCAnbG9jYWwnO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgY2FzZSAnYnVua2VyLmNvbm5lY3QnOlxuICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm9maWxlSW5kZXg6IGJpLCBidW5rZXJVcmwgfSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGNyZWF0ZVNlc3Npb24oYmksIGJ1bmtlclVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVB1YmtleSA9IGF3YWl0IHNlc3Npb24uZ2V0UHVibGljS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlbW90ZVB1YmtleSBvbiB0aGUgcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGVzW2JpXS5yZW1vdGVQdWJrZXkgPSByZW1vdGVQdWJrZXk7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGVzW2JpXS5idW5rZXJVcmwgPSBidW5rZXJVcmw7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHJlbW90ZVB1YmtleSB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICdidW5rZXIuZGlzY29ubmVjdCc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGlzY29ubmVjdFNlc3Npb24oYmkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ2J1bmtlci5zdGF0dXMnOlxuICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmkgPSBtZXNzYWdlLnBheWxvYWQgPz8gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29ubmVjdGVkOiBpc1Nlc3Npb25BY3RpdmUoYmkpIH07XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICdidW5rZXIucGluZyc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaSA9IG1lc3NhZ2UucGF5bG9hZCA/PyBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldE9yQ3JlYXRlU2Vzc2lvbihiaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlc3Npb24ucGluZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCByZXN1bHQgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgY2FzZSAnYnVua2VyLnZhbGlkYXRlVXJsJzpcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGVCdW5rZXJVcmwobWVzc2FnZS5wYXlsb2FkKSk7XG5cbiAgICAgICAgLy8gLS0tIFZhdWx0IGhhbmRsZXJzIC0tLVxuICAgICAgICBjYXNlICd2YXVsdC5wdWJsaXNoJzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCwgY29udGVudCB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwdWJrZXkgPSBhd2FpdCBnZXRQdWJLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgbmlwNDRFbmNyeXB0KHsgcHViS2V5OiBwdWJrZXksIHBsYWluVGV4dDogY29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5zaWduZWQgPSBidWlsZFZhdWx0RXZlbnQocGF0aCwgZW5jcnlwdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWduZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T3JDcmVhdGVTZXNzaW9uKHBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCA9IGF3YWl0IHNlc3Npb24uc2lnbkV2ZW50KHVuc2lnbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNrID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkID0gZmluYWxpemVFdmVudCh1bnNpZ25lZCwgc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2l0aFJlbGF5cygnd3JpdGUnLCBhc3luYyAocmVsYXlzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlbGF5LnB1Ymxpc2goc2lnbmVkKTsgfSBjYXRjaCAoXykge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGV2ZW50SWQ6IHNpZ25lZC5pZCwgY3JlYXRlZEF0OiBzaWduZWQuY3JlYXRlZF9hdCB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICd2YXVsdC5mZXRjaCc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwdWJrZXkgPSBhd2FpdCBnZXRQdWJLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gYnVpbGRWYXVsdEZpbHRlcihwdWJrZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxFdmVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3aXRoUmVsYXlzKCdyZWFkJywgYXN5bmMgKHJlbGF5cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyUmVsYXkgPSByZWxheXMubWFwKHJlbGF5ID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSBgdmF1bHQtJHtjcnlwdG8ucmFuZG9tVVVJRCgpLnNsaWNlKDAsIDgpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZWxheS51bnN1YnNjcmliZShzdWJJZCk7IH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxNTAwMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxheS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7IGFsbEV2ZW50cy5wdXNoKGV2ZW50KTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmVsYXkudW5zdWJzY3JpYmUoc3ViSWQpOyB9IGNhdGNoIChfKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHBlclJlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVkdXBsaWNhdGUgYnkgZC10YWcgXHUyMDE0IGxhdGVzdCBjcmVhdGVkX2F0IHdpbnMgKE5JUC0zMylcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlEdGFnID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGFsbEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VWYXVsdEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYnlEdGFnLmdldChwYXJzZWQucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nIHx8IHBhcnNlZC5jcmVhdGVkQXQgPiBleGlzdGluZy5jcmVhdGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieUR0YWcuc2V0KHBhcnNlZC5wYXRoLCB7IGV2ZW50LCBwYXJzZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGVhY2ggZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleV8gPSBhd2FpdCBnZXRQdWJLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGV2ZW50LCBwYXJzZWQgfSBvZiBieUR0YWcudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgbmlwNDREZWNyeXB0KHsgcHViS2V5OiBwdWJrZXlfLCBjaXBoZXJUZXh0OiBldmVudC5jb250ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyc2VkLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGRlY3J5cHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBwYXJzZWQuY3JlYXRlZEF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudElkOiBwYXJzZWQuZXZlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGRvY3VtZW50cyB3ZSBjYW4ndCBkZWNyeXB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZG9jdW1lbnRzIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ3ZhdWx0LmRlbGV0ZSc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGgsIGV2ZW50SWQgfSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5zaWduZWQgPSBidWlsZFZhdWx0RGVsZXRpb24oZXZlbnRJZCwgcGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGkgPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUocGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lnbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZmlsZS50eXBlID09PSAnYnVua2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldE9yQ3JlYXRlU2Vzc2lvbihwaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduZWQgPSBhd2FpdCBzZXNzaW9uLnNpZ25FdmVudCh1bnNpZ25lZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzayA9IGF3YWl0IGdldFByaXZLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCA9IGZpbmFsaXplRXZlbnQodW5zaWduZWQsIHNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdpdGhSZWxheXMoJ3dyaXRlJywgYXN5bmMgKHJlbGF5cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZWxheS5wdWJsaXNoKHNpZ25lZCk7IH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ3ZhdWx0LmdldFJlbGF5cyc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgY3VycmVudFByb2ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXlzID0gcHJvZmlsZS5yZWxheXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWQgPSByZWxheXMuZmlsdGVyKHIgPT4gci5yZWFkKS5tYXAociA9PiByLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlID0gcmVsYXlzLmZpbHRlcihyID0+IHIud3JpdGUpLm1hcChyID0+IHIudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVhZCwgd3JpdGUgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlYWQ6IFtdLCB3cml0ZTogW10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8vIC0tLSBBUEkgS2V5IFZhdWx0IGhhbmRsZXJzIC0tLVxuICAgICAgICBjYXNlICdhcGlrZXlzLnB1Ymxpc2gnOlxuICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZXlzIH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IGdldFB1YktleSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFpblRleHQgPSBKU09OLnN0cmluZ2lmeShrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgbmlwNDRFbmNyeXB0KHsgcHViS2V5OiBwdWJrZXksIHBsYWluVGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5zaWduZWQgPSBidWlsZFZhdWx0RXZlbnQoJ3ZhdWx0L2FwaS1rZXlzJywgZW5jcnlwdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWduZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T3JDcmVhdGVTZXNzaW9uKHBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCA9IGF3YWl0IHNlc3Npb24uc2lnbkV2ZW50KHVuc2lnbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNrID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkID0gZmluYWxpemVFdmVudCh1bnNpZ25lZCwgc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2l0aFJlbGF5cygnd3JpdGUnLCBhc3luYyAocmVsYXlzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlbGF5LnB1Ymxpc2goc2lnbmVkKTsgfSBjYXRjaCAoXykge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGV2ZW50SWQ6IHNpZ25lZC5pZCwgY3JlYXRlZEF0OiBzaWduZWQuY3JlYXRlZF9hdCB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICdhcGlrZXlzLmZldGNoJzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IGdldFB1YktleSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzMwMDc4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyNkJzogWydub3N0cmtleTp2YXVsdC9hcGkta2V5cyddLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxFdmVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3aXRoUmVsYXlzKCdyZWFkJywgYXN5bmMgKHJlbGF5cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyUmVsYXkgPSByZWxheXMubWFwKHJlbGF5ID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSBgYXBpa2V5cy0ke2NyeXB0by5yYW5kb21VVUlEKCkuc2xpY2UoMCwgOCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlbGF5LnVuc3Vic2NyaWJlKHN1YklkKTsgfSBjYXRjaCAoXykge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDE1MDAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5LnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHsgYWxsRXZlbnRzLnB1c2goZXZlbnQpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZWxheS51bnN1YnNjcmliZShzdWJJZCk7IH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocGVyUmVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBieSBjcmVhdGVkX2F0IChzaW5nbGUgZC10YWcsIE5JUC0zMyBkZWR1cClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhdGVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgYWxsRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhdGVzdCB8fCBldmVudC5jcmVhdGVkX2F0ID4gbGF0ZXN0LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3QgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBrZXlzOiBudWxsLCBldmVudElkOiBudWxsLCBjcmVhdGVkQXQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IG5pcDQ0RGVjcnlwdCh7IHB1YktleTogcHVia2V5LCBjaXBoZXJUZXh0OiBsYXRlc3QuY29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5cywgZXZlbnRJZDogbGF0ZXN0LmlkLCBjcmVhdGVkQXQ6IGxhdGVzdC5jcmVhdGVkX2F0IH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ2FwaWtleXMuZGVsZXRlJzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRJZCB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnNpZ25lZCA9IGJ1aWxkVmF1bHREZWxldGlvbihldmVudElkLCAndmF1bHQvYXBpLWtleXMnKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWduZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T3JDcmVhdGVTZXNzaW9uKHBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCA9IGF3YWl0IHNlc3Npb24uc2lnbkV2ZW50KHVuc2lnbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNrID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkID0gZmluYWxpemVFdmVudCh1bnNpZ25lZCwgc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2l0aFJlbGF5cygnd3JpdGUnLCBhc3luYyAocmVsYXlzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlbGF5LnB1Ymxpc2goc2lnbmVkKTsgfSBjYXRjaCAoXykge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgY2FzZSAnYXBpa2V5cy5lbmNyeXB0JzpcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGxhaW5UZXh0IH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IGdldFB1YktleSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaXBoZXJUZXh0ID0gYXdhaXQgbmlwNDRFbmNyeXB0KHsgcHViS2V5OiBwdWJrZXksIHBsYWluVGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY2lwaGVyVGV4dCB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlICdhcGlrZXlzLmRlY3J5cHQnOlxuICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjaXBoZXJUZXh0IH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IGdldFB1YktleSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFpblRleHQgPSBhd2FpdCBuaXA0NERlY3J5cHQoeyBwdWJLZXk6IHB1YmtleSwgY2lwaGVyVGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcGxhaW5UZXh0IH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgLy8gbm9zdHI6IHByb3RvY29sIFVSTCBoYW5kbGVyIFx1MjAxNCBubyBrZXkgYWNjZXNzIG5lZWRlZCwgbm8gcGVybWlzc2lvbiBwcm9tcHRcbiAgICAgICAgY2FzZSAncmVwbGFjZVVSTCc6XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3RvY29sX2hhbmRsZXIgfSA9IGF3YWl0IHN0b3JhZ2UuZ2V0KFsncHJvdG9jb2xfaGFuZGxlciddKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3RvY29sX2hhbmRsZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHVybC5zcGxpdCgnbm9zdHI6JylbMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyYXcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IG5pcDE5LmRlY29kZShyYXcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBocnA6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ25wdWInIHx8IHR5cGUgPT09ICdub3RlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlID09PSAnbnByb2ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhLnB1YmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ25ldmVudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlID09PSAnbmFkZHInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5wdWJrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwX29yX2U6IHsgbnB1YjogJ3AnLCBub3RlOiAnZScsIG5wcm9maWxlOiAncCcsIG5ldmVudDogJ2UnLCBuYWRkcjogJ2EnIH1bdHlwZV0gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB1X29yX246IHsgbnB1YjogJ3UnLCBub3RlOiAnbicsIG5wcm9maWxlOiAndScsIG5ldmVudDogJ24nLCBuYWRkcjogJ24nIH1bdHlwZV0gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxheTA6IGRhdGE/LnJlbGF5cz8uWzBdIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXkxOiBkYXRhPy5yZWxheXM/LlsxXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5MjogZGF0YT8ucmVsYXlzPy5bMl0gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwcm90b2NvbF9oYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwYXR0ZXJuLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVwbGFjZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXHsgKiR7cGF0dGVybn0gKlxcXFx9YCwgJ2cnKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8vIHdpbmRvdy5ub3N0clxuICAgICAgICBjYXNlICdnZXRQdWJLZXknOlxuICAgICAgICBjYXNlICdzaWduRXZlbnQnOlxuICAgICAgICBjYXNlICduaXAwNC5lbmNyeXB0JzpcbiAgICAgICAgY2FzZSAnbmlwMDQuZGVjcnlwdCc6XG4gICAgICAgIGNhc2UgJ25pcDQ0LmVuY3J5cHQnOlxuICAgICAgICBjYXNlICduaXA0NC5kZWNyeXB0JzpcbiAgICAgICAgY2FzZSAnZ2V0UmVsYXlzJzpcbiAgICAgICAgICAgIHZhbGlkYXRpb25zW3V1aWRdID0gc2VuZFJlc3BvbnNlO1xuICAgICAgICAgICAgYXNrKHV1aWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSDQgZml4OiBkZW55IHBlbmRpbmcgcmVxdWVzdCBvbiB0aW1lb3V0IGluc3RlYWQgb2Ygc2lsZW50bHkgcmVsZWFzaW5nXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25zW3V1aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbnkoeyBwYXlsb2FkOiB1dWlkLCBvcmlnS2luZDogbWVzc2FnZS5raW5kLCBob3N0OiBtZXNzYWdlLmhvc3QgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21wdC5yZWxlYXNlPy4oKTtcbiAgICAgICAgICAgIH0sIDEwXzAwMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59KTtcblxuYXN5bmMgZnVuY3Rpb24gZm9yY2VSZWxlYXNlKCkge1xuICAgIGlmIChwcm9tcHQudGFiSWQgIT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwcm9tcHQgaXMgc3RpbGwgb3BlbiwgdGhlbiB0aGlzIHdvbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gSWYgaXQncyBub3Qgb3BlbiwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBhbmQgZ2V0IGNhdWdodC5cbiAgICAgICAgICAgIGF3YWl0IGFwaS50YWJzLmdldChwcm9tcHQudGFiSWQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhYiBpcyBjbG9zZWQsIGJ1dCBzb21laG93IGVzY2FwZWQgb3VyIGV2ZW50IGhhbmRsaW5nLCB3ZSBjYW4gY2xlYW4gaXQgdXAgaGVyZVxuICAgICAgICAgICAgLy8gYmVmb3JlIGF0dGVtcHRpbmcgdG8gb3BlbiB0aGUgbmV4dCB0YWIuXG4gICAgICAgICAgICBwcm9tcHQucmVsZWFzZT8uKCk7XG4gICAgICAgICAgICBwcm9tcHQudGFiSWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVByaXZhdGVLZXlfKCkge1xuICAgIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBnZW5lcmF0ZUtleVBhaXIoKTtcbiAgICByZXR1cm4ga2V5UGFpci5wcml2YXRlS2V5O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhc2sodXVpZCwgeyBraW5kLCBob3N0LCBwYXlsb2FkIH0pIHtcbiAgICAvLyBCdW5rZXIgcHJvZmlsZXMgZG9uJ3QgbmVlZCBsb2NhbCBrZXkgZGVjcnlwdGlvbiBcdTIwMTQgc2tpcCBsb2NrIGNoZWNrXG4gICAgY29uc3QgcGkgPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwaSk7XG4gICAgY29uc3QgaXNCdW5rZXIgPSBwcm9maWxlPy50eXBlID09PSAnYnVua2VyJztcblxuICAgIC8vIElmIHRoZSBleHRlbnNpb24gaXMgbG9ja2VkLCByZWplY3Qgc2lnbmluZy9lbmNyeXB0aW9uIHJlcXVlc3RzIChsb2NhbCBwcm9maWxlcyBvbmx5KVxuICAgIGlmICghaXNCdW5rZXIpIHtcbiAgICAgICAgY29uc3QgaXNMb2NrZWQgPSBhd2FpdCBjaGVja0xvY2tTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbmRSZXNwb25zZSA9IHZhbGlkYXRpb25zW3V1aWRdO1xuICAgICAgICAgICAgZGVsZXRlIHZhbGlkYXRpb25zW3V1aWRdO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlPy4oeyBlcnJvcjogJ2xvY2tlZCcsIG1lc3NhZ2U6ICdFeHRlbnNpb24gaXMgbG9ja2VkLiBQbGVhc2UgdW5sb2NrIHdpdGggeW91ciBtYXN0ZXIgcGFzc3dvcmQuJyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJhdGUgbGltaXQgcGVybWlzc2lvbiBwcm9tcHRzIHBlciBob3N0XG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQoaG9zdCkpIHtcbiAgICAgICAgY29uc3Qgc2VuZFJlc3BvbnNlID0gdmFsaWRhdGlvbnNbdXVpZF07XG4gICAgICAgIGRlbGV0ZSB2YWxpZGF0aW9uc1t1dWlkXTtcbiAgICAgICAgc2VuZFJlc3BvbnNlPy4oeyBlcnJvcjogJ3JhdGVfbGltaXRlZCcsIG1lc3NhZ2U6ICdUb28gbWFueSByZXF1ZXN0cy4gUGxlYXNlIHdhaXQuJyB9KTtcbiAgICAgICAgbG9nKGBSYXRlIGxpbWl0ZWQ6ICR7aG9zdH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc2V0QXV0b0xvY2soKTtcbiAgICBhd2FpdCBmb3JjZVJlbGVhc2UoKTsgLy8gQ2xlYW4gdXAgcHJldmlvdXMgdGFiIGlmIGl0IGNsb3NlZCB3aXRob3V0IGNsZWFuaW5nIGl0c2VsZiB1cFxuICAgIHByb21wdC5yZWxlYXNlID0gYXdhaXQgcHJvbXB0Lm11dGV4LmFjcXVpcmUoKTtcblxuICAgIGxldCBtS2luZCA9IGtpbmQgPT09ICdzaWduRXZlbnQnID8gYHNpZ25FdmVudDoke3BheWxvYWQua2luZH1gIDoga2luZDtcbiAgICBsZXQgcGVybWlzc2lvbiA9IGF3YWl0IGdldFBlcm1pc3Npb24oaG9zdCwgbUtpbmQpO1xuICAgIGlmIChwZXJtaXNzaW9uID09PSAnYWxsb3cnKSB7XG4gICAgICAgIGNvbXBsZXRlKHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHV1aWQsXG4gICAgICAgICAgICBvcmlnS2luZDoga2luZCxcbiAgICAgICAgICAgIGV2ZW50OiBwYXlsb2FkLFxuICAgICAgICAgICAgcmVtZW1iZXI6IGZhbHNlLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21wdC5yZWxlYXNlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGVybWlzc2lvbiA9PT0gJ2RlbnknKSB7XG4gICAgICAgIGRlbnkoeyBwYXlsb2FkOiB1dWlkLCBvcmlnS2luZDoga2luZCwgaG9zdCB9KTtcbiAgICAgICAgcHJvbXB0LnJlbGVhc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBzaG93IGJvdHRvbSBzaGVldCBpbiB0aGUgYWN0aXZlIHRhYidzIGNvbnRlbnQgc2NyaXB0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2FjdGl2ZVRhYl0gPSBhd2FpdCBhcGkudGFicy5xdWVyeSh7IGFjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZVRhYj8uaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaS50YWJzLnNlbmRNZXNzYWdlKGFjdGl2ZVRhYi5pZCwge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdzaG93UGVybWlzc2lvblNoZWV0JyxcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25LaW5kOiBraW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogdXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdLaW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1lbWJlcjogcmVzdWx0LnJlbWVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB1dWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ0tpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWVtYmVyOiByZXN1bHQucmVtZW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbXB0LnJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIENvbnRlbnQgc2NyaXB0IG5vdCBhdmFpbGFibGUsIGZhbGwgYmFjayB0byB0YWJcbiAgICAgICAgbG9nKCdCb3R0b20gc2hlZXQgdW5hdmFpbGFibGUsIGZhbGxpbmcgYmFjayB0byB0YWI6JywgZS5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBwZXJtaXNzaW9uIHRhYlxuICAgIGxldCBxcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICB1dWlkLFxuICAgICAgICBraW5kLFxuICAgICAgICBob3N0LFxuICAgICAgICBwYXlsb2FkOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkIHx8IGZhbHNlKSxcbiAgICB9KTtcbiAgICBsZXQgdGFiID0gYXdhaXQgYXBpLnRhYnMuZ2V0Q3VycmVudCgpO1xuICAgIGxldCBwID0gYXdhaXQgYXBpLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgdXJsOiBhcGkucnVudGltZS5nZXRVUkwoYHBlcm1pc3Npb24vcGVybWlzc2lvbi5odG1sPyR7cXMudG9TdHJpbmcoKX1gKSxcbiAgICAgICAgb3BlbmVyVGFiSWQ6IHRhYj8uaWQsXG4gICAgfSk7XG4gICAgcHJvbXB0LnRhYklkID0gcC5pZDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGUoeyBwYXlsb2FkLCBvcmlnS2luZCwgZXZlbnQsIHJlbWVtYmVyLCBob3N0IH0pIHtcbiAgICBjb25zdCBzZW5kUmVzcG9uc2UgPSB2YWxpZGF0aW9uc1twYXlsb2FkXTtcbiAgICBkZWxldGUgdmFsaWRhdGlvbnNbcGF5bG9hZF07XG5cbiAgICBpZiAocmVtZW1iZXIpIHtcbiAgICAgICAgbGV0IG1LaW5kID1cbiAgICAgICAgICAgIG9yaWdLaW5kID09PSAnc2lnbkV2ZW50JyA/IGBzaWduRXZlbnQ6JHtldmVudC5raW5kfWAgOiBvcmlnS2luZDtcbiAgICAgICAgc2V0UGVybWlzc2lvbihob3N0LCBtS2luZCwgJ2FsbG93Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbmRSZXNwb25zZSkge1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIGxvZyhgRXJyb3IgaW4gJHtvcmlnS2luZH06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHsgZXJyb3I6ICdidW5rZXJfZXJyb3InLCBtZXNzYWdlOiBlLm1lc3NhZ2UgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChvcmlnS2luZCkge1xuICAgICAgICAgICAgY2FzZSAnZ2V0UHViS2V5JzpcbiAgICAgICAgICAgICAgICBnZXRQdWJLZXkoKS50aGVuKHBrID0+IHNlbmRSZXNwb25zZShwaykpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2lnbkV2ZW50JzpcbiAgICAgICAgICAgICAgICBzaWduRXZlbnRfKGV2ZW50LCBob3N0KS50aGVuKGUgPT4gc2VuZFJlc3BvbnNlKGUpKS5jYXRjaChvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25pcDA0LmVuY3J5cHQnOlxuICAgICAgICAgICAgICAgIG5pcDA0RW5jcnlwdChldmVudCkudGhlbihlID0+IHNlbmRSZXNwb25zZShlKSkuY2F0Y2gob25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduaXAwNC5kZWNyeXB0JzpcbiAgICAgICAgICAgICAgICBuaXAwNERlY3J5cHQoZXZlbnQpLnRoZW4oZSA9PiBzZW5kUmVzcG9uc2UoZSkpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmlwNDQuZW5jcnlwdCc6XG4gICAgICAgICAgICAgICAgbmlwNDRFbmNyeXB0KGV2ZW50KS50aGVuKGUgPT4gc2VuZFJlc3BvbnNlKGUpKS5jYXRjaChvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25pcDQ0LmRlY3J5cHQnOlxuICAgICAgICAgICAgICAgIG5pcDQ0RGVjcnlwdChldmVudCkudGhlbihlID0+IHNlbmRSZXNwb25zZShlKSkuY2F0Y2gob25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnZXRSZWxheXMnOlxuICAgICAgICAgICAgICAgIGdldFJlbGF5cygpLnRoZW4oZSA9PiBzZW5kUmVzcG9uc2UoZSkpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZW55KHsgb3JpZ0tpbmQsIGhvc3QsIHBheWxvYWQsIHJlbWVtYmVyLCBldmVudCB9KSB7XG4gICAgY29uc3Qgc2VuZFJlc3BvbnNlID0gdmFsaWRhdGlvbnNbcGF5bG9hZF07XG4gICAgZGVsZXRlIHZhbGlkYXRpb25zW3BheWxvYWRdO1xuXG4gICAgaWYgKHJlbWVtYmVyKSB7XG4gICAgICAgIGxldCBtS2luZCA9XG4gICAgICAgICAgICBvcmlnS2luZCA9PT0gJ3NpZ25FdmVudCcgPyBgc2lnbkV2ZW50OiR7ZXZlbnQua2luZH1gIDogb3JpZ0tpbmQ7XG4gICAgICAgIHNldFBlcm1pc3Npb24oaG9zdCwgbUtpbmQsICdkZW55Jyk7XG4gICAgfVxuXG4gICAgc2VuZFJlc3BvbnNlPy4odW5kZWZpbmVkKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIE9wdGlvbnNcbmFzeW5jIGZ1bmN0aW9uIHNhdmVQcml2YXRlS2V5KFtpbmRleCwgcHJpdktleV0pIHtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShpbmRleCk7XG4gICAgaWYgKHByb2ZpbGU/LnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBwcml2YXRlIGtleSBvbiBhIGJ1bmtlciBwcm9maWxlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcml2S2V5ICE9PSAnc3RyaW5nJyB8fCBwcml2S2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXk6IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgbGV0IGhleEtleTtcbiAgICBpZiAocHJpdktleS5zdGFydHNXaXRoKCduc2VjJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOS5kZWNvZGUocHJpdktleSkuZGF0YTtcbiAgICAgICAgICAgIGhleEtleSA9IGJ5dGVzVG9IZXgoZGVjb2RlZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuc2VjIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhIGhleCBzdHJpbmdcbiAgICAgICAgaGV4S2V5ID0gcHJpdktleTtcbiAgICB9XG5cbiAgICBpZiAoIS9eWzAtOWEtZl17NjR9JC9pLnRlc3QoaGV4S2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXk6IG11c3QgYmUgNjQgaGV4IGNoYXJhY3RlcnMgb3IgdmFsaWQgbnNlYycpO1xuICAgIH1cblxuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldCgncHJvZmlsZXMnKTtcblxuICAgIGlmICghcHJvZmlsZXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHByb2ZpbGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvZmlsZSBpbmRleCcpO1xuICAgIH1cblxuICAgIC8vIElmIGVuY3J5cHRpb24gaXMgYWN0aXZlLCByZS1lbmNyeXB0IHRoZSBuZXcga2V5IHVzaW5nIHRoZSBzZXNzaW9uIHBhc3N3b3JkXG4gICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgaXNFbmNyeXB0ZWQoKTtcbiAgICBpZiAoZW5jcnlwdGVkICYmIHNlc3Npb25QYXNzd29yZCkge1xuICAgICAgICBwcm9maWxlc1tpbmRleF0ucHJpdktleSA9IGF3YWl0IGVuY3J5cHRCbG9iKGhleEtleSwgc2Vzc2lvblBhc3N3b3JkKTtcbiAgICAgICAgc2Vzc2lvbktleXMuc2V0KGluZGV4LCBoZXhLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2ZpbGVzW2luZGV4XS5wcml2S2V5ID0gaGV4S2V5O1xuICAgIH1cblxuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE5zZWMoaW5kZXgpIHtcbiAgICBsZXQgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUoaW5kZXgpO1xuXG4gICAgaWYgKHByb2ZpbGUudHlwZSA9PT0gJ2J1bmtlcicpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IGhleEtleSA9IGF3YWl0IGdldFBsYWludGV4dFByaXZLZXkoaW5kZXgsIHByb2ZpbGUpO1xuICAgIGxldCBuc2VjID0gbmlwMTkubnNlY0VuY29kZShoZXhUb0J5dGVzKGhleEtleSkpO1xuICAgIHJldHVybiBuc2VjO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXROcHViKGluZGV4KSB7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKGluZGV4KTtcblxuICAgIGlmICghcHJvZmlsZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAocHJvZmlsZS50eXBlID09PSAnYnVua2VyJykge1xuICAgICAgICBpZiAocHJvZmlsZS5yZW1vdGVQdWJrZXkpIHJldHVybiBuaXAxOS5ucHViRW5jb2RlKHByb2ZpbGUucmVtb3RlUHVia2V5KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGhleEtleSA9IGF3YWl0IGdldFBsYWludGV4dFByaXZLZXkoaW5kZXgsIHByb2ZpbGUpO1xuICAgICAgICBpZiAoIWhleEtleSB8fCB0eXBlb2YgaGV4S2V5ICE9PSAnc3RyaW5nJyB8fCBoZXhLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB1YktleSA9IGdldFB1YmxpY0tleShoZXhUb0J5dGVzKGhleEtleSkpO1xuICAgICAgICBsZXQgbnB1YiA9IG5pcDE5Lm5wdWJFbmNvZGUocHViS2V5KTtcbiAgICAgICAgcmV0dXJuIG5wdWI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnZXROcHViIGVycm9yOicsIGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwbGFpbnRleHQgaGV4IHByaXZhdGUga2V5IGZvciBhIHByb2ZpbGUuXG4gKiBVc2VzIHNlc3Npb24gY2FjaGUgaWYgZW5jcnlwdGlvbiBpcyBhY3RpdmUsIG90aGVyd2lzZSByZWFkcyBmcm9tIHN0b3JhZ2UgZGlyZWN0bHkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBsYWludGV4dFByaXZLZXkoaW5kZXgsIHByb2ZpbGUpIHtcbiAgICBpZiAoaXNFbmNyeXB0ZWRCbG9iKHByb2ZpbGUucHJpdktleSkpIHtcbiAgICAgICAgLy8gS2V5IGlzIGVuY3J5cHRlZCBcdTIwMTQgbXVzdCB1c2Ugc2Vzc2lvbiBjYWNoZVxuICAgICAgICBpZiAoc2Vzc2lvbktleXMuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25LZXlzLmdldChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gaXMgbG9ja2VkIFx1MjAxNCBjYW5ub3QgYWNjZXNzIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9maWxlLnByaXZLZXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFByaXZLZXkoKSB7XG4gICAgbGV0IGluZGV4ID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBjdXJyZW50UHJvZmlsZSgpO1xuICAgIGxldCBoZXhLZXkgPSBhd2FpdCBnZXRQbGFpbnRleHRQcml2S2V5KGluZGV4LCBwcm9maWxlKTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhLZXkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRQdWJLZXkoKSB7XG4gICAgbGV0IHBpID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHBpKTtcblxuICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgcmVtb3RlUHVia2V5LCBvciBsaXZlLXF1ZXJ5IGFuZCBjYWNoZVxuICAgICAgICBpZiAocHJvZmlsZS5yZW1vdGVQdWJrZXkpIHJldHVybiBwcm9maWxlLnJlbW90ZVB1YmtleTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldE9yQ3JlYXRlU2Vzc2lvbihwaSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IHNlc3Npb24uZ2V0UHVibGljS2V5KCk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVzID0gYXdhaXQgZ2V0KCdwcm9maWxlcycpO1xuICAgICAgICBwcm9maWxlc1twaV0ucmVtb3RlUHVia2V5ID0gcHVia2V5O1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgICAgICByZXR1cm4gcHVia2V5O1xuICAgIH1cblxuICAgIGxldCBwcml2S2V5ID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgIGxldCBwdWJLZXkgPSBnZXRQdWJsaWNLZXkocHJpdktleSk7XG4gICAgcmV0dXJuIHB1YktleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3VycmVudFByb2ZpbGUoKSB7XG4gICAgbGV0IGluZGV4ID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0KCdwcm9maWxlcycpO1xuICAgIHJldHVybiBwcm9maWxlc1tpbmRleF07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNpZ25FdmVudF8oZXZlbnQsIGhvc3QpIHtcbiAgICBldmVudCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcblxuICAgIGNvbnN0IHBpID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUocGkpO1xuXG4gICAgaWYgKHByb2ZpbGUudHlwZSA9PT0gJ2J1bmtlcicpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldE9yQ3JlYXRlU2Vzc2lvbihwaSk7XG4gICAgICAgIGV2ZW50ID0gYXdhaXQgc2Vzc2lvbi5zaWduRXZlbnQoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzayA9IGF3YWl0IGdldFByaXZLZXkoKTtcbiAgICAgICAgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2ZW50LCBzayk7XG4gICAgfVxuXG4gICAgc2F2ZUV2ZW50KHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG1ldGFkYXRhOiB7IGhvc3QsIHNpZ25lZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG5pcDA0RW5jcnlwdCh7IHB1YktleSwgcGxhaW5UZXh0IH0pIHtcbiAgICBjb25zdCBwaSA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHBpKTtcblxuICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXRPckNyZWF0ZVNlc3Npb24ocGkpO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbi5uaXAwNEVuY3J5cHQocHViS2V5LCBwbGFpblRleHQpO1xuICAgIH1cblxuICAgIGxldCBwcml2S2V5ID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgIHJldHVybiBuaXAwNC5lbmNyeXB0KHByaXZLZXksIHB1YktleSwgcGxhaW5UZXh0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbmlwMDREZWNyeXB0KHsgcHViS2V5LCBjaXBoZXJUZXh0IH0pIHtcbiAgICBjb25zdCBwaSA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHBpKTtcblxuICAgIGlmIChwcm9maWxlLnR5cGUgPT09ICdidW5rZXInKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXRPckNyZWF0ZVNlc3Npb24ocGkpO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbi5uaXAwNERlY3J5cHQocHViS2V5LCBjaXBoZXJUZXh0KTtcbiAgICB9XG5cbiAgICBsZXQgcHJpdktleSA9IGF3YWl0IGdldFByaXZLZXkoKTtcbiAgICByZXR1cm4gbmlwMDQuZGVjcnlwdChwcml2S2V5LCBwdWJLZXksIGNpcGhlclRleHQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBuaXA0NEVuY3J5cHQoeyBwdWJLZXksIHBsYWluVGV4dCB9KSB7XG4gICAgY29uc3QgcGkgPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwaSk7XG5cbiAgICBpZiAocHJvZmlsZS50eXBlID09PSAnYnVua2VyJykge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0T3JDcmVhdGVTZXNzaW9uKHBpKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb24ubmlwNDRFbmNyeXB0KHB1YktleSwgcGxhaW5UZXh0KTtcbiAgICB9XG5cbiAgICBsZXQgcHJpdktleSA9IGF3YWl0IGdldFByaXZLZXkoKTtcbiAgICBsZXQgY29udmVyc2F0aW9uS2V5ID0gbmlwNDQudjIudXRpbHMuZ2V0Q29udmVyc2F0aW9uS2V5KHByaXZLZXksIHB1YktleSk7XG4gICAgcmV0dXJuIG5pcDQ0LnYyLmVuY3J5cHQocGxhaW5UZXh0LCBjb252ZXJzYXRpb25LZXkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBuaXA0NERlY3J5cHQoeyBwdWJLZXksIGNpcGhlclRleHQgfSkge1xuICAgIGNvbnN0IHBpID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUocGkpO1xuXG4gICAgaWYgKHByb2ZpbGUudHlwZSA9PT0gJ2J1bmtlcicpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldE9yQ3JlYXRlU2Vzc2lvbihwaSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLm5pcDQ0RGVjcnlwdChwdWJLZXksIGNpcGhlclRleHQpO1xuICAgIH1cblxuICAgIGxldCBwcml2S2V5ID0gYXdhaXQgZ2V0UHJpdktleSgpO1xuICAgIGxldCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkocHJpdktleSwgcHViS2V5KTtcbiAgICByZXR1cm4gbmlwNDQudjIuZGVjcnlwdChjaXBoZXJUZXh0LCBjb252ZXJzYXRpb25LZXkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheXMoKSB7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBjdXJyZW50UHJvZmlsZSgpO1xuICAgIGxldCByZWxheXMgPSBwcm9maWxlLnJlbGF5cztcbiAgICBsZXQgcmVsYXlPYmogPSB7fTtcbiAgICAvLyBUaGUgZ2V0UmVsYXlzIGNhbGwgZXhwZWN0cyB0aGlzIHRvIGJlIHJldHVybmVkIGFzIGFuIG9iamVjdCwgbm90IGFycmF5XG4gICAgcmVsYXlzLmZvckVhY2gocmVsYXkgPT4ge1xuICAgICAgICBsZXQgeyB1cmwsIHJlYWQsIHdyaXRlIH0gPSByZWxheTtcbiAgICAgICAgcmVsYXlPYmpbdXJsXSA9IHsgcmVhZCwgd3JpdGUgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVsYXlPYmo7XG59XG5cbi8qKlxuICogT3BlbiBlcGhlbWVyYWwgcmVsYXkgY29ubmVjdGlvbnMsIGV4ZWN1dGUgY2FsbGJhY2ssIHRoZW4gZGlzY29ubmVjdC5cbiAqIENvcnJlY3QgZm9yIENocm9tZSBNVjMgc2VydmljZSB3b3JrZXIgbGlmZWN5Y2xlIChubyBwZXJzaXN0ZW50IHBvb2wpLlxuICpcbiAqIEBwYXJhbSB7J3JlYWQnfCd3cml0ZSd9IG1vZGUgLSBXaGljaCByZWxheSBzdWJzZXQgdG8gY29ubmVjdCB0b1xuICogQHBhcmFtIHtmdW5jdGlvbihSZWxheUNvbm5lY3Rpb25bXSk6IFByb21pc2V9IGNhbGxiYWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdpdGhSZWxheXMobW9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgY3VycmVudFByb2ZpbGUoKTtcbiAgICBjb25zdCByZWxheUxpc3QgPSBwcm9maWxlLnJlbGF5cyB8fCBbXTtcbiAgICBjb25zdCB1cmxzID0gcmVsYXlMaXN0XG4gICAgICAgIC5maWx0ZXIociA9PiBtb2RlID09PSAncmVhZCcgPyByLnJlYWQgOiByLndyaXRlKVxuICAgICAgICAubWFwKHIgPT4gci51cmwpO1xuXG4gICAgaWYgKHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVsYXlzIGNvbmZpZ3VyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlcyA9IHVybHMubWFwKGFzeW5jICh1cmwpID0+IHtcbiAgICAgICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXlDb25uZWN0aW9uKHVybCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHJlbGF5KTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gU2tpcCByZWxheXMgdGhhdCBmYWlsIHRvIGNvbm5lY3RcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNvbm5lY3RQcm9taXNlcyk7XG5cbiAgICBpZiAoY29ubmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgdG8gYW55IHJlbGF5Jyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soY29ubmVjdGlvbnMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHJlbGF5LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiLyoqXG4gKiBDaHJvbWUgTVYzIHNlcnZpY2Ugd29ya2VyIGVudHJ5IHBvaW50LlxuICpcbiAqIENocm9tZSBNVjMgcmVxdWlyZXMgYSBzZXJ2aWNlIHdvcmtlciBpbnN0ZWFkIG9mIGEgYmFja2dyb3VuZCBwYWdlLlxuICogVGhpcyBmaWxlIHNpbXBseSByZS1leHBvcnRzIGV2ZXJ5dGhpbmcgZnJvbSBiYWNrZ3JvdW5kLmpzIHNvIHRoYXRcbiAqIGVzYnVpbGQgY2FuIGJ1bmRsZSBpdCBpbnRvIGEgc2luZ2xlIGZpbGUgKGJhY2tncm91bmQtc3cuYnVpbGQuanMpXG4gKiB0aGF0IGlzIHJlZmVyZW5jZWQgYnkgdGhlIENocm9tZSBtYW5pZmVzdCdzIFwic2VydmljZV93b3JrZXJcIiBmaWVsZC5cbiAqXG4gKiBUaGUgYmFja2dyb3VuZC5qcyBtb2R1bGUgcmVnaXN0ZXJzIGl0cyBvd24gcnVudGltZS5vbk1lc3NhZ2UgbGlzdGVuZXJcbiAqIGF0IGltcG9ydCB0aW1lLCBzbyBpbXBvcnRpbmcgaXQgaGVyZSBpcyBzdWZmaWNpZW50IHRvIGFjdGl2YXRlIGFsbFxuICogYmFja2dyb3VuZCBsb2dpYy5cbiAqL1xuXG5pbXBvcnQgJy4vYmFja2dyb3VuZC5qcyc7XG5cbi8vIE9wZW4gc2lkZSBwYW5lbCB3aGVuIGFjdGlvbiBidXR0b24gaXMgY2xpY2tlZCAoQ2hyb21lIG9ubHkpXG5pZiAodHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hyb21lLnNpZGVQYW5lbCkge1xuICAgIGNocm9tZS5hY3Rpb24ub25DbGlja2VkLmFkZExpc3RlbmVyKGFzeW5jICh0YWIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNocm9tZS5zaWRlUGFuZWwub3Blbih7IHRhYklkOiB0YWIuaWQgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBvcGVuIHNpZGUgcGFuZWw6JywgZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldCBzaWRlIHBhbmVsIGJlaGF2aW9yIHRvIG9wZW4gb24gYWN0aW9uIGNsaWNrXG4gICAgY2hyb21lLnNpZGVQYW5lbC5zZXRQYW5lbEJlaGF2aW9yKHsgb3BlblBhbmVsT25BY3Rpb25DbGljazogdHJ1ZSB9KS5jYXRjaCgoKSA9PiB7fSk7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOztBQU1NLFdBQVUsUUFB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S0FBSyxNQUFNLEtBQUssTUFBTTtBQUMzQyxhQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsS0FBSyxHQUFHO0FBQ2xDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUssTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBQzlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBRTlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBQzlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBRTlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBQzlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7SUFDaEQ7QUFFQSxRQUFJLEtBQUs7QUFDVCxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDdkQsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQUcsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQ3ZELFFBQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUFHLFFBQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUN2RCxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDdkQsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQUcsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQ3ZELFFBQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUFHLFFBQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUN2RCxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxRQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDdkQsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQUcsUUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0VBQ3pEO0FBT00sV0FBVSxRQUNkLEdBQWdCLEdBQWdCQyxJQUFnQixLQUFnQjtBQUVoRSxRQUFJLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQzdDLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQzdDLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQzdDLE1BQU1BLEdBQUUsQ0FBQyxHQUFHLE1BQU1BLEdBQUUsQ0FBQyxHQUFHLE1BQU1BLEdBQUUsQ0FBQyxHQUFHLE1BQU1BLEdBQUUsQ0FBQztBQUNqRCxhQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSyxHQUFHO0FBQzlCLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUQsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBQzlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBRTlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxDQUFDO0FBQzlDLFlBQU8sTUFBTSxNQUFPO0FBQUcsWUFBTUEsTUFBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxZQUFPLE1BQU0sTUFBTztBQUFHLFlBQU1BLE1BQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsWUFBTyxNQUFNLE1BQU87QUFBRyxZQUFNQSxNQUFLLE1BQU0sS0FBSyxFQUFFO0FBQy9DLFlBQU8s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QUFPLEtBQUssTUFBTSxNQUFNLEdBQUcsRUFBRTtBQUM3RCxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUksQ0FBQztBQUFHLGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBSSxDQUFDO0FBQzdELGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQUcsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0QsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFJLENBQUM7QUFBRyxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUksQ0FBQztBQUM3RCxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUcsRUFBRTtBQUFHLGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdELGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBSSxDQUFDO0FBQUcsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFJLENBQUM7QUFDN0QsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFBRyxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUcsRUFBRTtBQUM3RCxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUksQ0FBQztBQUFHLGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBSSxDQUFDO0FBQzdELGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQUcsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0QsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFJLENBQUM7QUFBRyxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUksQ0FBQztBQUM3RCxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUcsRUFBRTtBQUFHLGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdELGFBQU8sS0FBSyxNQUFNLE1BQU0sR0FBSSxDQUFDO0FBQUcsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFJLENBQUM7QUFDN0QsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFBRyxhQUFPLEtBQUssTUFBTSxNQUFNLEdBQUcsRUFBRTtBQUM3RCxhQUFPLEtBQUssTUFB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T0FBTyxVQUFVLEtBQUssRUFBRSxPQUFPLElBQUksR0FBRyxDQUFDO0FBQUEsTUFDakQsU0FBUyxHQUFHO0FBQ1IsZ0JBQVEsTUFBTSw4QkFBOEIsQ0FBQztBQUFBLE1BQ2pEO0FBQUEsSUFDSixDQUFDO0FBR0QsV0FBTyxVQUFVLGlCQUFpQixFQUFFLHdCQUF3QixLQUFLLENBQUMsRUFBRSxNQUFNLE1BQU07QUFBQSxJQUFDLENBQUM7QUFBQSxFQUN0RjsiLAogICJuYW1lcyI6IFsiaSIsICJpIiwgImkiLCAicGFkIiwgImlzTEUiLCAiaSIsICJpIiwgIm51bSIsICJpIiwgImkiLCAiXzBuIiwgIl8xbiIsICJfMG4iLCAiXzFuIiwgImdjZCIsICJpIiwgIm51bSIsICJfMG4iLCAiXzFuIiwgImkiLCAiXzFuIiwgIl8wbiIsICJfMW4iLCAibnVtIiwgImlzTEUiLCAiaXNMRSIsICJudW0iLCAiXzFuIiwgIl8wbiIsICJfMW4iLCAiaSIsICJ3aW5kb3ciLCAiXzBuIiwgIl8xbiIsICJ3aW5kb3ciLCAiaSIsICJpc0xFIiwgIl8wbiIsICJnZXRQdWJsaWNLZXkiLCAicGFkIiwgImkiLCAibnVtIiwgIl8ybiIsICJfMG4iLCAiXzFuIiwgIl8zbiIsICJfNG4iLCAicG9pbnRUb0J5dGVzIiwgImVuZG8iLCAibXVsIiwgIm51bSIsICJnZXRQdWJsaWNLZXkiLCAicmFuZG9tQnl0ZXMiLCAiaG1hYyIsICJfMm4iLCAiXzFuIiwgInIiLCAicyIsICJfMG4iLCAiXzBuIiwgIl8ybiIsICJfM24iLCAiaXNCeXRlcyIsICJhYnl0ZXMiLCAiYW51bWJlciIsICJ3cmFwIiwgImRlY29kZSIsICJpIiwgImkiLCAicGFkZGluZyIsICJhbnVtYmVyIiwgImFudW1iZXIiLCAiaXNCeXRlcyIsICJhbHBoYWJldCIsICJhYnl0ZXMiLCAiaSIsICJpc0J5dGVzIiwgImRlY29kZSIsICJpc0J5dGVzIiwgImFib29sIiwgImFudW1iZXIiLCAiYWJ5dGVzIiwgImFleGlzdHMiLCAiYW91dHB1dCIsICJ1MzIiLCAiY2xlYW4iLCAiaSIsICJjcmVhdGVWaWV3IiwgImlzTEUiLCAiY2hlY2tPcHRzIiwgImkiLCAiYWJ5dGVzIiwgImlzTEUiLCAiYWJvb2wiLCAibnVtIiwgImNyZWF0ZVZpZXciLCAiY29weUJ5dGVzIiwgImkiLCAiY2xlYW4iLCAic2JveCIsICJzYm94MiIsICJpIiwgImFieXRlcyIsICJjb3B5Qnl0ZXMiLCAidTMyIiwgImNsZWFuIiwgInQwIiwgInQxIiwgInQyIiwgInQzIiwgImFieXRlcyIsICJjb3B5Qnl0ZXMiLCAidTMyIiwgImkiLCAiY29weUJ5dGVzIiwgInUzMiIsICJpIiwgImNsZWFuIiwgImFieXRlcyIsICJ1MzIiLCAiaSIsICJhYnl0ZXMiLCAiaSIsICJjbGVhbiIsICJ1MzIiLCAicm90bCIsICJpc0FsaWduZWQzMiIsICJjaGVja09wdHMiLCAiYW51bWJlciIsICJhYm9vbCIsICJhYnl0ZXMiLCAiY29weUJ5dGVzIiwgImNsZWFuIiwgImkiLCAiY29weUJ5dGVzIiwgImFieXRlcyIsICJpIiwgInBhZCIsICJjbGVhbiIsICJhZXhpc3RzIiwgImFvdXRwdXQiLCAicm90bCIsICJpIiwgImFieXRlcyIsICJjbGVhbiIsICJjaGFsbGVuZ2UiLCAiZGVjcnlwdCIsICJlbmNyeXB0IiwgImRlY3J5cHQyIiwgImVuY3J5cHQyIiwgIm51bSIsICJ3cmFwIiwgInN0b3JhZ2UiLCAiaSIsICJpIiwgIkJlY2gzMk1heFNpemUiLCAiZW5jb2RlQmVjaDMyIiwgImVuY29kZUJ5dGVzIiwgImVuY3J5cHQiLCAiZGVjcnlwdCIsICJpIiwgImkiLCAiYmFzZTY0IiwgImVuY3J5cHQiLCAiZGVjcnlwdCIsICJpIiwgImRlY3J5cHQiLCAiZW5jcnlwdCIsICJjb21wbGV0ZSIsICJ0YXJnZXQiLCAidXRmOERlY29kZXIiLCAidXRmOEVuY29kZXIiLCAibWluUGxhaW50ZXh0U2l6ZSIsICJtYXhQbGFpbnRleHRTaXplIiwgImdldENvbnZlcnNhdGlvbktleSIsICJnZXRNZXNzYWdlS2V5cyIsICJjYWxjUGFkZGVkTGVuIiwgIndyaXRlVTE2QkUiLCAibnVtIiwgInBhZCIsICJ1bnBhZCIsICJobWFjQWFkIiwgImRlY29kZVBheWxvYWQiLCAiZW5jcnlwdCIsICJkZWNyeXB0IiwgInYyIiwgInN0b3JhZ2UiLCAidjIiLCAic2Vzc2lvbiIsICJzdG9yYWdlIiwgImxvZyIsICJub3ciLCAiaSIsICJkZWNyeXB0IiwgImVuY3J5cHQiLCAibmlwNDRFbmNyeXB0IiwgIm5pcDQ0RGVjcnlwdCJdCn0K
